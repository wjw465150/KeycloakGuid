{"./":{"url":"./","title":"序言","keywords":"","body":"Keycloak GuidKeycloak Guid Keycloak 是一个为浏览器和 RESTful Web 服务提供 SSO 的集成。基于 OAuth 2.0 和 JSON Web Token(JWT) 规范。最开始是面向 JBoss 和 Wildfly 通讯，但已经为其他诸如 Tomcat、Jetty、Node.js、Rails、Grails 等环境提供解决方案。 主要功能： SSO and Single Log Out for browser applications 浏览器应用程序的SSO和单点注销 Social Broker. Enable Google, Facebook, Yahoo, Twitter social login with no code required. 社交代理。 启用Google，Facebook，Yahoo，Twitter社交登录，无需代码。 Optional User Registration 可选的用户注册 Password and TOTP support (via Google Authenticator). Client cert auth coming soon. 密码和TOTP支持（通过Google身份验证器）。 客户端证书即将推出。 Customizable themes for user facing pages 面向用户页面的可自定义主题 OAuth Bearer token auth for REST Services REST服务的OAuth承载令牌身份验证 Integrated Browser App to REST Service token propagation 集成浏览器应用程序以REST服务令牌传播 OAuth 2.0 Grant requests OAuth 2.0授予请求 CORS Support CORS支持 CORS Web Origin management and validation CORS Web Origin管理和验证 Completely centrally managed user and role mapping metadata. Minimal configuration at the application side 完全集中管理的用户和角色映射元数据。 应用程序端的最小配置 Admin Console for managing users, roles, role mappings, applications, user sessions, allowed CORS web origins, and OAuth clients. 管理控制台，用于管理用户，角色，角色映射，应用程序，用户会话，允许的CORS Web源和OAuth客户端。 Deployable as a WAR, appliance, or an Openshift cloud service (SaaS). 可部署为WAR，设备或Openshift云服务（SaaS）。 Supports JBoss AS7, EAP 6.x, and Wildfly applications. support Node.js, RAILS, GRAILS, and other non-Java applications. 支持JBoss AS7，EAP 6.x和Wildfly应用程序。 支持Node.js，RAILS，GRAILS和其他非Java应用程序。 Javascript/HTML 5 adapter for pure Javascript apps 适用于纯Javascript应用的Javascript/HTML 5适配器 Session management from admin console 管理控制台的会话管理 Revocation policies 撤销策略 密码策略 密 OpenID Connect Support OpenID Connect支持 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-15 10:00:05 "},"01_Getting Started Guide.html":{"url":"01_Getting Started Guide.html","title":"Keycloak入门指南","keywords":"","body":"Keycloak入门指南1. 概述2. 安装和启动2.1. 安装分发文件2.2. 启动服务器2.3. 创建管理员帐户2.4. 登录管理控制台3. 创建领域和用户3.1. 在你开始之前3.2. 创建一个新领域3.3. 创建新用户3.4. 用户帐户服务4. 保护JBoss Servlet应用程序4.1. 在你开始之前4.2. 安装客户端适配器4.3. 下载，构建和部署应用程序代码4.4. 创建和注册客户端4.5. 配置子系统Keycloak入门指南 原文地址: https://www.keycloak.org/docs/latest/getting_started/index.html 1. 概述 本指南可帮助您开始使用Keycloak。 它涵盖了服务器配置和默认数据库的使用。 不包括高级部署选项。 有关功能或配置选项的更深入说明，请参阅其他参考指南。 2. 安装和启动 本节介绍如何在独立模式下启动Keycloak服务器，设置初始管理员用户，以及登录Keycloak管理控制台。 2.1. 安装分发文件 下载Keycloak服务器分发文件: keycloak-6.0.1.[zip|tar.gz] 该文件可以从 Keycloak downloads下载. keycloak-6.0.1.[zip|tar.gz]文件是服务器专用的分发版。它只包含运行Keycloak服务器的脚本和二进制文件。 将文件放在您选择的目录中，并使用unzip或tar实用程序来提取它。 Linux/Unix $ unzip keycloak-6.0.1.zip or $ tar -xvzf keycloak-6.0.1.tar.gz Windows > unzip keycloak-6.0.1.zip 2.2. 启动服务器 要启动Keycloak服务器，请转到服务器分发的bin目录并运行standalone启动脚本： Linux/Unix $ cd bin $ ./standalone.sh Windows > ...\\bin\\standalone.bat 2.3. 创建管理员帐户 服务器启动后，在web浏览器中打开http://localhost:8080/auth。欢迎页面将指示服务器正在运行。 输入用户名和密码来创建初始管理用户。 该帐户将被允许登录到master(主) realm(域)的管理控制台，您将从该控制台创建域和用户，并注册应用程序，这些应用程序将由Keycloak进行保护。 如果使用localhost连接，则只能在欢迎页面上创建初始管理员用户。 这是一项安全预防措施。 您可以使用add-user-keycloak.sh脚本在命令行创建初始管理员用户。 有关详细信息，请参阅服务器安装和配置指南和服务器管理指南。 2.4. 登录管理控制台 创建初始管理员帐户后，请使用以下步骤登录管理控制台： 单击 Welcome 页面上的 Administration Console 链接或直接转到控制台URL http://localhost:8080/auth/admin/ 在Welcome页面上键入您创建的用户名和密码，打开Keycloak Admin Console。 Admin Console(管理控制台) 3. 创建领域和用户 在本节中，您将在Keycloak管理控制台中创建一个新领域，并向该领域添加新用户。 您将使用该新用户登录到您的新域并访问所有用户都可以访问的内置用户帐户服务。 3.1. 在你开始之前 (https://www.keycloak.org/docs/latest/getting_started/index.html#_install-boot) 3.2. 创建一个新领域 要创建新领域，请完成以下步骤： 转到http://localhost:8080/auth/admin/并使用您在安装和启动中创建的帐户登录Keycloak管理控制台。 从Master下拉菜单中，单击Add Realm。 当您登录到主域时，此下拉菜单会列出所有现有域。 在Name字段中输入demo，然后单击Create。 创建领域后，将打开主管理控制台页面。 注意，当前的域现在设置为demo。 通过单击Select realm下拉菜单中的条目，在管理master领域和刚刚创建的领域之间切换。 3.3. 创建新用户 要在demo域中创建新用户，以及该新用户的临时密码，请完成以下步骤： 从菜单中，单击Users以打开用户列表页面。 在空用户列表的右侧，单击Add User以打开添加用户页面。 在Username`字段中输入名称; 这是唯一必填字段。 单击保存以保存数据并打开新用户的管理页面。 单击Credentials选项卡为新用户设置临时密码。 输入新密码并确认。 单击Reset Password将用户密码设置为您指定的新密码。 此密码是临时的，用户需要在首次登录后进行更改。 要创建持久密码，请在单击Reset Password之前将Temporary开关从On翻转到Off。 3.4. 用户帐户服务 创建新用户后，打开用户下拉菜单并选择Sign Out，注销管理控制台。 转到http://localhost:8080/auth/realms/demo/account并使用刚创建的用户登录您的demo域的用户帐户服务。 输入您创建的用户名和密码。 成功登录后，您将需要创建一个永久密码，除非您在创建密码时将Temporary设置更改为Off。 将打开用户帐户服务页面。 默认情况下，领域中的每个用户都可以访问此帐户服务。 在此页面中，您可以更新配置文件信息并更改或添加其他凭据。 有关此服务的详细信息，请参阅服务器管理指南。 4. 保护JBoss Servlet应用程序 本节介绍如何通过以下方式在WildFly应用程序服务器上保护Java servlet应用程序： 在WildFly应用程序服务器分发上安装Keycloak客户端适配器 在Keycloak管理控制台中创建和注册客户端应用程序 配置要由Keycloak保护的应用程序 4.1. 在你开始之前 在确保Java servlet应用程序安全之前，必须完成Keycloak的安装并创建初始管理员用户，如安装和引导中所示。 有一点需要注意：尽管WildFly与Keycloak捆绑在一起，但您不能将其用作应用程序容器。 相反，您必须在与Keycloak服务器相同的机器上运行单独的WildFly实例才能运行Java servlet应用程序。 使用与WildFly不同的端口运行Keycloak，以避免端口冲突。 要调整使用的端口，请在从命令行启动服务器时更改jboss.socket.binding.port-offset系统属性的值。 此属性的值是一个数字，将添加到Keycloak服务器打开的每个端口的基值。 要在调整端口的同时启动Keycloak服务器： Linux/Unix $ cd bin $ ./standalone.sh -Djboss.socket.binding.port-offset=100 Windows > ...\\bin\\standalone.bat -Djboss.socket.binding.port-offset=100 启动Keycloak后，转到http://localhost:8180/auth/admin/以访问管理控制台。 4.2. 安装客户端适配器 下载WildFly发行版并将其从压缩文件中提取到计算机上的目录中。 从keycloak.org下载WildFly OpenID Connect适配器分发版。 将此文件的内容解压缩到WildFly发行版的根目录中。 为您的平台运行适当的脚本： WildFly 10 和 Linux/Unix $ cd bin $ ./jboss-cli.sh --file=adapter-install-offline.cli WildFly 10 和 Windows > cd bin > jboss-cli.bat --file=adapter-install-offline.cli Wildfly 11 和 Linux/Unix $ cd bin $ ./jboss-cli.sh --file=adapter-elytron-install-offline.cli Wildfly 11 和 Windows > cd bin > jboss-cli.bat --file=adapter-elytron-install-offline.cli 此脚本将对您的应用服务器分发的…/standalone/configuration/standalone.xml文件进行必要的编辑，可能需要一些时间才能完成。 启动应用程序服务器。 Linux/Unix $ cd bin $ ./standalone.sh Windows > ...\\bin\\standalone.bat 4.3. 下载，构建和部署应用程序代码 您必须在您的机器上安装以下软件，并在您的PATH路径中可用，然后才能继续: Java JDK 8 Apache Maven 3.1.1 or higher Git 您可以通过克隆https://github.com/keycloak/keycloak-quickstarts上的Keycloak Quickstarts存储库来获取代码。 快速入门旨在与最新的Keycloak版本一起使用。 在继续之前，请确保已启动WildFly应用程序服务器。 要下载，构建和部署代码，请完成以下步骤。 克隆项目 $ git clone https://github.com/keycloak/keycloak-quickstarts $ cd keycloak-quickstarts/app-profile-jee-vanilla $ mvn clean wildfly:deploy 在安装过程中，您将在应用程序服务器控制台窗口中看到一些文本滚动。 要确认应用程序已成功部署，请转至http://localhost:8080/vanilla，然后将显示登录页面。 如果单击Login，浏览器将弹出BASIC auth登录对话框。 但是，应用程序尚未受到任何身份提供程序的保护，因此您在对话框中输入的任何内容都将导致服务器发回Forbidden消息。 您可以通过查找应用程序的web.xml文件中的设置来确认应用程序当前是通过BASICauthentication保护的。 4.4. 创建和注册客户端 要在Keycloak管理控制台中定义和注册客户端，请完成以下步骤： 使用您的管理员帐户登录管理控制台。 在左上角的下拉菜单中选择并管理 Demo 领域。 单击左侧菜单中的Clients以打开“客户端”页面。 Clients(客户端) 在右侧，单击Create。 填写如下所示的字段： Add Client(添加客户端) 单击Save以创建客户端应用程序条目。 单击Keycloak管理控制台中的Installation选项卡以获取配置模板。 选择Keycloak OIDC JBoss Subsystem XML以生成XML模板。 复制内容以供下一部分使用。 模板 XML 4.5. 配置子系统 要配置部署应用程序的WildFly实例，以便Keycloak保护此应用程序，请完成以下步骤。 打开部署了应用程序的WildFly实例中的standalone/configuration/standalone.xml文件，并搜索以下文本： 修改此文本以准备粘贴内容的文件来自Keycloak OIDC JBoss Subsystem XML模板我们获得Keycloak管理控制台Installation选项卡，通过将XML条目从自动关闭更改为使用一对开放和结束标签： 将模板的内容粘贴到元素中，如下例所示： demo http://localhost:8180/auth true EXTERNAL vanilla 将name更改为vanilla.war： ... 重新启动应用程序服务器。 转到http://localhost:8080/vanilla并单击Login。 当Keycloak登录页面打开时，使用您在创建新用户中创建的用户登录。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-01-04 20:07:52 "},"02_Server Installation and Configuration Guide.html":{"url":"02_Server Installation and Configuration Guide.html","title":"KeyCloak服务器安装和配置指南","keywords":"","body":"KeyCloak服务器安装和配置指南1. 指南概述1.1. 建议额外的外部文档2. 安装2.1. 系统需求2.2. 安装分布式文件2.3. 分布式目录结构3. 选择工作模式3.1. 独立模式3.2. 独立的集群模式3.3. 域集群模式3.4. 跨数据中心复制模式4. 管理子系统配置4.1. 配置SPI提供程序4.2. 启动WildFly CLI4.3. CLI嵌入式模式4.4. CLI GUI模式4.5. CLI脚本4.6. CLI食谱5. 特征文件6. 关系数据库设置6.1. RDBMS设置清单6.2. 打包JDBC驱动程序6.3. 声明并加载JDBC驱动程序6.4. 修改Keycloak数据源6.5. 数据库配置6.6. 数据库的Unicode注意事项7. 网络设置7.1. 绑定地址7.2. 套接字端口绑定7.3. 设置 HTTPS/SSL7.4. 传出HTTP请求8. 集群8.1. 推荐的网络架构8.2. 集群示例8.3. 设置负载均衡器或代理8.4. 粘性会话8.5. 多播网络设置8.6. 确保集群通信安全8.7. 串行化集群启动8.8. 启动群集8.9. 故障排除9. 服务器缓存配置9.1. 驱逐和到期9.2. 复制和故障转移9.3. 禁用缓存9.4. 在运行时清除缓存10. Keycloak安全代理10.1. 代理安装和运行10.2. 代理配置10.3. 应用程序配置10.4. Keycloak标识头KeyCloak服务器安装和配置指南 原文地址: https://www.keycloak.org/docs/latest/server_installation/index.html 1. 指南概述 本指南的目的是介绍在首次启动Keycloak服务器之前需要完成的步骤。如果您只是想测试Keycloak，它几乎是用它自己的嵌入式和本地数据库开箱即用。对于将要在生产环境中运行的实际部署，您需要决定如何在运行时管理服务器配置(独立或域模式)，为Keycloak存储配置共享数据库，设置加密和HTTPS，最后设置Keycloak在集群中运行。本指南将详细介绍部署服务器之前必须进行的任何预引导决策和设置的各个方面。 需要特别注意的一点是，Keycloak派生自WildFly应用程序服务器。配置Keycloak的许多方面都围绕着WildFly配置元素。如果您想深入了解更多细节，本指南通常会将您引向手册之外的文档。 1.1. 建议额外的外部文档 Keycloak构建在WildFly应用服务器之上，它的子项目包括Infinispan(用于缓存)和Hibernate(用于持久性)。本指南只涵盖基础设施级配置的基础知识。强烈建议您仔细阅读WildFly及其子项目的文档。以下是文档链接: WildFly 16 Documentation 2. 安装 安装Keycloak非常简单，只需下载并解压缩即可。本章回顾了系统的需求以及发行版的目录结构。 2.1. 系统需求 以下是运行Keycloak身份验证服务器的要求: 能运行Java的任何操作系统 Java 8 JDK zip 或者 gzip 和 tar 至少512M内存 At least 1G of diskspace 共享的外部数据库，如PostgreSQL、MySQL、Oracle等。如果要在集群中运行，Keycloak需要一个外部共享数据库。有关更多信息，请参阅本指南的数据库配置部分。 如果您想在集群中运行，最好计算机上的网络支持多播。Keycloak可以在没有多播的情况下集群化，但这需要大量的配置更改。有关更多信息，请参见本指南的集群部分。 在Linux上，建议使用/dev/urandom作为随机数据的来源，以防止由于缺少可用的熵而导致密钥隐藏挂起，除非您的安全策略强制使用/dev/random。要在Oracle JDK 8和OpenJDK 8上实现这一点，请设置 java.security.egd系统属性为file:/dev/urandom。 2.2. 安装分布式文件 Keycloak服务器有三个可下载的发行版: 'keycloak-6.0.0.[zip|tar.gz]' 'keycloak-overlay-6.0.0.[zip|tar.gz]' 'keycloak-demo-6.0.0.[zip|tar.gz]' 'keycloak-6.0.0.[zip|tar.gz]'文件是服务器唯一的发行版。它只包含运行Keycloak服务器的脚本和二进制文件。要解压缩这个文件，只需运行操作系统的unzip或gunzip和tar实用程序。 'keycloak-overlay-6.0.0.[zip|tar.gz]'文件是一个WildFly插件，允许您在现有的WildFly发行版上安装Keycloak服务器。我们不支持用户希望在同一服务器实例上运行应用程序和Keycloak。要安装Keycloak服务包，只需将其解压到WildFly发行版的根目录中，打开shell中的bin目录并运行./jboss-cli.[sh|bat] --file=keycloak-install.cli。 'keycloak-demo-6.0.0.[zip|tar.gz]' 包含服务器二进制文件、所有文档和所有示例。它预先配置了OIDC和SAML客户机应用程序适配器，可以在不进行任何配置的情况下开箱即用地部署任何分发示例。此分发版只建议那些想要测试Keycloak的用户使用。我们不支持用户在生产环境中运行演示发行版。 要解压缩这些文件，请运行unzip或gunzip和tar实用程序。 2.3. 分布式目录结构 本章将介绍服务器分发版的目录结构。 分布式目录结构 让我们来看看其中一些目录的用途: bin/ 它包含各种脚本，可以启动服务器，也可以在服务器上执行其他管理操作。 domain/ 当在域模式中运行Keycloak时，它包含配置文件和工作目录。 modules/ 这些都是服务器使用的所有Java库。 providers/ 如果您正在为keycloak编写扩展，可以将扩展放在这里。有关这方面的更多信息，请参见服务器开发人员指南。 standalone/ 这包含配置文件和工作目录时，运行Keycloak在独立模式。 themes/ 此目录包含用于服务器显示的任何UI所需要的所有html、样式表、JavaScript文件和图像。在这里，您可以修改现有的主题或创建自己的主题。有关这方面的更多信息，请参见服务器开发人员指南。 3. 选择工作模式 在生产环境中部署Keycloak之前，您需要决定使用哪种类型的操作模式。您会在集群中运行Keycloak吗?您需要一种集中的方式来管理服务器配置吗?您选择的操作模式将影响您如何配置数据库、配置缓存，甚至如何启动服务器。 Keycloak构建在WildFly应用服务器之上。本指南只讨论在特定模式下部署的基础知识。如果您想了解这方面的具体信息，最好的去处是WildFly 16 Documentation. 3.1. 独立模式 独立的操作模式只在您希望运行一个且仅运行一个Keycloak服务器实例时才有用。它不适用于集群部署，而且所有缓存都是非分布式的，并且只在本地使用。 不建议在生产中使用独立模式，因为只有一个故障点。如果您的单机模式服务器宕机，用户将无法登录。这种模式只适用于测试驱动和使用Keycloak的功能. 3.1.1. 独立的启动脚本 当以独立模式运行服务器时，您需要运行一个特定的脚本来启动服务器，这取决于您的操作系统。这些脚本位于服务器分发版的 bin/ 目录中。 独立的启动脚本 启动服务器: Linux/Unix $ .../bin/standalone.sh Windows > ...\\bin\\standalone.bat 3.1.2. 独立的配置 本指南的大部分内容将指导您如何配置Keycloak的基础设施级别方面。 这些方面是在配置文件中配置的，该配置文件特定于Keycloak派生的应用程序服务器。在独立操作模式下，该文件位于 .. / independent /configuration/standalone.xml 中。 此文件还用于配置特定于Keycloak组件的非基础设施级别的内容。 独立的配置文件 在服务器运行时对该文件所做的任何更改都不会生效，甚至可能被服务器覆盖。而是使用命令行脚本或WildFly的web控制台。 更多信息参见WildFly 16 Documentation。 3.2. 独立的集群模式 当您希望在集群中运行Keycloak时，可以使用独立集群操作模式。此模式要求在希望运行服务器实例的每台计算机上都有Keycloak分发版的副本。这种模式最初很容易部署，但是会变得相当麻烦。要进行配置更改，您必须修改每台机器上的每个发行版。对于大型集群，这可能会耗费时间并容易出错。 3.2.1. 独立的集群配置 该发行版有一个主要预配置的app服务器配置文件，用于在集群中运行。它具有用于网络、数据库、缓存和发现的所有特定基础设施设置。此文件驻留在 …/standalone/configuration/standalone-ha.xml. 这个配置中缺少一些东西。如果不配置共享数据库连接，就不能在集群中运行Keycloak。您还需要在集群前面部署某种类型的负载均衡器。 本指南的集群 和 数据库 部分将指导您了解这些内容。 标准HA配置 在服务器运行时对该文件所做的任何更改都不会生效，甚至可能被服务器覆盖。建议使用命令行脚本或WildFly的web控制台。 更多信息参见 WildFly 16 Documentation | 3.2.2. 独立集群启动脚本 使用与在独立模式下相同的引导脚本启动Keycloak。不同之处在于，您传递了一个额外的标志来指向HA配置文件。 独立集群启动脚本 启动服务器: Linux/Unix $ .../bin/standalone.sh --server-config=standalone-ha.xml Windows > ...\\bin\\standalone.bat --server-config=standalone-ha.xml 3.3. 域集群模式 域模式是一种集中管理和发布服务器配置的方法。 在标准模式下运行集群会随着集群规模的增长而迅速恶化。每次需要更改配置时，都必须在集群中的每个节点上执行。 域模式解决了这个问题通过提供一个中心位置存储和发布配置。 设置起来可能相当复杂，但最终是值得的。这个功能被内置到WildFly应用服务器中，Keycloak就是从这个应用服务器派生的。 本指南将介绍域模式的基本知识。关于如何在集群中设置域模式的详细步骤应该从WildFly 16 Documentation. 获得。 以下是在域模式下运行的一些基本概念。 域控制器 域控制器是一个进程，负责存储、管理和发布集群中每个节点的一般配置。这个进程是集群中的节点获取其配置的中心点。 主机控制器 主机控制器负责管理特定机器上的服务器实例。 您将其配置为运行一个或多个服务器实例。域控制器还可以与每台机器上的主机控制器交互来管理集群。 为了减少运行进程的数量，域控制器还充当它所运行机器上的主机控制器。 域配置文件 域配置文件是一组命名的配置文件，可供服务器用于引导。 域控制器可以定义不同服务器使用的多个域配置文件。 服务器组 服务器组是服务器的集合。它们被管理并配置为一个。您可以将一个域配置文件分配给一个服务器组，该组中的每个服务都将使用该域配置文件作为它们的配置。 在域模式下，在主节点上启动域控制器。集群的配置位于域控制器中。 接下来，在群集中的每台计算机上启动主机控制器。 每个主机控制器部署配置指定将在该计算机上启动的Keycloak服务器实例数。 当主机控制器启动时，它启动的Keycloak服务器实例与配置时一样多。这些服务器实例从域控制器中提取配置。 3.3.1. 域配置 本指南的其他各章将介绍如何配置数据库、HTTP网络连接、缓存和其他与基础设施相关的内容。 虽然独立模式使用 standalone.xml 文件来配置这些内容，但域模式使用 .../domain/configuration/domain.xml 配置文件。 这里定义了Keycloak 服务器的域配置文件和服务器组。 domain.xml 在域控制器运行时对该文件所做的任何更改都不会生效，甚至可能被服务器覆盖。建议使用命令行脚本或WildFly的web控制台。 更多信息参见WildFly 16 Documentation 我们来看看这个 domain.xml 文件的某些内容。 auth-server-standalone 和 auth-server-clustered profile XML块是您进行大量配置决策的地方。 您将在此处配置网络连接，缓存和数据库连接等内容。 auth-server配置 ... ... auth-server-standalone配置是非集群设置。 auth-server-clustered配置是集群设置。 如果你进一步向下滚动，你会看到定义了各种socket-binding-groups。 socket-binding-groups ... ... ... 此配置定义使用每个Keycloak服务器实例打开的各种连接器的默认端口映射。 包含$ {...}的任何值都是可以在命令行上使用-D开关重写的值，例如: $ domain.sh -Djboss.http.port=80 Keycloak服务器组的定义位于 server-groups XML块中。 它指定在主机控制器启动实例时使用的域配置文件(default)以及Java VM的一些默认引导参数。 它还将socket-binding-group绑定到服务器组。 server group 3.3.2. 主机控制器配置 Keycloak附带了两个主机控制器配置文件，它们位于 .../domain/configuration/ 目录中：host-master.xml 和 host-slave.xml。 host-master.xml 配置为启动域控制器，负载均衡器和一个Keycloak服务器实例。 host-slave.xml 配置为与域控制器通信并启动一个Keycloak服务器实例。 负载均衡器不是必需的服务。 它的存在使您可以轻松地在开发计算机上测试驱动器群集。 虽然可以在生产中使用，但如果您要使用其他基于硬件或软件的负载均衡器，则可以选择替换它。 主机控制器配置 要禁用负载均衡器服务器实例，请编辑 host-master.xml 并注释掉或删除 \"load-balancer\" 条目。 ... 关于此文件的另一个有趣的事情是声明身份验证服务器实例。 它有一个port-offset设置。 domain.xmlsocket-binding-group或服务器组中定义的任何网络端口都将添加port-offset的值。 对于此示例域设置，我们执行此操作，以便负载平衡器服务器打开的端口不会与启动的身份验证服务器实例冲突。 ... 3.3.3. 服务器实例工作目录 主机文件中定义的每个Keycloak服务器实例在 …/domain/servers/{SERVER NAME} 下创建一个工作目录。可以在其中进行其他配置，并且服务器实例需要或创建的任何临时，日志或数据文件也可以放在那里。 每个服务器目录的结构最终看起来像任何其他WildFly启动的服务器。 工作目录 3.3.4. 域启动脚本 在域模式下运行服务器时，根据您的操作系统，需要运行特定的脚本来启动服务器。 这些脚本位于服务器分发的 bin/ 目录中。 域启动脚本 启动服务器: Linux/Unix $ .../bin/domain.sh --host-config=host-master.xml Windows > ...\\bin\\domain.bat --host-config=host-master.xml 运行启动脚本时，您需要通过--host-config开关传入您将要使用的主机控制配置文件。 3.3.5. 集群域示例 您可以使用开箱即用的 domain.xml 配置测试驱动器集群。这个示例域是用来在一台机器上运行并启动的: 1个域控制器 1个HTTP负载均衡器 2个Keycloak服务器实例 要模拟在两台计算机上运行集群，您将运行domain.sh脚本两次以启动两个单独的主机控制器。 第一个是主控主机控制器，它将启动域控制器，HTTP负载平衡器和一个Keycloak认证服务器实例。 第二个是从属主机控制器，它只启动一个认证服务器实例。 设置从属控制器到域控制器的连接 在启动之前，您必须配置从属主机控制器，以便它可以安全地与域控制器通信。如果不这样做，则从属主机将无法从域控制器获取集中式配置。 要设置安全连接，您必须创建服务器管理员用户和将在主服务器和从服务器之间共享的密钥。 您可以通过运行 …/bin/add-user.sh 脚本来完成此操作。 当您运行脚本时，选择 Management User 并回答 yes ，当它询问您是否将新用户用于一个AS进程以连接到另一个AS进程时。 这将生成一个秘密值，您需要将其剪切并粘贴到 …/domain/configuration/host-slave.xml 文件中。 添加: App Server Admin $ add-user.sh What type of user do you wish to add? a) Management User (mgmt-users.properties) b) Application User (application-users.properties) (a): a Enter the details of the new user to add. Using realm 'ManagementRealm' as discovered from the existing property files. Username : admin Password recommendations are listed below. To modify these restrictions edit the add-user.properties configuration file. - The password should not be one of the following restricted values {root, admin, administrator} - The password should contain at least 8 characters, 1 alphabetic character(s), 1 digit(s), 1 non-alphanumeric symbol(s) - The password should be different from the username Password : Re-enter Password : What groups do you want this user to belong to? (Please enter a comma separated list, or leave blank for none)[ ]: About to add user 'admin' for realm 'ManagementRealm' Is this correct yes/no? yes Added user 'admin' to file '/.../standalone/configuration/mgmt-users.properties' Added user 'admin' to file '/.../domain/configuration/mgmt-users.properties' Added user 'admin' with groups to file '/.../standalone/configuration/mgmt-groups.properties' Added user 'admin' with groups to file '/.../domain/configuration/mgmt-groups.properties' Is this new user going to be used for one AS process to connect to another AS process? e.g. for a slave host controller connecting to the master or for a Remoting connection for server to server EJB calls. yes/no? yes To represent the user add the following to the server-identities definition add-user.sh不会将用户添加到Keycloak服务器，而是添加到基础JBoss企业应用程序平台。 上述脚本中使用和生成的凭据仅用于示例目的。 请使用系统上生成的。 现在将秘密值剪切并粘贴到 …/domain/configuration/host-slave.xml 文件中，如下所示： 您还需要在 …/domain/configuration/host-slave.xml 文件中添加已创建用户的 username： 运行启动脚本 由于我们在一台开发机器上模拟双节点集群，因此您将运行两次启动脚本： 启动 主 $ domain.sh --host-config=host-master.xml 启动 从属 $ domain.sh --host-config=host-slave.xml 要试用它，请打开浏览器并转到 http://localhost:8080/auth。 3.4. 跨数据中心复制模式 跨数据中心复制模式适用于您希望跨多个数据中心在集群中运行Keycloak，最常用的是使用位于不同地理区域的数据中心站点。 使用此模式时，每个数据中心都有自己的Keycloak服务器集群。 本文档将引用以下示例体系结构图来说明和描述简单的跨数据中心复制用例。 示例架构图 3.4.1. 先决条件 由于这是一个高级主题，我们建议您首先阅读以下内容，它们提供了宝贵的背景知识： 集群与Keycloak 设置跨数据中心复制时，您将使用更多独立的Keycloak集群，因此您必须了解集群的工作方式以及基本概念和要求，例如负载平衡，共享数据库和多播。 JBoss数据网格跨数据中心复制 Keycloak使用JBoss Data Grid（JDG）在数据中心之间复制Infinispan数据。 3.4.2. 技术细节 本节介绍了如何完成Keycloak跨数据中心复制的概念和详细信息。 Data(数据) Keycloak是有状态的应用程序。 它使用以下作为数据源： 数据库用于保存永久数据，例如用户信息。 Infinispan缓存用于缓存来自数据库的持久性数据，还用于保存一些短期和频繁更改的元数据，例如用于用户会话。 Infinispan通常比数据库快得多，但是使用Infinispan保存的数据不是永久性的，并且预计不会在集群重启期间持续存在。 在我们的示例架构中，有两个名为 site1 和 site2 的数据中心。 对于跨数据中心复制，我们必须确保两个数据源都可靠地工作，并且来自 site1 的Keycloak服务器最终能够读取site2上的Keycloak服务器保存的数据。 根据环境，您可以选择是否愿意： 可靠性 - 通常用于 主/主 模式。 写在site1上的数据必须立即在site2上可见。 性能 - 通常用于 主/被模式。 写在site1上的数据不需要立即在site2上可见。 在某些情况下，数据可能在site2上根本不可见。 For more details, see Modes. 3.4.3. 请求处理 最终用户的浏览器向前端负载均衡器发送HTTP请求。 此负载均衡器通常是HTTPD或WildFly，带有mod_cluster，NGINX，HA代理，或者某些其他类型的软件或硬件负载均衡器。 然后，负载均衡器将其接收的HTTP请求转发到基础Keycloak实例，这些实例可以在多个数据中心之间传播。 负载平衡器通常为粘性会话提供支持, 这意味着负载均衡器能够始终将来自同一用户的所有HTTP请求转发到同一数据中心内的同一Keycloak实例。 从客户端应用程序发送到负载均衡器的HTTP请求称为“反向通道请求”。终端用户的浏览器不会看到这些，因此不能作为用户和负载平衡器之间的粘性会话的一部分。 对于反向信道请求，负载均衡器可以将HTTP请求转发到任何数据中心中的任何Keycloak实例。 这很有挑战性，因为一些OpenID Connect和一些SAML流需要来自用户和应用程序的多个HTTP请求。 由于我们不能可靠地依赖粘性会话来强制将所有相关请求发送到同一数据中心中的同一个Keycloak实例，因此我们必须跨数据中心复制一些数据，以便在特定流期间由后续HTTP请求查看数据。 3.4.4. 模式 根据您的要求，跨数据中心复制有两种基本操作模式： 主/备 - 这里，用户和客户端应用程序仅将请求发送到单个数据中心的Keycloak节点。 第二个数据中心仅用作保存数据的备份。 如果主数据中心出现故障，通常可以从第二个数据中心恢复数据。 主/主 - 这里，用户和客户端应用程序将请求发送到两个数据中心的Keycloak节点。 这意味着数据需要立即在两个站点上可见，并且可以立即从两个站点上的Keycloak服务器中使用。 如果Keycloak服务器在site1上写入一些数据，并且要求在site1上的写入完成后，立即可以通过site2上的Keycloak服务器读取数据。 主动/被动模式对性能更好。 有关如何为任一模式配置高速缓存的详细信息，请参阅：SYNC或ASYNC备份. 3.4.5. 数据库 Keycloak使用关系数据库管理系统(RDBMS)来持久保存有关领域，客户端，用户等的一些元数据。 有关详细信息，请参阅服务器安装指南的本章。 在跨数据中心复制设置中，我们假设两个数据中心都与同一个数据库通信，或者每个数据中心都有自己的数据库节点，并且两个数据库节点在数据中心之间同步复制。 在这两种情况下，当site1上的Keycloak服务器持久保存某些数据并提交事务时，要求这些数据立即在site2上的后续数据库事务中可见。 数据库设置的细节超出了Keycloak的范围，但是像MariaDB和Oracle这样的许多RDBMS供应商都提供了复制数据库和同步复制。 我们与这些供应商一起测试Keycloak： Oracle Database 12c Release 1 (12.1) RAC Galera 3.12 cluster for MariaDB server version 10.1.19-MariaDB 3.4.6. Infinispan缓存 本节首先介绍Infinispan缓存的高级描述。 下面是缓存设置的更多细节。 Authentication sessions (认证会话) 在Keycloak中，我们有认证会话的概念。 有一个名为 authenticationSessions 的独立Infinispan缓存用于在特定用户的身份验证期间保存数据。 来自此缓存的请求通常只涉及浏览器和Keycloak服务器，而不是应用程序。 在这里，我们可以依赖粘性会话，即使您处于主/主 模式，也不需要跨数据中心复制 authenticationSessions 缓存内容。 Action tokens (动作令牌) 我们还有动作令牌的概念， 通常用于用户需要通过电子邮件异步地确认操作的场景。例如，在“忘记密码”流期间，actiontokenInfinispan缓存用于跟踪有关操作令牌的元数据，比如已经使用了哪个操作令牌，因此不能第二次重用。这通常需要跨数据中心复制。 持久数据的缓存和失效 Keycloak使用Infinispan来缓存持久数据，以避免对数据库的许多不必要的请求。 缓存提高了性能，但它增加了额外的挑战。 当某些Keycloak服务器更新任何数据时，所有数据中心中的所有其他Keycloak服务器都需要知道它，因此它们会使其缓存中的特定数据无效。 Keycloak使用称为realms ，users 和 authorization 的本地Infinispan缓存来缓存持久数据。 我们使用单独的缓存 work，它在所有数据中心中复制。 工作缓存本身不会缓存任何实际数据。 它仅用于在群集节点和数据中心之间发送失效消息。 换句话说，当更新数据时，例如用户john，Keycloak节点将失效消息发送到同一数据中心的所有其他集群节点以及所有其他数据中心。 收到无效通知后，每个节点都会从其本地缓存中使相应的数据无效。 User sessions (用户会话) Infinispan缓存称为 sessions, clientSessions, offlineSessions 和 offlineClientSessions，所有这些缓存通常都需要跨数据中心进行复制。 这些缓存用于保存有关用户会话的数据，这些数据对用户的浏览器会话长度有效。 缓存必须处理来自最终用户和应用程序的HTTP请求。 如上所述，在此实例中无法可靠地使用粘性会话，但我们仍希望确保后续HTTP请求可以查看最新数据。 因此，数据通常在数据中心之间复制。 Brute force protection (强力保护) 最后，loginFailures 缓存用于跟踪有关失败登录的数据，例如用户john 输入错误密码的次数。 详细说明此处。 管理员是否应该跨数据中心复制此缓存。 要准确计算登录失败次数，需要进行复制。 另一方面，不复制此数据可以节省一些性能。 因此，如果性能比准确的登录失败计数更重要，则可以避免复制。 有关如何配置高速缓存的更多详细信息，请参阅调整JDG高速缓存配置。 3.4.7. 通信细节 keycover使用多个独立的Infinispan缓存集群。每个Keycloak 节点都与相同数据中心中的其他Keycloak 节点在集群中，但不包含不同数据中心的Keycloak节点。 Keycloak节点不直接与来自不同数据中心的Keycloak节点通信。 Keycloak节点使用外部JDG（实际上是Infinispan服务器）跨数据中心进行通信。 这是使用Infinispan HotRod协议。 Keycloak端上的Infinispan缓存必须配置为remoteStore，以确保数据被保存到远程缓存中。JDG服务器之间有单独的Infinispan集群，因此保存在 site1 上的JDG1上的数据被复制到 site2上的JDG2上。 最后，接收JDG服务器通过客户机侦听器通知集群中的Keycloak服务器，这是HotRod协议的一个特性。然后更新它们的Infinispan缓存，特定的用户会话也可以在 site2 的Keycloak节点上看到。 有关更多细节，请参见示例架构图。 3.4.8. 基本设置 在本例中，我们描述了使用两个数据中心，site1 和 site2。 每个数据中心由1个Infinispan服务器和2个Keycloak服务器组成。 我们最终将拥有2台Infinispan服务器和4台Keycloak服务器。 Site1 由Infinispan服务器，jdg1 和2个Keycloak服务器，node11 和 node12 组成。 Site2 由Infinispan服务器，jdg2 和2个Keycloak服务器，node21 和 node22 组成。 Infinispan服务器 jdg1 和 jdg2 通过 RELAY2 协议和 backup 的Infinispan缓存相互连接，其方式与JDG文档中描述的类似。 Keycloak服务器 node11 和 node12 彼此形成一个集群，但它们不直接与 site2 中的任何服务器通信。 它们使用HotRod协议（远程缓存）与Infinispan服务器 jdg1 进行通信。 有关详细信息，请参阅通信详细信息。 同样的细节适用于 node21 和 node22。它们彼此集群，仅使用HotRod协议与jdg2服务器通信。 我们的示例设置假定所有4个Keycloak服务器都与同一个数据库通信。 在生产中，建议在数据库中使用单独的同步复制数据库，如数据库中所述。 Infinispan服务器设置 请按照以下步骤设置Infinispan服务器： 下载Infinispan 9.4.8服务器并解压缩到您选择的目录。 该位置将在后面的步骤中称为 JDG1_HOME 。 在JGroups子系统的配置中更改 JDG1_HOME/standalone/configuration/clustered.xml中的那些内容： 在 channels 元素下添加 xsite 通道，它将使用tcp 堆栈： 在 udp 堆栈的末尾添加 relay 元素。 我们将以我们的站点为 site1 的方式配置它，而我们将备份的另一个站点是 site2 ： ... false 配置tcp堆栈使用TCPPING协议而不是'MPING。 删除MPING元素并将其替换为TCPPING。initial_hosts元素指向主机jdg1和jdg2`： jdg1[7600],jdg2[7600] false ... 这只是一个让程序快速运行的示例设置。在生产中，JGroups ' RELAY2 '不需要使用' tcp '栈， 但是您可以配置任何其他堆栈。例如，如果数据中心之间的网络支持多播，可以使用默认的udp堆栈。 只要确保Infinispan和Keycloak集群是相互不可发现的。 同样，您不需要使用 TCPPING 作为发现协议。 在生产中，你可能不会使用TCPPING因为它是静态的。 最后，站点名称也是可配置的。 这个更详细的设置的详细信息超出了Keycloak文档的范围。 有关更多详细信息，请参阅Infinispan文档和JGroups文档。 将其添加到名为clustered的缓存容器下的JDG1_HOME/standalone/configuration/clustered.xml中： ... 有关 replicated-cache-configuration 中的配置选项的详细信息，请参阅调整JDG缓存配置，其中包含信息 关于调整其中一些选项。 与以前的版本不同，Infinispan服务器 replicated-cache-configuration 需要在没有 transaction 元素的情况下进行配置。 有关详细信息，请参阅故障排除 。 在通过网络访问受保护的缓存之前，某些Infinispan服务器版本需要授权。 如果您使用推荐的Infinispan 9.4.8服务器，则不应该看到任何问题，并且可以（并且应该）忽略此步骤。 与授权相关的问题可能仅适用于Infinispan服务器的某些其他版本。 Keycloak需要更新包含脚本的 ___ script_cache 缓存。 如果访问此缓存时出错，则需要在 clustered.xml 配置中设置授权，如下所述： 在 部分中，添加一个安全领域： ... not-so-secret-password 在服务器核心子系统中，添加 ，如下所示： ... 在端点子系统中，将身份验证配置添加到Hot Rod连接器： ... 将服务器复制到第二个位置，稍后将称之为 JDG2_HOME。 在 JDG2_HOME/standalone/configuration/clustered.xml交换site1和site2，反之亦然，在JGroups子系统中的 relay 配置和cache-subsystem中 backups 的配置。 例如： relay元素应如下所示： false 像这样的backups元素： 由于Infinispan子系统不支持用表达式替换站点名，因此目前需要为两个站点上的JDG服务器提供不同的配置文件。有关详细信息，请参见this issue。 启动服务器 jdg1: cd JDG1_HOME/bin ./standalone.sh -c clustered.xml -Djava.net.preferIPv4Stack=true \\ -Djboss.default.multicast.address=234.56.78.99 \\ -Djboss.node.name=jdg1 -b PUBLIC_IP_ADDRESS 启动服务器jdg2。由于存在不同的组播地址，因此jdg1和jdg2服务器并不直接集群在一起;相反，它们只是通过RELAY2协议连接，TCP JGroups堆栈用于它们之间的通信。启动命令是这样的: cd JDG2_HOME/bin ./standalone.sh -c clustered.xml -Djava.net.preferIPv4Stack=true \\ -Djboss.default.multicast.address=234.56.78.100 \\ -Djboss.node.name=jdg2 -b PUBLIC_IP_ADDRESS 要验证此时通道是否工作，您可能需要使用JConsole并连接到正在运行的JDG1或JDG2服务器。当您使用MBean jgroups:type=protocol,cluster=\"cluster\",protocol=RELAY2和操作printRoutes时，应该会看到如下输出: site1 --> _jdg1:site1 site2 --> _jdg2:site2 当您使用MBean jgroups:type=protocol,cluster=\"cluster\",protocol=GMS 时，您应该看到属性成员只包含一个成员: 在JDG1上应该是这样的: (1) jdg1 在JDG2上是这样的: (1) jdg2 在生产中，您可以在每个数据中心拥有更多Infinispan服务器。 您只需要确保同一数据中心内的Infinispan服务器使用相同的多播地址（换句话说，在启动时使用相同的 jboss.default.multicast.address ）。 然后在GMS 协议视图的jconsole中，您将看到当前集群的所有成员。 Keycloak服务器设置 将Keycloak服务器分发解压缩到您选择的位置。 它将在后面称为 NODE11。 为KeycloakDS数据源配置共享数据库。 建议使用MySQL或MariaDB进行测试。 有关详细信息，请参阅数据库。 在生产中，您可能需要在每个数据中心都有一个单独的数据库服务器，并且两个数据库服务器应该同步复制到彼此。 在示例设置中，我们只使用一个数据库并将所有4个Keycloak服务器连接到它。 编辑 NODE11/standalone/configuration/standalone-ha.xml : 将属性site添加到JGroups UDP协议： 在名为keycloak的cache-container元素下添加这个module属性： 在work缓存下添加remote-store： true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory 在sessions缓存下添加这样的remote-store： true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory 对于offlineSessions，clientSessions，offlineClientSessions，loginFailures和actionTokens缓存执行相同的操作（与sessions缓存的唯一区别是cache属性值不同）： true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory 将远程存储的出站套接字绑定添加到socket-binding-group元素配置中： 分布式缓存authenticationSessions和其他缓存的配置保持不变。 （可选）在logging子系统下启用DEBUG日志记录： 将NODE11复制到3个其他目录，后面称为NODE12，NODE21和NODE22。 启动 NODE11 : cd NODE11/bin ./standalone.sh -c standalone-ha.xml -Djboss.node.name=node11 -Djboss.site.name=site1 \\ -Djboss.default.multicast.address=234.56.78.1 -Dremote.cache.host=jdg1 \\ -Djava.net.preferIPv4Stack=true -b PUBLIC_IP_ADDRESS 启动 NODE12 : cd NODE12/bin ./standalone.sh -c standalone-ha.xml -Djboss.node.name=node12 -Djboss.site.name=site1 \\ -Djboss.default.multicast.address=234.56.78.1 -Dremote.cache.host=jdg1 \\ -Djava.net.preferIPv4Stack=true -b PUBLIC_IP_ADDRESS 应该连接集群节点。类似这样的东西应该同时出现在NODE11和NODE12的日志中: Received new cluster view for channel keycloak: [node11|1] (2) [node11, node12] 日志中的通道名称可能不同。 启动 NODE21 : cd NODE21/bin ./standalone.sh -c standalone-ha.xml -Djboss.node.name=node21 -Djboss.site.name=site2 \\ -Djboss.default.multicast.address=234.56.78.2 -Dremote.cache.host=jdg2 \\ -Djava.net.preferIPv4Stack=true -b PUBLIC_IP_ADDRESS 它不应该使用NODE11和NODE12连接到集群，而是分开一个： Received new cluster view for channel keycloak: [node21|0] (1) [node21] 启动 NODE22 : cd NODE22/bin ./standalone.sh -c standalone-ha.xml -Djboss.node.name=node22 -Djboss.site.name=site2 \\ -Djboss.default.multicast.address=234.56.78.2 -Dremote.cache.host=jdg2 \\ -Djava.net.preferIPv4Stack=true -b PUBLIC_IP_ADDRESS 它应该在与NODE21的集群中： Received new cluster view for channel keycloak: [node21|1] (2) [node21, node22] 日志中的通道名称可能不同。 测试: 转到 http://node11:8080/auth/ 并创建初始管理员用户。 转到 http://node11:8080/auth/admin 并以admin身份登录管理控制台。 打开第二个浏览器并转到任何节点 http://node12:8080/auth/admin 或http://node21:8080/auth/admin 或 http://node22:8080/auth/admin 。 登录后，您应该能够在所有4台服务器上的特定用户，客户端或领域的“会话”选项卡中看到相同的会话。 在对Keycloak管理控制台进行任何更改后（例如，更新某些用户或某些领域），更新应立即在4个节点中的任何一个上可见，因为缓存应在任何地方正确无效。 如果需要，请检查server.logs。 登录或注销后，这样的消息应该在所有节点上 NODEXY/standalone/log/server.log： 2017-08-25 17:35:17,737 DEBUG [org.keycloak.models.sessions.infinispan.remotestore.RemoteCacheSessionListener] (Client-Listener-sessions-30012a77422542f5) Received event from remote store. Event 'CLIENT_CACHE_ENTRY_REMOVED', key '193489e7-e2bc-4069-afe8-f1dfa73084ea', skip 'false' 3.4.9. 跨DC部署的管理 本节包含与跨数据中心复制相关的一些提示和选项。 当您在数据中心内运行Keycloak服务器时， 需要在 KeycloakDS 数据源中引用的数据库已经在该数据中心中运行并可用。 outbound-socket-binding引用的Infinispan服务器也是必要的， 从Infinispan缓存remote-store元素引用的,已经在运行。否则Keycloak服务器将无法启动。 如果要支持数据库故障转移和更高的可靠性，每个数据中心都可以拥有更多数据库节点。 有关如何在数据库端进行设置以及如何在Keycloak端配置KeycloakDS数据源的详细信息，请参阅数据库和JDBC驱动程序的文档。 每个数据中心都可以在集群中运行更多Infinispan服务器。 如果您需要一些故障转移和更好的容错能力，这将非常有用。 用于Infinispan服务器和Keycloak服务器之间通信的HotRod协议具有以下功能：Infinispan服务器将自动向Keycloak服务器发送有关Infinispan群集更改的新拓扑， 因此，Keycloak端的远程存储将知道它可以连接到哪个Infinispan服务器。阅读Infinispan和WildFly文档了解更多细节。 强烈建议在启动任何站点中的Keycloak服务器之前，在每个站点中运行一个主Infinispan服务器。 在我们的例子中，我们首先在所有Keycloak服务器之前启动了jdg1和jdg2。 如果您仍然需要运行Keycloak服务器并且备份站点处于脱机状态，建议您在站点上的Infinispan服务器上手动切换备份站点，如使站点脱机并联机中所述。 如果不手动将不可用站点脱机，则第一次启动可能会失败，或者在启动期间可能会出现一些异常，直到备份站点因配置的失败操作计数而自动脱机。 3.4.10. 使网站脱机和在线 例如，假设这种情况： 站点site2从site1角度完全脱机。 这意味着site2上的所有Infinispan服务器都关闭**或者site1和site2之间的网络被破坏了。 您在站点site1中运行Keycloak服务器和Infinispan服务器jdg1 有人在site1上的Keycloak服务器上登录。 来自site1的Keycloak服务器将尝试将会话写入jdg1服务器上的远程缓存，该服务器应该将数据备份到site2中的jdg2服务器。 有关详细信息，请参阅通信详细信息。 服务器jdg2离线或无法访问jdg1。 所以从jdg1到jdg2的备份将失败。 在jdg1日志中抛出异常，故障也将从jdg1服务器传播到Keycloak服务器，因为配置了默认的FAIL备份失败策略。 有关备份策略的详细信息，请参阅备份失败策略。 错误也会在Keycloak方面发生，用户可能无法完成登录。 根据您的环境，站点之间的网络可能或多或少可能不可用或暂时中断（裂脑）。如果发生这种情况，最好是site1上的Infinispan服务器知道site2上的Infinispan服务器不可用，因此它们将停止尝试访问jdg2站点上的服务器，并且不会发生备份故障。这就是所谓的“让网站脱机”。 使网站脱机 有两种方法可以使网站脱机。 由管理员手动 - 管理员可以使用jconsole或其他工具运行一些JMX操作来手动使特定站点脱机。 这非常有用，尤其是在计划中断时。使用jconsole或CLI，您可以连接到jdg1服务器并使site2脱机。 有关这方面的更多详细信息，请参见JDG文档。 通常需要对SYNC或ASYNC备份中提到的所有Keycloak缓存执行这些步骤。 自动 - 经过一定数量的失败备份后，site2通常会自动脱机。 这是通过在Infinispan服务器设置中配置的缓存配置中的take-offline元素的配置来完成的。 这个示例显示，如果在60秒内至少有3个后续备份失败，并且没有任何成功备份，那么对于特定的单个缓存，站点将自动脱机。 自动使站点脱机是非常有用的，特别是当站点之间的网络中断是计划外的。 缺点是，在检测到网络中断之前，会有一些失败的备份，这也可能意味着应用程序端出现故障。 例如，某些用户的登录失败或登录超时很长。 特别是如果使用值为 FAIL 的 failure-policy。 每个缓存都会单独跟踪站点是否处于脱机状态。 把网站在线 一旦你的网络恢复了，site1 和 site2 可以互相交谈，你可能需要把网站上线。这需要通过JMX或CLI手动完成，方法类似于使站点脱机。同样，您可能需要检查所有缓存并将它们联机。 一旦网站上线，通常最好: 做状态转移。 手动清除缓存。 3.4.11. 状态转移 国家转移是必需的手动步骤。 Infinispan服务器不会自动执行此操作，例如在裂脑期间，只有管理员可以决定哪个站点具有首选项，因此是否需要在两个站点之间双向进行状态转移，或者只是单向进行，如同仅来自site1到site2，但不是从site2到site1。 双向状态转移将确保site1上的裂脑后创建的实体被转移到site2上。 这不是问题，因为它们在site2上还不存在。 类似地，在site2上裂脑后创建的实体将被转移到site1上。 可能有问题的部分是那些在两个站点上的裂脑之前存在并且在两个站点上的裂脑期间更新的实体。 当这种情况发生时，其中一个站点将胜出，并覆盖第二个站点在脑裂期间完成的更新。 不幸的是，没有任何通用的解决方案。 脑裂和网络中断只是状态，通常不可能100%正确地处理站点之间100%一致的数据。 就Keycloak而言，它通常不是一个关键问题。 在最坏的情况下，用户需要重新登录到他们的客户端，或者有不正确的loginFailures计数用于强力保护。 有关如何处理裂脑的更多提示，请参阅Infinispan/JGroups文档。 状态转移也可以通过JMX在Infinispan服务器端完成。 操作名称是pushState。 几乎没有其他操作来监视状态，取消推送状态等。 有关状态转移的更多信息，请参阅Infinispan docs。 3.4.12. 清除缓存 在脑裂之后，可以安全地在Keycloak管理控制台中手动清除缓存。 这是因为在site1上的数据库中可能存在一些数据发生了变化，并且由于该事件，缓存应该被无效，并且在脑裂期间没有被转移到site2。 因此，site2上的Keycloak节点可能仍然在其缓存中有一些陈旧的数据。 要清除缓存，请参阅清除服务器缓存。 当网络恢复时，仅在任何随机站点上的一个Keycloak节点上清除缓存就足够了。 缓存失效事件将发送到所有站点中的所有其他Keycloak节点。 但是，需要对所有缓存（领域，用户，密钥）执行此操作。 有关详细信息，请参阅清除服务器缓存。 3.4.13. 调整JDG缓存配置 本节包含配置JDG缓存的技巧和选项。 备份失败策略 默认情况下，JDG的clustered.xml文件中Infinispan缓存配置中的备份failure-policy配置级别为FAIL。 您可以根据需要将其更改为WARN或IGNORE。 FAIL和WARN之间的区别在于，当使用FAIL并且Infinispan服务器尝试将数据备份到另一个站点并且备份失败时，失败将传播回调用者（Keycloak服务器）。 备份可能会失败，因为第二个站点暂时无法访问，或者存在尝试更新同一实体的并发事务。 在这种情况下，Keycloak服务器将重试该操作几次。 但是，如果重试失败，则用户可能会在更长的超时后看到错误。 使用WARN时，失败的备份不会从Infinispan服务器传播到Keycloak服务器。 用户将看不到错误，将忽略失败的备份。 将有一个较短的超时，通常为10秒，因为这是备份的默认超时。 它可以通过backup元素的属性timeout来改变。 不会重试。 Infinispan服务器日志中只会出现一条WARNING消息。 潜在的问题是，在某些情况下，站点之间可能只有一些短暂的网络中断，其中重试（使用FAIL策略）可能有所帮助，因此使用WARN（不重试），将会有 站点间的一些数据不一致。 如果尝试在两个站点上同时更新同一实体，也会发生这种情况。 这些不一致有多糟糕？ 通常只表示用户需要重新进行身份验证。 当使用WARN策略时，可能会发生由actionTokens缓存提供并处理该特定密钥的一次性缓存实际上是单独使用，但可能“成功”两次写入相同的密钥。 但是，例如，OAuth2规范提及该代码必须是单一使用的。 使用WARN策略，可能无法严格保证，如果尝试在两个站点中同时写入相同的代码，则可以写两次相同的代码。 如果有较长的网络中断或裂脑，那么同时使用FAIL和WARN，其他站点将在一段时间后失效，如使站点离线和联机中所述。 使用默认的1分钟超时，通常需要1-3分钟才能使所有相关的缓存脱机。 之后，从最终用户的角度来看，所有操作都可以正常工作。 如网站离线和在线中所述，您只需在网站重新联机时手动恢复该网站。 总之，如果您希望站点之间频繁，更长时间的中断，并且您可以接受一些数据不一致且不是100％准确的一次性缓存，但您绝不希望最终用户看到错误和长时间超时，那么 切换到WARN。 WARN和IGNORE之间的区别在于，IGNORE警告不会写入JDG日志中。 请参阅Infinispan文档中的更多详细信息。 Lock acquisition timeout (锁定获取超时) 默认配置是在NON_DURABLE_XA模式下使用事务，获取超时为0.这意味着如果同一个密钥正在进行另一个事务，则事务将快速失败。 将其切换为0而不是默认10秒的原因是为了避免可能的死锁问题。 使用Keycloak，可能会发生同一实体（通常是会话实体或loginFailure）从两个站点同时更新。 这可能会在某些情况下导致死锁，这将导致事务被阻止10秒。 有关详细信息，请参阅此JIRA报告。 如果超时为0，则事务将立即失败，如果配置了具有值FAIL的备份failure-policy，则将从Keycloak重试该事务。 只要第二个并发事务完成，重试通常就会成功，并且实体将从两个并发事务中应用更新。 我们看到使用此配置进行并发事务的一致性和结果非常好，建议保留它。 唯一（非功能）问题是Infinispan服务器日志中的异常，每次锁定不可用时都会发生。 3.4.14. 同步或异步备份 backup元素的一个重要部分是strategy属性。 您必须决定是否需要SYNC或ASYNC。 我们有7个可能支持跨数据中心复制的缓存，这些缓存可以配置为3种不同的交叉直流模式： 同步 备份 异步 备份 不备份 如果使用SYNC备份，则备份是同步的，并且在第二个站点上处理备份后，调用者（Keycloak服务器）端的操作将被视为已完成。 这比ASYNC的性能更差，但另一方面，您确信在site2上对特定实体（如用户会话）的后续读取将从site1中看到更新。 此外，如果您想要数据一致性，则需要它。 与ASYNC一样，如果备份到其他站点失败，则不会通知呼叫者。 对于某些缓存，甚至可能根本不进行备份并完全跳过将数据写入Infinispan服务器。 要进行此设置，请不要将remote-store元素用于Keycloak端的特定缓存 (文件 KEYCLOAK_HOME/standalone/configuration/standalone-ha.xml) ，然后使用特定的replicated-cache元素。 在Infinispan服务器端也不需要。 默认情况下，所有7个缓存都配置了SYNC备份，这是最安全的选项。 以下是一些需要考虑的事项： 如果您使用的是主动/被动模式（所有Keycloak服务器都在单站点site1中，而site2中的Infinispan服务器仅用作备份。请参阅模式以获取更多详细信息），然后通常可以使用所有缓存的ASYNC策略来保存性能。 work缓存主要用于向其他站点发送一些消息，例如缓存失效事件。 它还用于确保某些特殊事件,例如userStorage同步;仅在单个站点上发生。 建议将此设置保持为`SYNC。 actionTokens缓存用作一次性缓存，用于跟踪某些令牌/票证仅使用一次。 例如，动作令牌或OAuth2代码。 可以将其设置为ASYNC以略微提高性能，但是不能保证特定票证真的是单次使用。 例如，如果两个站点中同时存在同一票证请求，那么两个请求都可能成功使用ASYNC策略。 所以你在这里设置的将取决于你是否更喜欢更好的安全性（SYNC策略）或更好的性能（ASYNC策略）。 loginFailures缓存可以在3种模式中的任何一种中使用。 如果根本没有备份，则意味着每个站点将单独计算用户的登录失败次数（请参阅Infinispan缓存了解详情）。 这具有一些安全隐患，但它具有一些性能优势。 此外，它还可以降低拒绝服务（DoS）攻击的风险。 例如，如果攻击者使用两个站点上的用户的用户名和密码模拟1000个并发请求，则意味着在站点之间传递大量消息，这可能导致网络拥塞。 ASYNC策略可能更糟糕，因为等待备份到其他站点不会阻止攻击者请求，从而导致可能更加拥挤的网络流量。 使用ASYNC策略，登录失败的次数也不准确。 对于数据中心之间网络速度较慢且DoS概率较低的环境，建议不要备份loginFailures缓存。 建议在SYNC中保留sessions和clientSessions缓存。 只有当您确定用户请求和反向通道请求（从请求处理中描述的客户端应用程序到Keycloak的请求）时，才可以将它们切换为ASYNC）将始终在同一站点上处理。 例如，如果： 您使用主动/被动模式，如模式所述。 您的所有客户端应用程序都使用Keycloak JavaScript Adapter。 JavaScript适配器在浏览器中发送反向通道请求，因此它们参与浏览器粘性会话，并将在与该用户的其他浏览器请求相同的群集节点（因此在同一站点上）结束。 您的负载均衡器能够根据客户端IP地址（位置）提供请求，并在两个站点上部署客户端应用程序。 例如，您有2个站点LON和NYC。 只要您的应用程序也部署在LON和NYC站点中，您就可以确保来自伦敦用户的所有用户请求将被重定向到LON站点中的应用程序以及LON站点中的Keycloak服务器。 来自LON站点客户端部署的Backchannel请求也将在LON站点中的Keycloak服务器上结束。 另一方面，对于美国用户，所有Keycloak请求，应用程序请求和反向通道请求将在NYC站点上处理。 对于offlineSessions和offlineClientSessions，它是相似的，不同之处在于，如果您从未计划为任何客户端应用程序使用脱机令牌，则根本不需要备份它们。 一般来说，如果您有疑问并且性能不适合您，那么将缓存保持在SYNC策略中会更安全。 关于切换到SYNC/ASYNC备份，请确保编辑backup元素的strategy属性。 例如这样： 注意cache-configuration元素的mode属性。 3.4.15. 故障排除 以下提示旨在帮助您解决问题： 建议通过基本设置并首先使用此工具，以便您对事情有所了解 工作。 阅读整篇文档以了解事物也是明智之举。 按照Infinispan服务器设置中的说明检入Infinispan的jconsole集群状态（GMS）和JGroups状态（RELAY）。 如果事情看起来不像预期，那么问题很可能出在Infinispan服务器的设置上。 对于Keycloak服务器，您应该在服务器启动期间看到这样的消息： 18:09:30,156 INFO [org.keycloak.connections.infinispan.DefaultInfinispanConnectionProviderFactory] (ServerService Thread Pool -- 54) Node name: node11, Site name: site1 在Keycloak服务器启动期间检查站点名称和节点名称是否与预期一致。 检查Keycloak服务器是否按预期位于集群中，包括只有来自同一数据中心的Keycloak服务器彼此在集群中。 这也可以通过GMS视图在JConsole中进行检查。 有关其他详细信息，请参阅集群疑难解答。 如果在启动Keycloak服务器期间有异常，如下所示： 17:33:58,605 ERROR [org.infinispan.client.hotrod.impl.operations.RetryOnFailureOperation] (ServerService Thread Pool -- 59) ISPN004007: Exception encountered. Retry 10 out of 10: org.infinispan.client.hotrod.exceptions.TransportException:: Could not fetch transport ... Caused by: org.infinispan.client.hotrod.exceptions.TransportException:: Could not connect to server: 127.0.0.1:12232 at org.infinispan.client.hotrod.impl.transport.tcp.TcpTransport.(TcpTransport.java:82) 它通常意味着Keycloak服务器无法访问自己的数据中心的Infinispan服务器。 确保按预期设置防火墙，并且可以连接Infinispan服务器。 如果在启动Keycloak服务器期间有异常，如下所示： 16:44:18,321 WARN [org.infinispan.client.hotrod.impl.protocol.Codec21] (ServerService Thread Pool -- 57) ISPN004005: Error received from the server: javax.transaction.RollbackException: ARJUNA016053: Could not commit transaction. ... 然后检查您站点的相应Infinispan服务器的日志，并检查是否未能备份到其他站点。 如果备份站点不可用，则建议将其切换为脱机，以便Infinispan服务器不会尝试备份到脱机站点，从而导致操作也在Keycloak服务器端成功通过。 有关详细信息，请参阅交叉DC部署管理。 检查可通过JMX获得的Infinispan统计信息。 例如，尝试登录，然后查看新会话是否已成功写入两个Infinispan服务器，并在那里的sessions缓存中可用。 这可以通过检查MBean的sessions缓存中的元素数来间接完成jboss.datagrid-infinispan:type=Cache,name=\"sessions(repl_sync)\",manager=\"clustered\",component=Statistics和属性numberOfEntries。 登录后，两个站点上的两个Infinispan服务器上都应该有一个numberOfEntries条目。 按照Keycloak服务器设置所述启用DEBUG日志记录。 例如，如果您登录并且认为新会话在第二个站点上不可用，则最好检查Keycloak服务器日志并检查是否按照Keycloak服务器设置中的说明触发了侦听器。 如果您不知道并想要在keycloak-user邮件列表上询问，那么从电子邮件中的两个数据中心的Keycloak服务器发送日志文件会很有帮助。 将日志片段添加到邮件或将日志放在某处并在电子邮件中引用它们。 如果您在site1上的Keycloak服务器上更新了实体，例如user，并且您没有在site2上的Keycloak服务器上看到该实体更新，那么问题可能在于复制同步数据库本身 或Keycloak缓存未正确无效。 您可以尝试暂时禁用Keycloak缓存，如here所述，以确定问题是否在数据库复制级别。 此外，手动连接到数据库并检查数据是否按预期更新可能会有所帮助。 这是特定于每个数据库的，因此您需要查阅数据库的文档。 有时您可能会在Infinispan服务器日志中看到与此类锁相关的异常： (HotRodServerHandler-6-35) ISPN000136: Error executing command ReplaceCommand, writing keys [[B0x033E243034396234..[39]]: org.infinispan.util.concurrent.TimeoutException: ISPN000299: Unable to acquire lock after 0 milliseconds for key [B0x033E243034396234..[39] and requestor GlobalTx:jdg1:4353. Lock is held by GlobalTx:jdg1:4352 这些例外不一定是个问题。 它们可能在任何时候在两个DC上触发同一实体的并发编辑时发生。 这在部署中很常见。 通常，Keycloak服务器会收到有关失败操作的通知，并会重试，因此从用户的角度来看，通常没有任何问题。 如果Keycloak服务器启动期间有异常，如下所示： 16:44:18,321 WARN [org.infinispan.client.hotrod.impl.protocol.Codec21] (ServerService Thread Pool -- 55) ISPN004005: Error received from the server: java.lang.SecurityException: ISPN000287: Unauthorized access: subject 'Subject with principal(s): []' lacks 'READ' permission ... 这些日志条目是Keycloak自动检测Infinispan是否需要身份验证的结果，并且意味着需要进行身份验证。 此时您将注意到服务器成功启动并且您可以安全地忽略这些或服务器无法启动。 如果服务器无法启动，请确保已按照Infinispan服务器设置中的说明正确配置Infinispan进行身份验证。 要防止包含此日志条目，可以通过在spi=connectionsInfinispan/provider=default配置中将remoteStoreSecurityEnabled属性设置为true来强制进行身份验证： ... ... ... 如果您尝试使用Keycloak对您的应用程序进行身份验证，但身份验证失败并且浏览器中存在无限次重定向，并且您在Keycloak服务器日志中看到如下错误： 2017-11-27 14:50:31,587 WARN [org.keycloak.events] (default task-17) type=LOGIN_ERROR, realmId=master, clientId=null, userId=null, ipAddress=aa.bb.cc.dd, error=expired_code, restart_after_timeout=true 这可能意味着您的负载均衡器需要设置为支持粘性会话。 确保在启动Keycloak服务器（Propertyjboss.node.name）期间使用的提供的路由名称包含负载均衡器服务器用于标识当前服务器的正确名称。 如果Infinispanwork缓存无限增长，您可能会遇到此Infinispan问题，这是由缓存项未正确过期引起的。 在这种情况下，使用空的标记更新缓存声明，如下所示： 如果您在Infinispan服务器日志中看到警告，例如： 18:06:19,687 WARN [org.infinispan.server.hotrod.Decoder2x] (HotRod-ServerWorker-7-12) ISPN006011: Operation 'PUT_IF_ABSENT' forced to return previous value should be used on transactional caches, otherwise data inconsistency issues could arise under failure situations 18:06:19,700 WARN [org.infinispan.server.hotrod.Decoder2x] (HotRod-ServerWorker-7-10) ISPN006010: Conditional operation 'REPLACE_IF_UNMODIFIED' should be used with transactional caches, otherwise data inconsistency issues could arise under failure situations 你可以忽略它们。 为了避免警告，Infinispan服务器端的缓存可以更改为事务缓存，但不推荐这样做，因为它可能导致由bug引起的其他一些问题https://issues.jboss.org/browse/ISPN-9323。 所以现在，警告只需要被忽略。 如果您在Infinispan服务器日志中看到错误，例如： 12:08:32,921 ERROR [org.infinispan.server.hotrod.CacheDecodeContext] (HotRod-ServerWorker-7-11) ISPN005003: Exception reported: org.infinispan.server.hotrod.InvalidMagicIdException: Error reading magic byte or message id: 7 at org.infinispan.server.hotrod.HotRodDecoder.readHeader(HotRodDecoder.java:184) at org.infinispan.server.hotrod.HotRodDecoder.decodeHeader(HotRodDecoder.java:133) at org.infinispan.server.hotrod.HotRodDecoder.decode(HotRodDecoder.java:92) at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248) 并且您在Keycloak日志中看到一些类似的错误，它可以表明正在使用的HotRod协议的版本不兼容。 当您尝试将Keycloak与JDG 7.2服务器或旧版本的Infinispan服务器一起使用时，可能会发生这种情况。 如果将protocolVersion属性作为附加属性添加到Keycloak配置文件中的remote-store元素，将会有所帮助。 例如： 2.6 4. 管理子系统配置 Keycloak的低级配置是通过编辑发行版中的standalone.xml，standalone-ha.xml或domain.xml文件来完成的。 此文件的位置取决于您的操作模式。 虽然您可以在此配置无限设置，但本节将重点介绍 keycloak-server 子系统的配置。 无论您使用哪个配置文件，keycloak-server 子系统的配置都是相同的。 keycloak-server子系统通常在文件末尾声明，如下所示： auth ... 请注意，在重新启动服务器之前，此子系统中的任何更改都不会生效。 4.1. 配置SPI提供程序 每个配置设置的细节在该设置的上下文中的其他地方讨论。 但是，了解用于在SPI提供程序上声明设置的格式很有用。 Keycloak是一个高度模块化的系统，具有很大的灵活性。 有超过50个服务提供程序接口（SPI），您可以交换每个SPI的实现。 SPI的实现称为提供者。 SPI声明中的所有元素都是可选的，但完整的SPI声明如下所示： myprovider 这里我们为SPImyspi定义了两个提供程序。 default-provider被列为myprovider。 但是由SPI来决定如何处理这个设置。 有些SPI允许多个提供商，有些则不允许。 所以default-provider可以帮助SPI选择。 另请注意，每个提供程序都定义了自己的一组配置属性。 上面两个提供商都有一个名为foo的属性这一事实只是巧合。 每个属性值的类型由提供程序解释。 但是，有一个例外。 考虑eventsStore SPI 的 jpa 提供程序： 我们看到值以方括号开头和结尾。 这意味着该值将作为列表传递给提供程序。 在此示例中，系统将向提供程序传递一个包含两个元素值 EVENT1 和 EVENT2 的列表。 要向列表中添加更多值，只需使用逗号分隔每个列表元素即可。 不幸的是，你需要使用 ＆quot; 来转义每个列表元素周围的引号。 4.2. 启动WildFly CLI 除了手动编辑配置外，您还可以通过 jboss-cli 工具发出命令来更改配置。 CLI允许您在本地或远程配置服务器。 当与脚本结合使用时，它尤其有用。 要启动WildFly CLI，您需要运行jboss-cli。 Linux/Unix $ .../bin/jboss-cli.sh Windows > ...\\bin\\jboss-cli.bat 这将带您到这样的提示： 提示 [disconnected /] 如果您希望在正在运行的服务器上执行命令，则首先执行connect命令。 连接 [disconnected /] connect connect [standalone@localhost:9990 /] 你可能会想，“我没有输入任何用户名或密码！”。 如果您在运行独立服务器或域控制器的同一台计算机上运行jboss-cli，并且您的帐户具有适当的文件权限，则无需设置或输入管理员用户名和密码。 请参阅 WildFly 16文档，了解如果您对该设置感到不舒服时如何使事情更安全的更多详细信息。 4.3. CLI嵌入式模式 如果您碰巧与独立服务器位于同一台计算机上，并且您希望在服务器未处于活动状态时发出命令，则可以将服务器嵌入CLI并在不允许传入请求的特殊模式下进行更改。 为此，首先使用您要更改的配置文件执行embed-server命令。 embed-server (嵌入服务器) [disconnected /] embed-server --server-config=standalone.xml [standalone@embedded /] 4.4. CLI GUI模式 CLI也可以在GUI模式下运行。 GUI模式启动Swing应用程序，允许您以图形方式查看和编辑 running 服务器的整个管理模型。 当您需要帮助格式化CLI命令并了解可用选项时，GUI模式特别有用。 GUI还可以从本地或远程服务器检索服务器日志。 从GUI模式开始 $ .../bin/jboss-cli.sh --gui 注意: 要连接到远程服务器，还要传递--connect选项。 使用--help选项可获取更多详细信息。 启动GUI模式后，您可能需要向下滚动才能找到节点 subsystem=keycloak-server 。 如果右键单击该节点并单击 Explore subsystem=keycloak-server ，您将获得一个仅显示keycloak-server子系统的新选项卡。 4.5. CLI脚本 CLI具有广泛的脚本功能。 脚本只是一个包含CLI命令的文本文件。 考虑一个关闭主题和模板缓存的简单脚本。 turn-off-caching.cli /subsystem=keycloak-server/theme=defaults/:write-attribute(name=cacheThemes,value=false) /subsystem=keycloak-server/theme=defaults/:write-attribute(name=cacheTemplates,value=false) 要执行脚本，我可以按照CLI GUI中的Scripts菜单，或者从命令行执行脚本，如下所示： $ .../bin/jboss-cli.sh --file=turn-off-caching.cli 4.6. CLI食谱 以下是一些配置任务以及如何使用CLI命令执行它们。 请注意，在第一个示例中的所有示例中，我们使用通配符路径 ** 表示您应该替换keycloak-server子系统的路径。 对于独立模式，这意味着: **` = `/subsystem=keycloak-server 对于域模式，这意味着： **` = `/profile=auth-server-clustered/subsystem=keycloak-server 4.6.1. 更改服务器的Web上下文 /subsystem=keycloak-server/:write-attribute(name=web-context,value=myContext) 4.6.2. 设置全局默认主题 **/theme=defaults/:write-attribute(name=default,value=myTheme) 4.6.3. 添加新的SPI和提供程序 **/spi=mySPI/:add **/spi=mySPI/provider=myProvider/:add(enabled=true) 4.6.4. 禁用提供商 **/spi=mySPI/provider=myProvider/:write-attribute(name=enabled,value=false) 4.6.5. 更改SPI的默认提供程序 **/spi=mySPI/:write-attribute(name=default-provider,value=myProvider) 4.6.6. 配置dblock SPI **/spi=dblock/:add(default-provider=jpa) **/spi=dblock/provider=jpa/:add(properties={lockWaitTimeout => \"900\"},enabled=true) 4.6.7. 为提供者添加或更改单个属性值 **/spi=dblock/provider=jpa/:map-put(name=properties,key=lockWaitTimeout,value=3) 4.6.8. 从提供程序中删除单个属性 **/spi=dblock/provider=jpa/:map-remove(name=properties,key=lockRecheckTime) 4.6.9. 在类型为List的提供程序属性上设置值 **/spi=eventsStore/provider=jpa/:map-put(name=properties,key=exclude-events,value=[EVENT1,EVENT2]) 5. 特征文件 Keycloak中的某些功能默认情况下未启用，这些功能包括不完全支持的功能。 此外，默认情况下会启用一些功能，但可以禁用这些功能。 可以启用和禁用的功能包括： 名称 描述 默认启用 支持级别 account2 New Account Management Console No Experimental account_api Account Management REST API No Preview admin_fine_grained_authz Fine-Grained Admin Permissions No Preview authz_drools_policy Drools Policy for Authorization Services No Preview docker Docker Registry protocol No Supported impersonation Ability for admins to impersonate users Yes Supported openshift_integration Extension to enable securing OpenShift No Preview script Write custom authenticators using JavaScript Yes Preview token_exchange Token Exchange Service No Preview 要启用所有预览功能，请启动服务器： bin/standalone.sh|bat -Dkeycloak.profile=preview 您可以通过在域模式下为server-one创建文件standalone/configuration/profile.properties（或domain/servers/server-one/configuration/profile.properties）来永久设置它。 将以下内容添加到文件中： profile=preview 要启用特定功能，请启动服务器： bin/standalone.sh|bat -Dkeycloak.profile.feature.=enabled 例如，要启用Docker，请使用-Dkeycloak.profile.feature.docker=enabled。 您可以通过添加以下内容在profile.properties文件中永久设置它： feature.docker=enabled 要禁用特定功能，请启动服务器： bin/standalone.sh|bat -Dkeycloak.profile.feature.=disabled 例如，要禁用模拟，请使用-Dkeycloak.profile.feature.impersonation=disabled。 您可以通过添加以下内容在profile.properties文件中永久设置它： feature.impersonation=disabled 6. 关系数据库设置 Keycloak附带了自己的基于Java的嵌入式关系数据库H2。 这是Keycloak用于保存数据的默认数据库，以便您可以开箱即用地运行身份验证服务器。 我们强烈建议您使用更多生产就绪的外部数据库替换它。 H2数据库在高并发情况下不是很可行，也不应该在集群中使用。 本章的目的是向您展示如何将Keycloak连接到更成熟的数据库。 Keycloak使用两种分层技术来持久保存其关系数据。 底层技术是JDBC。 JDBC是一种用于连接到RDBMS的Java API。 每种数据库类型都有不同的JDBC驱动程序，由数据库供应商提供。 本章讨论如何配置Keycloak以使用这些特定于供应商的驱动程序之一。 用于持久性的顶层技术是Hibernate JPA。 这是将Java对象映射到关系数据的关系映射API的对象。 Keycloak的大部分部署永远不会触及Hibernate的配置方面，但我们将讨论如果遇到这种罕见的情况，如何做到这一点。 在 WildFly 16文档 的数据源配置章节中更全面地介绍了数据源配置。 6.1. RDBMS设置清单 以下是为Keycloak配置RDBMS所需执行的步骤。 找到并下载数据库的JDBC驱动程序 将驱动程序JAR打包到模块中并将此模块安装到服务器中 在服务器的配置文件中声明JDBC驱动程序 修改数据源配置以使用数据库的JDBC驱动程序 修改数据源配置以定义数据库的连接参数 本章将使用PostgresQL作为其所有示例。 其他数据库遵循相同的安装步骤。 6.2. 打包JDBC驱动程序 查找并下载RDBMS的JDBC驱动程序JAR。 在使用此驱动程序之前，必须将其打包到模块中并将其安装到服务器中。 模块定义加载到Keycloak类路径中的JAR以及这些JAR对其他模块的依赖关系。 它们设置起来非常简单。 在Keycloak发行版的 …/modules/ 目录中，您需要创建一个目录结构来保存模块定义。 约定是使用JDBC驱动程序的Java包名称作为目录结构的名称。 对于PostgreSQL，创建目录 org/postgresql/main 。 将数据库驱动程序JAR复制到此目录中，并在其中创建一个空的 module.xml 文件。 模块目录 完成此操作后，打开 module.xml 文件并创建以下XML： 模块 XML 模块名称应与模块的目录结构匹配。 所以，org/postgresql 映射到org.postgresql。 resource-root path属性应指定驱动程序的JAR文件名。 其余的只是任何JDBC驱动程序JAR所具有的正常依赖关系。 6.3. 声明并加载JDBC驱动程序 接下来要做的是将新打包的JDBC驱动程序声明到部署配置文件中，以便在服务器启动时加载并变为可用。 执行此操作的位置取决于您的操作模式。 如果要在标准模式下部署，请编辑…/standalone/configuration/standalone.xml。 如果要以标准群集模式进行部署，请编辑.../standalone/configuration/ standalone-ha.xml。 如果要在域模式下部署，请编辑.../domain/configuration/domain.xml。 在域模式下，您需要确保编辑正在使用的配置文件：auth-server-standalone或auth-server-clustered 在配置文件中，搜索datasources子系统中的drivers XML块。 您应该看到为H2 JDBC驱动程序声明的预定义驱动程序。 这是您为外部数据库声明JDBC驱动程序的地方。 JDBC 驱动 ... org.h2.jdbcx.JdbcDataSource 在drivers XML块中，您需要声明一个额外的JDBC驱动程序。 它需要一个name，你可以选择任何你想要的。 您指定module属性，该属性指向您之前为驱动程序JAR创建的module包。 最后，您必须指定驱动程序的Java类。 下面是安装PostgreSQL驱动程序的示例，该驱动程序位于本章前面定义的模块示例中。 声明您的JDBC驱动程序 ... org.postgresql.xa.PGXADataSource org.h2.jdbcx.JdbcDataSource 6.4. 修改Keycloak数据源 声明JDBC驱动程序后，必须修改Keycloak用于将其连接到新外部数据库的现有数据源配置。 您将在注册JDBC驱动程序的相同配置文件和XML块中执行此操作。以下是设置与新数据库的连接的示例： 声明您的JDBC驱动程序 ... jdbc:postgresql://localhost/keycloak postgresql 20 William password ... 搜索KeycloakDS的datasource定义。 您首先需要修改connection-url。 供应商的JDBC实现的文档应指定此连接URL值的格式。 接下来定义你将使用的driver。 这是您在本章上一节中声明的JDBC驱动程序的逻辑名称。 每次要执行事务时，打开与数据库的新连接都很昂贵。 为了补偿，数据源实现维护了一个打开的连接池。 max-pool-size指定它将允许的最大连接数。 您可能希望根据系统负载更改此值。 最后，至少使用PostgreSQL，您需要定义连接到数据库所需的数据库用户名和密码。 您可能会担心示例中的明文是明文。 有一些方法可以对此进行模糊处理，但这超出了本指南的范围。 有关数据源功能的更多信息，请参阅 WildFly 16文档中的数据源配置章节。 6.5. 数据库配置 此组件的配置位于发行版中的standalone.xml，standalone-ha.xml或domain.xml文件中。 此文件的位置取决于您的操作模式。 数据库配置 ... ... 可能的配置选项是： dataSource DataSource的JNDI名称 jta boolean属性，用于指定datasource是否支持JTA driverDialect 数据库方言的值。在大多数情况下，您不需要指定此属性，因为Hibernate将自动检测方言。 initializeEmpty 如果为空则初始化数据库。 如果设置为false，则必须手动初始化数据库。 如果要手动将数据库集migrationStrategy初始化为manual，它将创建一个带有SQL命令的文件来初始化数据库。 默认为true。 migrationStrategy 用于迁移数据库的策略。 有效值为update，manual和validate。 Update将自动迁移数据库架构。 手动将使用可在数据库上手动执行的SQL命令将所需更改导出到文件。 验证将只检查数据库是否是最新的。 migrationExport 编写手动数据库初始化/迁移文件的位置的路径。 showSql 指定Hibernate是否应在控制台中显示所有SQL命令（默认为false）。 这非常冗长！ formatSql 指定Hibernate是否应格式化SQL命令（默认为true） globalStatsInterval 将从Hibernate记录关于执行的数据库查询和其他事情的全局统计信息。 统计信息始终以指定的时间间隔（以秒为单位）报告给服务器日志，并在每次报告后清除。 schema 指定要使用的数据库的schema 这些配置开关等在 WildFly 16开发指南中有所描述。 6.6. 数据库的Unicode注意事项 Keycloak中的数据库模式仅考虑以下特殊字段中的Unicode字符串： Realms: 显示名称，HTML显示名称 Federation Providers: 显示名称 Users: 用户名，给定名称，姓氏，属性名称和值 Groups: 名称，属性名称和值 Roles: 名字 Descriptions of objects: 对象的描述 否则，字符仅限于数据库编码中包含的字符，通常为8位。 但是，对于某些数据库系统，可以启用Unicode字符的UTF-8编码，并在所有文本字段中使用完整的Unicode字符集。 通常，与8位编码的情况相比，这通过较短的字符串最大长度来抵消。 某些数据库需要对数据库和/或JDBC驱动程序进行特殊设置才能处理Unicode字符。 请在下面找到您的数据库的设置。 请注意，如果此处列出了数据库，只要它在数据库级别和JDBC驱动程序上正确处理UTF-8编码，它仍然可以正常工作。 从技术上讲，Unicode支持所有字段的关键标准是数据库是否允许为VARCHAR和CHAR字段设置Unicode字符集。 如果是，那么Unicode很可能是合理的，通常以字段长度为代价。 如果它只支持NVARCHAR和NCHAR字段中的Unicode，则不太可能支持所有文本字段，因为Keycloak模式广泛使用VARCHAR和CHAR字段。 6.6.1. Oracle 数据库 如果数据库是在VARCHAR和CHAR字段中使用Unicode支持创建的（例如，使用AL32UTF8字符集作为数据库字符集），则可以正确处理Unicode字符。 JDBC驱动程序无需特殊设置。 如果数据库字符集不是Unicode，那么要在特殊字段中使用Unicode字符，需要使用连接属性oracle.jdbc.defaultNChar设置为true来配置JDBC驱动程序。 将oracle.jdbc.convertNcharLiterals连接属性设置为true可能是明智的，尽管不是绝对必要的。 可以将这些属性设置为系统属性或连接属性。 请注意，设置oracle.jdbc.defaultNChar可能会对性能产生负面影响。 有关详细信息，请参阅Oracle JDBC驱动程序配置文档。 6.6.2. Microsoft SQL Server 数据库 只为特殊字段正确处理Unicode字符。 不需要JDBC驱动程序或数据库的特殊设置。 6.6.3. MySQL 数据库 如果在CREATE DATABASE命令中的VARCHAR和CHARfields中使用Unicode支持创建数据库，则可以正确处理Unicode字符（例如，使用utf8字符集作为MySQL 5.5中的默认数据库字符集。请注意 由于对utf8字符集[1]的存储要求不同，utf8mb4字符集不起作用。 请注意，在这种情况下，对非特殊字段的长度限制不适用，因为创建列以容纳给定数量的字符，而不是字节。 如果数据库缺省字符集不允许存储Unicode，则只有特殊字段允许存储Unicode值。 在JDBC驱动程序设置方面，需要在JDBC连接设置中添加连接属性characterEncoding = UTF-8。 6.6.4. PostgreSQL 数据库 当数据库字符集为UTF8时，支持Unicode。 在这种情况下，Unicode字符可以在任何字段中使用，非特殊字段的字段长度不会减少。 不需要JDBC驱动程序的特殊设置。 7. 网络设置 keycover可能会因为一些网络限制而无法使用。首先，所有网络端点都绑定到localhost，因此auth服务器实际上只能在一台本地机器上使用。对于基于HTTP的连接，它不使用80和443之类的默认端口。HTTPS/SSL不是开箱即用配置的，如果没有它，keycover有许多安全漏洞。最后，keyshield可能经常需要与外部服务器建立安全的SSL和HTTPS连接，因此需要建立信任存储，以便正确验证端点。本章将讨论所有这些内容。 7.1. 绑定地址 默认情况下，keycover绑定到本地主机环回地址127.0.0.1。如果您希望网络上的身份验证服务器可用，那么这不是一个非常有用的缺省值。通常，我们建议在公共网络上部署反向代理或负载平衡器，并将流量路由到私有网络上的各个Keycloak服务器实例。无论哪种情况，您仍然需要设置网络接口来绑定到localhost之外的其他东西。 设置绑定地址非常简单，可以在命令行上使用选择操作模式章节 中讨论的 standalone.sh 或 domain.sh 启动脚本来完成。 $ standalone.sh -b 192.168.0.5 -b开关为任何公共接口设置IP绑定地址。 或者，如果您不想在命令行设置绑定地址，则可以编辑部署的配置文件配置。 打开配置文件配置文件（standalone.xml 或 domain.xml，具体取决于您的操作模式 ）并寻找interfaces XML块。 public接口对应于创建可公开使用的套接字的子系统。 其中一个子系统的示例是Web层，它提供Keycloak的身份验证端点。 management接口对应于WildFly管理层打开的套接字。 特别是允许您使用jboss-cli.sh命令行界面和WildFly Web控制台的套接字。 在查看public接口时，您会看到它有一个特殊字符串${jboss.bind.address:127.0.0.1}。 此字符串表示值127.0.0.1，可以通过设置Java系统属性在命令行上覆盖，即： $ domain.sh -Djboss.bind.address=192.168.0.5 -b只是这个命令的简写符号。 因此，您可以直接在配置文件配置中更改绑定地址值，也可以在启动时在命令行上更改它。 设置interface定义时，还有更多选项可用。 有关更多信息，请参阅 WildFly 16文档 中的网络接口。 7.2. 套接字端口绑定 为每个套接字打开的端口具有预定义的默认值，可以在命令行或配置中覆盖。 为了说明这种配置，让我们假装你在独立模式中运行并打开…/standalone/configuration/standalone.xml。 搜索socket-binding-group。 socket-bindings定义将由服务器打开的套接字连接。 这些绑定指定了它们使用的interface（绑定地址）以及它们将打开的端口号。 你最感兴趣的是： http 定义用于Keycloak HTTP连接的端口 https 定义用于Keycloak HTTPS连接的端口 ajp 此套接字绑定定义用于AJP协议的端口。 当您使用Apache HTTPD作为负载均衡器时，Apache HTTPD服务器将此协议与mod-cluster结合使用。 management-http 定义WildFly CLI和Web控制台使用的HTTP连接。 在域模式中运行时，设置套接字配置有点棘手，因为示例 domain.xml文件具有 多个socket-binding-groups定义。 如果向下滚动到server-group定义，你可以看到socket-binding-group用于每个server-group。 域套接字绑定 ... ... 设置socket-binding-group定义时，还有更多选项可用。 有关更多信息，请参阅 WildFly 16文档 中的套接字绑定组。 7.3. 设置 HTTPS/SSL 默认情况下，Keycloak未设置为处理SSL/HTTPS。 强烈建议您在Keycloak服务器本身或Keycloak服务器前面的反向代理上启用SSL。 此默认行为由每个Keycloak领域的SSL/HTTPS模式定义。 这在服务器管理指南中有更详细的讨论，但让我们给出一些上下文和这些模式的简要概述。 外部请求 只要您坚持使用localhost，127.0.0.1，10.0.x.x，192.168.x.x和172.16.x.x等私有IP地址，Keycloak就可以在没有SSL的情况下运行。 如果您没有在服务器上配置SSL/HTTPS，或者您尝试通过HTTP从非私有IP地址访问Keycloak，则会收到错误消息。 none (没有) Keycloak不需要SSL。当你玩弄东西时,这应该只用于开发。 所有请求 Keycloak要求所有IP地址都使用SSL。 可以在Keycloak管理控制台中配置每个领域的SSL模式。 7.3.1. 为Keycloak Server启用SSL/HTTPS 如果您没有使用反向代理或负载平衡器来处理HTTPS流量，则需要为Keycloak服务器启用HTTPS。 这涉及到 获取或生成包含SSL/HTTP流量的私钥和证书的密钥库 配置Keycloak服务器以使用此密钥对和证书。 创建证书和Java密钥库 为了允许HTTPS连接，您需要获取自签名或第三方签名证书并将其导入Java密钥库，然后才能在要部署Keycloak Server的Web容器中启用HTTPS。 自签名证书 在开发过程中，您可能没有第三方签名证书可用于测试Keycloak部署，因此您需要使用Java JDK附带的keytool实用程序生成自签名证书。 $ keytool -genkey -alias localhost -keyalg RSA -keystore keycloak.jks -validity 10950 Enter keystore password: secret Re-enter new password: secret What is your first and last name? [Unknown]: localhost What is the name of your organizational unit? [Unknown]: Keycloak What is the name of your organization? [Unknown]: Red Hat What is the name of your City or Locality? [Unknown]: Westford What is the name of your State or Province? [Unknown]: MA What is the two-letter country code for this unit? [Unknown]: US Is CN=localhost, OU=Keycloak, O=Test, L=Westford, ST=MA, C=US correct? [no]: yes 您应该使用您正在安装服务器的计算机的DNS名称来回答您的名字和姓氏是什么？问题。 出于测试目的，应使用localhost。 执行此命令后，keycloak.jks文件将在您执行keytool命令的同一目录中生成。 如果您需要第三方签名证书，但没有第三方签名证书，可以在cacert.org免费获取。 在这之前你必须先做一点设置。 首先要做的是生成证书申请： $ keytool -certreq -alias yourdomain -keystore keycloak.jks > keycloak.careq 其中yourdomain是为其生成此证书的DNS名称。 Keytool生成请求： -----BEGIN NEW CERTIFICATE REQUEST----- MIIC2jCCAcICAQAwZTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAk1BMREwDwYDVQQHEwhXZXN0Zm9y ZDEQMA4GA1UEChMHUmVkIEhhdDEQMA4GA1UECxMHUmVkIEhhdDESMBAGA1UEAxMJbG9jYWxob3N0 MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr7kck2TaavlEOGbcpi9c0rncY4HhdzmY Ax2nZfq1eZEaIPqI5aTxwQZzzLDK9qbeAd8Ji79HzSqnRDxNYaZu7mAYhFKHgixsolE3o5Yfzbw1 29RvyeUVe+WZxv5oo9wolVVpdSINIMEL2LaFhtX/c1dqiqYVpfnvFshZQaIg2nL8juzZcBjj4as H98gIS7khql/dkZKsw9NLvyxgJvp7PaXurX29fNf3ihG+oFrL22oFyV54BWWxXCKU/GPn61EGZGw Ft2qSIGLdctpMD1aJR2bcnlhEjZKDksjQZoQ5YMXaAGkcYkG6QkgrocDE2YXDbi7GIdf9MegVJ35 2DQMpwIDAQABoDAwLgYJKoZIhvcNAQkOMSEwHzAdBgNVHQ4EFgQUQwlZJBA+fjiDdiVzaO9vrE/i n2swDQYJKoZIhvcNAQELBQADggEBAC5FRvMkhal3q86tHPBYWBuTtmcSjs4qUm6V6f63frhveWHf PzRrI1xH272XUIeBk0gtzWo0nNZnf0mMCtUBbHhhDcG82xolikfqibZijoQZCiGiedVjHJFtniDQ 9bMDUOXEMQ7gHZg5q6mJfNG9MbMpQaUVEEFvfGEQQxbiFK7hRWU8S23/d80e8nExgQxdJWJ6vd0X MzzFK6j4Dj55bJVuM7GFmfdNC52pNOD5vYe47Aqh8oajHX9XTycVtPXl45rrWAH33ftbrS8SrZ2S vqIFQeuLL3BaHwpl3t7j2lMWcK1p80laAxEASib/fAwrRHpLHBXRcq6uALUOZl4Alt8= -----END NEW CERTIFICATE REQUEST----- 将此ca请求发送给您的CA. CA将向您签发签名证书并将其发送给您。 在导入新证书之前，必须获取并导入CA的根证书。 您可以从CA下载证书（即：root.crt）并导入如下： $ keytool -import -keystore keycloak.jks -file root.crt -alias root 最后一步是将新的CA生成的证书导入密钥库： $ keytool -import -alias yourdomain -keystore keycloak.jks -file your-certificate.cer 配置Keycloak以使用密钥库 现在您已拥有具有相应证书的Java密钥库，您需要配置Keycloak安装以使用它。 首先，您必须编辑standalone.xml，standalone-ha.xml 或 host.xml文件以使用密钥库并启用HTTPS。然后，您可以将密钥库文件移动到部署的 configuration/ 目录或您选择的位置中的文件，并提供它的绝对路径。 如果使用绝对路径，请从配置中删除可选的relative-to参数（参见操作模式）。 使用CLI添加新的security-realm元素： $ /core-service=management/security-realm=UndertowRealm:add() $ /core-service=management/security-realm=UndertowRealm/server-identity=ssl:add(keystore-path=keycloak.jks, keystore-relative-to=jboss.server.config.dir, keystore-password=secret) 如果使用域模式，命令应该在每个主机中使用/host=/前缀执行（为了在所有主机中创建security-realm），就像这样，你会重复 每个主机： $ /host=/core-service=management/security-realm=UndertowRealm/server-identity=ssl:add(keystore-path=keycloak.jks, keystore-relative-to=jboss.server.config.dir, keystore-password=secret) 在独立或主机配置文件中，security-realms元素应如下所示： 接下来，在独立或每个域配置文件中，搜索security-realm的任何实例。 修改https-listener以使用创建的领域： $ /subsystem=undertow/server=default-server/https-listener=https:write-attribute(name=security-realm, value=UndertowRealm) 如果使用域模式，请在命令前加上正在使用的配置文件：/profile=/。 结果元素server name=\"default-server\"是subsystem xmlns=\"urn:jboss:domain:undertow:8.0\"的子元素，应该包含以下节： ... 7.4. 传出HTTP请求 Keycloak服务器通常需要向其保护的应用程序和服务发出非浏览器HTTP请求。 auth服务器通过维护HTTP客户端连接池来管理这些传出连接。 您需要在standalone.xml，standalone-ha.xml或domain.xml中配置一些内容。 此文件的位置取决于您的操作模式。 HTTP客户端配置示例 可能的配置选项是： establish-connection-timeout-millis 建立套接字连接的超时时间。 socket-timeout-millis 如果传出请求未在此时间内收到数据，则超时连接。 connection-pool-size 池中可以有多少个连接（默认为128）。 max-pooled-per-route 每个主机可以合并多少个连接（默认为64个）。 connection-ttl-millis 最长连接时间（以毫秒为单位）。 默认情况下未设置。 max-connection-idle-time-millis 连接可能在连接池中保持空闲的最长时间（默认为900秒）。 将启动Apache HTTP客户端的后台清理线程。 设置为-1以禁用此检查和后台线程。 disable-cookies 默认为true。 设置为true时，这将禁用任何cookie缓存。 client-keystore 这是Java密钥库文件的文件路径。 此密钥库包含双向SSL的客户端证书。 client-keystore-password 客户端密钥库的密码。 如果设置了client-keystore，这是 REQUIRED 。 client-key-password 客户密钥的密码。 如果设置了client-keystore，这是 REQUIRED 。 proxy-mappings 注意传出HTTP请求的代理配置。 有关更多详细信息，请参阅传出HTTP请求的代理映射部分。 7.4.1. 传出HTTP请求的代理映射 Keycloak发送的传出HTTP请求可以选择使用基于逗号分隔的代理映射列表的代理服务器。 代理映射表示基于正则表达式的主机名模式和hostnamePattern;proxyUri形式的proxy-uri的组合，例如： .*\\.(google|googleapis)\\.com;http://www-proxy.acme.com:8080 要确定传出HTTP请求的代理，需要根据配置的主机名模式匹配目标主机名。第一个匹配模式确定要使用的代理uri。如果配置的模式都不匹配给定的主机名，则不使用代理。 代理uri的特殊值 NO_PROXY 可用于指示不应将任何代理用于匹配关联主机名模式的主机。可以在代理映射的末尾指定一个catch-all模式，为所有发出的请求定义一个默认代理。 以下示例演示了代理映射配置。 #All requests to Google APIs should use http://www-proxy.acme.com:8080 as proxy .*\\.(google|googleapis)\\.com;http://www-proxy.acme.com:8080 #All requests to internal systems should use no proxy .*\\.acme\\.com;NO_PROXY #All other requests should use http://fallback:8080 as proxy .*;http://fallback:8080 这可以通过以下jboss-cli命令配置。 请注意，您需要正确地转义正则表达式模式，如下所示。 echo SETUP: Configure proxy routes for HttpClient SPI # In case there is no connectionsHttpClient definition yet /subsystem=keycloak-server/spi=connectionsHttpClient/provider=default:add(enabled=true) # Configure the proxy-mappings /subsystem=keycloak-server/spi=connectionsHttpClient/provider=default:write-attribute(name=properties.proxy-mappings,value=[\".*\\\\.(google|googleapis)\\\\.com;http://www-proxy.acme.com:8080\",\".*\\\\.acme\\\\.com;NO_PROXY\",\".*;http://fallback:8080\"]) jboss-cli 命令将导致以下子系统配置。注意，需要用 \" 来编码 \" 字符。 7.4.2. 传出HTTPS请求信任库 当Keycloak在远程HTTPS端点上调用时，它必须验证远程服务器的证书，以确保它连接到受信任的服务器。 这对于防止中间人攻击是必要的。 必须将这些远程服务器的证书或签署这些证书的CA放在信任库中。 此信任库由Keycloak服务器管理。 在安全地连接到身份代理，LDAP身份提供程序，发送电子邮件以及与客户端应用程序进行反向通道通信时，将使用信任库。 默认情况下，未配置信任库提供程序，并且任何https连接都回退到标准java信任库配置，如Java的JSSE参考指南中所述。 如果没有建立信任，则这些传出的HTTPS请求将失败。 您可以使用 keytool 创建新的信任库文件或将可信主机证书添加到现有文件： $ keytool -import -alias HOSTDOMAIN -keystore truststore.jks -file host-certificate.cer 信任库在您的发行版中的standalone.xml，standalone-ha.xml或domain.xml文件中配置。 此文件的位置取决于您的操作模式。 您可以使用以下模板添加信任库配置： 此设置的可能配置选项包括： file Java密钥库文件的路径。 HTTPS请求需要一种方法来验证他们正在与之通信的服务器的主机。 这就是委托人所做的。 密钥库包含一个或多个可信主机证书或证书颁发机构。 此信任库文件应仅包含安全主机的公共证书。 如果disabled不成立，这是 REQUIRED 。 password 信任库的密码。 如果disabled不成立，这是 REQUIRED 。 hostname-verification-policy WILDCARD默认情况下。 对于HTTPS请求，这将验证服务器证书的主机名。 ANY表示未验证主机名。 WILDCARD 允许子域名中的通配符，即*.foo.com。 STRICT CN必须与主机名完全匹配。 disabled 如果为true（默认值），则将忽略信任库配置，并且证书检查将回退到JSSE配置，如上所述。 如果设置为false，则必须为truststore配置file和password。 8. 集群 本节介绍如何配置要在集群中运行的Keycloak。 设置集群时，您需要做很多事情，具体来说： 选择一种操作模式 配置共享外部数据库 设置负载均衡器 提供支持IP多播的专用网络 本指南前面已讨论过选择操作模式和配置共享数据库。 在本章中，我们将讨论设置负载均衡器和提供专用网络。 我们还将讨论在集群中启动主机时需要注意的一些问题。 可以在没有IP多播的情况下对Keycloak进行群集，但此主题超出了本指南的范围。 有关更多信息，请参阅 WildFly 16 文档 的JGroups 章节。 8.1. 推荐的网络架构 用于部署Keycloak的推荐网络体系结构是在公共IP地址上设置HTTP/HTTPS负载均衡器，以将请求路由到位于专用网络上的Keycloak服务器。 这隔离了所有集群连接，并提供了保护服务器的好方法。 默认情况下，没有什么可以阻止未经授权的节点加入集群和广播多播消息。 这就是集群节点应该在专用网络中的原因，防火墙可以保护它们免受外部攻击。 8.2. 集群示例 Keycloak确实附带了一个利用域模式的开箱即用集群演示。 有关详细信息，请查看群集域示例一章。 8.3. 设置负载均衡器或代理 本节讨论在将反向代理或负载均衡器放在群集Keycloak部署之前需要配置的一些事项。 它还包括配置内置负载均衡器Clustered Domain Example。 8.3.1. 识别客户端IP地址 Keycloak中的一些功能依赖于连接到身份验证服务器的HTTP客户端的远程地址是客户端计算机的真实IP地址。 例子包括： 事件日志 - 将使用错误的源IP地址记录失败的登录尝试 需要SSL - 如果所需的SSL设置为外部（默认值），则所有外部请求都需要SSL 认证流程 - 使用IP地址的自定义身份验证流，例如仅针对外部请求显示OTP 动态客户端注册 当您在Keycloak身份验证服务器前面有反向代理或负载均衡器时，这可能会有问题。 通常的设置是，您有一个位于公共网络上的前端代理，负载平衡并将请求转发给位于专用网络中的后端Keycloak服务器实例。 在此方案中您需要执行一些额外配置，以便将实际的客户端IP地址转发到Keycloak服务器实例并由其处理。 特别： 配置反向代理或负载均衡器以正确设置 X-Forwarded-For 和 X-Forwarded-Proto HTTP头。 配置反向代理或负载均衡器以保留原始 HostHTTP头。 配置身份验证服务器以从 X-Forwarded-For 头读取客户端的IP地址。 配置代理以生成X-Forwarded-For和X-Forwarded-ProtoHTTP头并保留原始的HostHTTP头超出了本指南的范围。 采取额外的预防措施，以确保您的代理设置X-Forwared-For头。 如果您的代理配置不正确，那么 rogue 客户端可以自己设置此标头，并诱使Keycloak认为客户端从不同的IP地址连接而不是实际连接。 如果您正在进行任何黑名单或白名单的IP地址，这将变得非常重要。 除了代理本身之外，还需要在Keycloak方面配置一些东西。 如果您的代理通过HTTP协议转发请求，那么您需要配置Keycloak以从 X-Forwarded-For 头而不是从网络数据包中提取客户端的IP地址。 要执行此操作，请打开配置文件配置文件（standalone.xml，standalone-ha.xml 或 domain.xml，具体取决于您的操作模式）并查找 urn:jboss:domain:undertow:8.0 XML块。 X-Forwarded-For HTTP 配置 ... ... 将proxy-address-forwarding属性添加到http-listener元素。 将值设置为true。 如果您的代理使用AJP协议而不是HTTP来转发请求（即Apache HTTPD + mod-cluster），那么您必须以不同的方式配置。 您需要添加一个过滤器来从AJP数据包中提取此信息，而不是修改http-listener。 X-Forwarded-For AJP 配置 ... ... ... 8.3.2. 使反向代理启用HTTPS/SSL 假设您的反向代理不使用端口8443进行SSL，您还需要配置重定向到HTTPS流量的端口。 ... ... 将redirect-socket属性添加到http-listener元素。 值应为proxy-https，它指向您还需要定义的套接字绑定。 然后在socket-binding-group元素中添加一个新的socket-binding元素： ... ... 8.3.3. 验证配置 您可以通过反向代理打开路径 /auth/realms/master/.well-known/openid-configuration 来验证反向代理或负载均衡器配置。 例如，如果反向代理地址是 https://acme.com/，则打开URL https://acme.com/auth/realms/master/.well-known/openid-configuration。 这将显示一个JSON文档，其中列出了Keycloak的许多端点。 确保端点以反向代理或负载均衡器的地址（scheme, domain and port）开头。 通过这样做，您可以确保Keycloak正在使用正确的端点。 您还应验证Keycloak是否看到了请求的正确源IP地址。 请检查此项，您可以尝试使用无效的用户名和/或密码登录管理控制台。 这应该在服务器日志中显示如下警告： 08:14:21,287 WARN XNIO-1 task-45 [org.keycloak.events] type=LOGIN_ERROR, realmId=master, clientId=security-admin-console, userId=8f20d7ba-4974-4811-a695-242c8fbd1bf8, ipAddress=X.X.X.X, error=invalid_user_credentials, auth_method=openid-connect, auth_type=code, redirect_uri=http://localhost:8080/auth/admin/master/console/?redirect_fragment=%2Frealms%2Fmaster%2Fevents-settings, code_id=a3d48b67-a439-4546-b992-e93311d6493e, username=admin 检查ipAddress的值是您尝试登录的计算机的IP地址，而不是反向代理或负载平衡器的IP地址。 8.3.4. 使用内置负载均衡器 本节介绍如何配置Clustered Domain Example中讨论的内置负载均衡器. Clustered Domain Example仅设计为在一台计算机上运行。 要在另一台主机上启动一个slave，你需要 编辑 domain.xml 文件以指向新的主机slave 复制服务器分发版。 您不需要domain.xml，host.xml 或 host-master.xml文件。 你也不需要 standalone/ 目录。 编辑 host-slave.xml 文件以更改使用的绑定地址或在命令行上覆盖它们 使用Load Balancer注册新主机 让我们首先看一下使用 domain.xml 中的负载均衡器配置注册新的主机slave。 打开此文件并转到load-balancer配置文件中的undertow配置。 在reverse-proxy XML块中添加一个名为remote-host3的新host定义。 domain.xml反向代理配置 ... ... output-socket-binding是一个逻辑名，指向稍后在 domain.xml 文件中配置的socket-binding。 instance-id属性对于新主机也必须是唯一的，因为cookie使用此值来在负载平衡时启用粘性会话。 接下来转到load-balancer-socket socket-binding-group 并为 remote-host3 添加 outbound-socket-binding。 此新绑定需要指向新主机的主机和端口。 domain.xml outbound-socket-binding ... Master Bind Addresses (主绑定地址) 接下来你要做的就是更改主控主机的public和management绑定地址。 按照绑定地址一章中的说明编辑 domain.xml 文件，或者在命令行上指定这些绑定地址 命令行如下： $ domain.sh --host-config=host-master.xml -Djboss.bind.address=192.168.0.2 -Djboss.bind.address.management=192.168.0.2 Host Slave Bind Addresses (主机从属绑定地址) 接下来，您将不得不更改public，management和域控制器绑定地址（jboss.domain.master-address）。 编辑host-slave.xml文件或在命令行中指定它们，如下所示： $ domain.sh --host-config=host-slave.xml -Djboss.bind.address=192.168.0.5 -Djboss.bind.address.management=192.168.0.5 -Djboss.domain.master.address=192.168.0.2 jboss.bind.address和jboss.bind.addres.management的值属于主机slave的IP地址。 jboss.domain.master.address的值必须是域控制器的IP地址，域控制器是master主机的管理地址。 8.3.5. 配置其他负载均衡器 有关如何使用其他基于软件的负载平衡器的信息，请参阅 WildFly 16文档 中的负载均衡部分。 8.4. 粘性会话 典型的集群部署包括负载均衡器（反向代理）和专用网络上的2个或更多Keycloak服务器。 出于性能目的，如果负载均衡器将与特定浏览器会话相关的所有请求转发到同一Keycloak后端节点，则可能会很有用。 原因是，Keycloak正在使用Infinispan分布式缓存来保存与当前身份验证会话和用户会话相关的数据。 默认情况下，Infinispan分布式缓存配置有一个所有者。 这意味着特定会话仅保存在一个群集节点上，而其他节点需要远程查找会话才能访问它。 例如，如果ID为123的认证会话保存在node1上的Infinispan缓存中，然后node2需要查找该会话，则需要通过网络将请求发送到node1以返回特定会话 实体。 如果特定会话实体始终在本地可用，这是有益的，这可以在粘性会话的帮助下完成。 具有公共前端负载均衡器和两个后端Keycloak节点的集群环境中的工作流可以是这样的： 用户发送初始请求以查看Keycloak登录屏幕 该请求由前端负载均衡器提供，后者将其转发到某个随机节点（例如，node1）。 严格地说，节点不需要是随机的，但可以根据其他一些标准（客户端IP地址等）进行选择。 这一切都取决于底层负载均衡器（反向代理）的实现和配置。 Keycloak使用随机ID（例如123）创建认证会话并将其保存到Infinispan缓存。 Infinispan分布式缓存根据会话ID的哈希值分配会话的主要所有者。 有关此内容的详细信息，请参阅Infinispan文档。 让我们假设Infinispan将node2指定为此会话的所有者。 Keycloak使用.等格式创建cookie AUTH_SESSION_ID。 在我们的示例中，它将是123.node2。 使用Keycloak登录屏幕和浏览器中的AUTH_SESSION_ID cookie将响应返回给用户 从这一点来看，如果负载均衡器将所有下一个请求转发到node2是有益的，因为这是节点，它是ID为123的认证会话的所有者，因此Infinispan可以在本地查找该会话。 身份验证完成后，身份验证会话将转换为用户会话，该会话也将保存在node2上，因为它具有相同的ID123。 粘性会话对于群集设置不是强制性的，但由于上述原因，它对性能有利。 您需要将loadbalancer配置为粘贴在AUTH_SESSION_ID cookie上。 这究竟取决于您的负载均衡器。 建议在Keycloak端使用启动期间的系统属性jboss.node.name，其值与路由名称相对应。 例如，-Djboss.node.name=node1将使用node1来标识路由。 此路由将由Infinispan缓存使用，并在节点是特定密钥的所有者时附加到AUTH_SESSION_ID cookie。 以下是使用此系统属性的启动命令的示例： cd $RHSSO_NODE1 ./standalone.sh -c standalone-ha.xml -Djboss.socket.binding.port-offset=100 -Djboss.node.name=node1 通常在生产环境中，路由名称应使用与后端主机相同的名称，但不是必需的。 您可以使用其他路径名称。 例如，如果要在专用网络中隐藏Keycloak服务器的主机名。 8.4.1. 禁用添加路由 某些负载均衡器可以配置为自行添加路由信息，而不是依赖于后端Keycloak节点。 但是，如上所述，建议通过Keycloak添加路线。 这是因为当这样做时性能得到改善，因为Keycloak知道作为特定会话的所有者的实体并且可以路由到该节点，该节点不一定是本地节点。 如果您愿意，可以通过将以下内容添加到Keycloak子系统配置中的RHSSO_HOME/standalone/configuration/standalone-ha.xml文件中来禁用Keycloak将路由信息添加到AUTH_SESSION_ID cookie中： ... 8.5. 多播网络设置 开箱即用的集群支持需要IP多播。 组播是一种网络广播协议。 此协议在启动时用于发现和加入集群。 它还用于广播消息，以便复制和使Keycloak使用的分布式缓存失效。 Keycloak的集群子系统在JGroups堆栈上运行。 开箱即用，集群的绑定地址绑定到专用网络接口，默认IP地址为127.0.0.1。 您必须编辑Bind Address 中讨论的standalone-ha.xml 或 domain.xml部分章节。 专用网络配置 ... ... ... 你想要配置的东西是jboss.bind.address.private和jboss.default.multicast.address以及集群堆栈上服务的端口。 可以在没有IP多播的情况下对Keycloak进行集群，但此主题超出了本指南的范围。 有关更多信息，请参阅 WildFly 16文档 中的JGroups。 8.6. 确保集群通信安全 当集群节点在专用网络上隔离时，它需要访问专用网络才能加入集群或查看集群中的通信。 此外，您还可以为集群通信启用身份验证和加密。 只要您的专用网络是安全的，就不必启用身份验证和加密。 在任何一种情况下，Keycloak都不会在集群上发送非常敏感的信息。 如果要为集群通信启用身份验证和加密，请参阅 JBoss EAP配置指南中的保护群集。 8.7. 串行化集群启动 允许Keycloak集群节点同时引导。 当Keycloak服务器实例启动时，它可以执行一些数据库迁移，导入或首次初始化。 数据库锁用于在集群节点同时启动时防止启动操作相互冲突。 默认情况下，此锁定的最大超时为900秒。 如果某个节点正在等待此锁超过超时，则无法启动。 通常，您不需要增加/减少默认值，但以防万一可以在您的发行版中的standalone.xml，standalone-ha.xml或domain.xml文件中进行配置。 此文件的位置取决于您的操作模式。 8.8. 启动群集 在群集中启动Keycloak取决于您的操作模式 Standalone Mode (独立模式) $ bin/standalone.sh --server-config=standalone-ha.xml Domain Mode (域模式) $ bin/domain.sh --host-config=host-master.xml $ bin/domain.sh --host-config=host-slave.xml 您可能需要使用其他参数或系统属性。 例如，绑定主机的参数-b或系统属性jboss.node.name用于指定路由的名称，如Sticky Sessions中所述 部分。 8.9. 故障排除 请注意，在运行集群时，您应该在两个集群节点的日志中看到与此类似的消息： INFO [org.infinispan.remoting.transport.jgroups.JGroupsTransport] (Incoming-10,shared=udp) ISPN000094: Received new cluster view: [node1/keycloak|1] (2) [node1/keycloak, node2/keycloak] 如果您只看到提到的一个节点，则您的集群主机可能未连接在一起。 通常，最佳做法是将您的集群节点放在专用网络上，而不使用防火墙进行通信。 可以仅在公共访问点上启用防火墙，而不是网络。 如果由于某种原因您仍需要在集群节点上启用防火墙，则需要打开一些端口。 默认值为UDP端口55200和组播地址为230.0.0.4的组播端口45688。 请注意，如果要为JGroups堆栈启用诊断等其他功能，则可能需要打开更多端口。 Keycloak将大部分集群工作委托给Infinispan/JGroups。 有关更多信息，请参阅 WildFly 16文档 中的JGroups。 如果您对故障转移支持（高可用性），驱逐，到期和缓存调整感兴趣，请参阅服务器缓存配置。 9. 服务器缓存配置 Keycloak有两种类型的缓存。 一种类型的缓存位于数据库前面，以减少数据库的负载，并通过将数据保存在内存中来减少总体响应时间。 领域，客户端，角色和用户元数据保存在此类缓存中。 此缓存是本地缓存。 即使您在具有更多Keycloak服务器的集群中，本地缓存也不使用复制。 相反，它们仅在本地保留副本，如果更新了条目，则会向集群的其余部分发送无效消息，并逐出该条目。 存在单独的复制缓存work，该任务是将失效消息发送到整个集群，关于应从本地缓存中逐出哪些条目。 这极大地减少了网络流量，提高了效率，并避免了通过网络传输敏感元数据。 第二种类型的缓存处理用户会话，脱机令牌和跟踪登录失败，以便服务器可以检测密码网络钓鱼和其他攻击。 这些缓存中保存的数据是临时的，仅在内存中，但可能在集群中复制。 本章讨论这些高速缓存的集群非集群部署的一些配置选项。 这些高速缓存的更高级配置可以在 WildFly 16文档 的Infinispan部分找到。 9.1. 驱逐和到期 为Keycloak配置了多个不同的缓存。 有一个领域缓存可以保存有关安全应用程序，常规安全数据和配置选项的信息。 还有一个包含用户元数据的用户缓存。 两个缓存默认最多为10000个条目，并使用最近最少使用的逐出策略。 它们中的每一个还绑定到对象修订缓存，该缓存控制群集设置中的逐出。 此缓存是隐式创建的，并且具有配置大小的两倍。 这同样适用于保存授权数据的authorization缓存。 keys缓存保存有关外部密钥的数据，不需要具有专用的修订缓存。 相反，它在其上明确声明了expiration，因此密钥会定期过期并强制定期从外部客户端或身份提供者下载。 可以在standalone.xml，standalone-ha.xml或domain.xml中配置这些缓存的驱逐策略和最大条目，具体取决于您的操作模式。 在配置文件中，有infinispan子系统的部分，看起来类似于： ... ... 要限制或扩展允许的条目数，只需添加或编辑特定缓存配置的object元素或expiration元素。 此外，还有单独的缓存sessions，clientSessions，offlineSessions，offlineClientSessions，loginFailures和actionTokens。 这些缓存在集群环境中分布，默认情况下它们的大小无限制。 如果它们是有界的，则可能会丢失一些会话。 过期的会话由Keycloak本身在内部清除，以避免无限制地增加这些缓存的大小。 如果由于大量会话而发现内存问题，您可以尝试： 增加集群的大小（集群中的更多节点意味着会话在节点之间更均匀地分布） 增加Keycloak服务器进程的内存 减少所有者的数量以确保将缓存保存在一个位置。 有关详细信息，请参阅复制和故障转移 禁用分布式缓存的l1-lifespan。 有关更多详细信息，请参阅Infinispan文档 减少会话超时，可以在Keycloak管理控制台中为每个领域单独完成。 但这可能会影响最终用户的可用性。 有关详细信息，请参阅超时。 还有一个额外的复制缓存，work，主要用于在集群节点之间发送消息; 默认情况下它也是无界限的。 但是，此缓存不应导致任何内存问题，因为此缓存中的条目非常短暂。 9.2. 复制和故障转移 有一些缓存，如sessions，authenticationSessions，offlineSessions，loginFailures等等（参见Eviction and Expiration了解更多细节）， 在使用集群设置时配置为分布式缓存。 条目不会复制到每个节点，而是选择一个或多个节点作为该数据的所有者。 如果节点不是特定高速缓存条目的所有者，则查询集群以获取它。 这对于故障转移意味着如果拥有一个数据的所有节点都关闭，那么该数据将永远丢失。 默认情况下，Keycloak仅指定一个数据所有者。 因此，如果那个节点发生故障，那么数据就会丢失。 这通常意味着用户将被注销，并且必须再次登录。 您可以通过更改distributed-cache声明中的owners属性来更改复制一段数据的节点数。 owners (拥有者) ... 这里我们已经更改了它，因此至少有两个节点将复制一个特定的用户登录会话。 建议的所有者数量实际上取决于您的部署。 如果您不关心用户是否在节点关闭时注销，那么一个所有者就足够了，您将避免复制。 通常明智的做法是将环境配置为使用带有粘性会话的负载均衡。 这对于性能是有益的，因为提供特定请求的Keycloak服务器通常是来自分布式缓存的数据的所有者，因此能够在本地查找数据。 有关详细信息，请参阅粘贴会话。 9.3. 禁用缓存 要禁用领域或用户高速缓存，必须编辑发行版中的standalone.xml，standalone-ha.xml或domain.xml文件。 此文件的位置取决于您的操作模式。 这是配置最初的样子。 要禁用缓存，请将要禁用的缓存的enabled属性设置为false。 您必须重新启动服务器才能使此更改生效。 9.4. 在运行时清除缓存 要清除领域或用户缓存，请转到Keycloak管理控制台领域设置→缓存配置页面。 在此页面上，您可以清除领域缓存，用户缓存或外部公钥缓存。 所有领域缓存将被清除！ 10. Keycloak安全代理 Keycloak有一个HTTP(S)代理，在无法安装Keycloak适配器的环境里,您可以把它放在Web应用程序和服务之前。 您可以设置URL过滤器，以便通过浏览器登录和/或承载令牌身份验证来保护某些URL。 您还可以在应用程序中定义URL模式的角色约束。 10.1. 代理安装和运行 从Keycloak下载页面下载Keycloak代理发布版并解压缩。 $ unzip keycloak-proxy-dist.zip 要运行它，您必须有一个代理配置文件（我们将在稍后讨论）。 $ java -jar bin/launcher.jar [your-config.json] 如果未指定代理配置文件的路径，则启动程序将在当前工作目录中查找名为`proxy.json的文件。 10.2. 代理配置 这是一个示例配置文件。 { \"target-url\": \"http://localhost:8082\", \"target-request-timeout\": \"60000\", \"send-access-token\": true, \"bind-address\": \"localhost\", \"http-port\": \"8080\", \"https-port\": \"8443\", \"keystore\": \"classpath:ssl.jks\", \"keystore-password\": \"password\", \"key-password\": \"password\", \"applications\": [ { \"base-path\": \"/customer-portal\", \"error-page\": \"/error.html\", \"adapter-config\": { \"realm\": \"demo\", \"resource\": \"customer-portal\", \"realm-public-key\": \"MIGfMA0GCSqGSIb\", \"auth-server-url\": \"http://localhost:8081/auth\", \"ssl-required\" : \"external\", \"principal-attribute\": \"name\", \"credentials\": { \"secret\": \"password\" } } , \"constraints\": [ { \"pattern\": \"/users/*\", \"roles-allowed\": [ \"user\" ] }, { \"pattern\": \"/admins/*\", \"roles-allowed\": [ \"admin\" ] }, { \"pattern\": \"/users/permit\", \"permit\": true }, { \"pattern\": \"/users/deny\", \"deny\": true } ] } ] } 10.2.1. 基本配置 服务器的基本配置选项如下： target-url 此服务器代理的URL。 需要。 target-request-timeout 代理请求的超时（以毫秒为单位）。 可选的。 默认值为30000。 send-access-token 布尔标志。 如果为true，则会通过KEYCLOAK_ACCESS_TOKEN标头将访问令牌发送到代理服务器。 可选的。 默认值为false。 bind-address 用于将代理服务器的套接字绑定到的DNS名称或IP地址。 可选的。 默认值为localhost http-port 用于侦听HTTP请求的端口。 如果未指定此值，则代理将不侦听常规HTTP请求。 可选的。 https-port 侦听HTTPS请求的端口。 如果未指定此值，则代理将不侦听HTTPS请求。 可选的。 keystore Java密钥库文件的路径，该文件包含服务器能够处理HTTPS请求的私钥和证书。 可以是文件路径，或者，如果在前面添加classpath:，它将在类路径中查找此文件。 可选的。 如果您已启用HTTPS但尚未定义密钥库，则代理将自动生成自签名证书并使用该证书。 buffer-size HTTP服务器套接字缓冲区大小 通常默认值足够好。 可选的。 buffers-per-region 每个region(区域)的HTTP服务器套接字缓冲 通常默认值足够好。 可选的。 io-threads 处理IO的线程数。 通常默认是足够好的。 可选的。 默认值是可用处理器数量* 2。 worker-threads 处理请求的线程数。 通常默认值足够好。 可选的。 默认值是可用处理器数量* 16。 10.3. 应用程序配置 接下来在applications数组属性下，您可以为每个要代理的主机定义一个或多个应用程序。 base-path 应用程序的基本上下文根。 必须以'/'开头。 需要。 error-page 如果代理有错误，它将显示目标应用程序的错误页面相对URL。 可选的。 这是基本路径的相对路径。 在上面的例子中，它将是/customer-portal/error.html。 adapter-config 需要。 与任何其他Keycloak适配器的配置相同。 proxy-address-forwarding 当托管在另一个代理/负载均衡器后面时，允许使用X-Forwarded-For，X-Forwarded-Host，X-Forwarded-Proto。 10.3.1. 约束配置 在每个应用程序下，您可以在constraints数组属性中定义一个或多个约束。 约束定义相对于基本路径的URL模式。 您可以拒绝，允许或要求对特定URL模式进行身份验证。 您也可以指定该路径允许的角色。 更具体的约束将优先于更一般的约束。 pattern 相对于应用程序的基本路径匹配的URL模式。 必须以'/'开头。 必须. 你可能只有一个通配符，它必须位于模式的末尾。有效：/foo/bar/*和/foo/*.txt 无效：/ */foo/*。 roles-allowed 允许访问此url模式的角色字符串数组。 可选的。 methods HTTP方法的字符串数组，它们将独占地匹配此模式和HTTP请求。 可选的。 excluded-methods 匹配此模式时将忽略的HTTP方法字符串数组。 可选的。 deny 拒绝所有访问此URL模式的权限。 可选的。 permit 允许所有访问而无需身份验证或角色映射。 可选的。 permit-and-inject 允许所有访问，但如果用户已经过身份验证，则注入标头。 可选的。 authenticate 需要对此模式进行身份验证，但不需要角色映射。 可选的。 10.3.2. 头名配置 接下来，在应用程序列表下，您可以覆盖代理注入的头字段名称的默认值（请参阅Keycloak Identity Headers）。 此映射是可选的。 keycloak-subject 例如: MYAPP_USER_ID keycloak-username 例如: MYAPP_USER_NAME keycloak-email 例如: MYAPP_USER_EMAIL keycloak-name 例如: MYAPP_USER_ID keycloak-access-token 例如: MYAPP_ACCESS_TOKEN 10.4. Keycloak标识头 将请求转发到代理服务器时，Keycloak Proxy将使用收到的OIDC身份令牌中的值设置一些其他标头以进行身份验证。 KEYCLOAK_SUBJECT 用户ID。 对应于JWTsub，将是Keycloak用于存储此用户的用户ID。 KEYCLOAK_USERNAME 用户名。 对应于JWTpreferred_username。 KEYCLOAK_EMAIL 设置的用户的电子邮件地址。 KEYCLOAK_NAME 如果设置, 用户全名。 KEYCLOAK_ACCESS_TOKEN 如果代理配置为发送，则在此标头中发送访问令牌。 此令牌可用于发出承载令牌请求。 可以使用配置文件中的header-names映射配置标题字段名称：{ \"header-names\" { \"keycloak-subject\": \"MY_SUBJECT\" } } Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-01-04 20:08:01 "},"03_Securing Applications and Services Guide.html":{"url":"03_Securing Applications and Services Guide.html","title":"保护应用程序和服务指南","keywords":"","body":"保护应用程序和服务指南1. 概述1.1. 什么是客户端适配器?1.2. 支持的平台1.3. 支持的协议2. OpenID 连接器2.1. Java 适配器2.2. JavaScript 适配器2.3. Node.js 适配器2.4. Keycloak 看门人2.5. 其他OpenID连接库3. SAML3.1. Java 适配器3.2. mod_auth_mellon Apache HTTPD 模块4. Docker注册表配置4.1. Docker注册表配置文件安装4.2. Docker注册表环境变量覆盖安装4.3. Docker撰写YAML文件5. 客户端注册5.1. 认证5.2. Keycloak表示5.3. Keycloak适配器配置5.4. OpenID连接动态客户端注册5.5. SAML实体描述符5.6. 使用CURL的示例5.7. 使用Java客户端注册API的示例5.8. 客户端注册政策6. 客户端注册 CLI6.1. 配置新常规用户以使用客户端注册CLI6.2. 配置客户端以与客户端注册CLI一起使用6.3. 安装客户端注册CLI6.4. 使用客户端注册CLI6.5. 故障排除7. 令牌交换7.1. 内部令牌到内部令牌交换7.2. 外部令牌交换的内部令牌7.3. 外部令牌到内部令牌交换7.4. 模拟7.5. 直接赤裸裸的模拟7.6. 使用服务帐户展开权限模型7.7. 交换漏洞保护应用程序和服务指南 1. 概述 Keycloak支持OpenID Connect（OAuth 2.0的扩展）和SAML 2.0。 在保护客户端和服务时，首先需要确定的是您要使用的两个中的哪一个。 如果您愿意，您也可以选择使用OpenID Connect和其他SAML安全保护。 To secure clients and services you are also going to need an adapter or library for the protocol you’ve selected. Keycloak comes with its own adapters for selected platforms, but it is also possible to use generic OpenID Connect Resource Provider and SAML Service Provider libraries. 1.1. 什么是客户端适配器? Keycloak客户端适配器是使用Keycloak轻松保护应用程序和服务的库。 我们将它们称为适配器而不是库，因为它们提供了与底层平台和框架的紧密集成。 这使得我们的适配器易于使用，并且它们需要的库样板代码少于库通常所需的代码。 1.2. 支持的平台 1.2.1. OpenID Connect Java JBoss EAP WildFly Fuse Tomcat Jetty 9 Servlet Filter Spring Boot Spring Security JavaScript (client-side) JavaScript Node.js (server-side) Node.js 1.2.2. C OWIN (community) 1.2.3. Python oidc (generic) 1.2.4. Android AppAuth (generic) AeroGear (generic) 1.2.5. iOS AppAuth (generic) AeroGear (generic) Apache HTTP Server mod_auth_openidc 1.2.6. SAML Java JBoss EAP WildFly Tomcat Jetty Apache HTTP Server mod_auth_mellon 1.3. 支持的协议 1.3.1. OpenID Connect OpenID 连接 (OIDC)是一个身份验证协议，它是OAuth 2.0的扩展。虽然OAuth 2.0只是一个构建授权协议的框架，而且主要是不完整的，但OIDC是一个完整的身份验证和授权协议。 OIDC还大量使用了Json Web Token (JWT)标准集。这些标准定义了一种身份令牌JSON格式，以及以一种紧凑且web友好的方式对数据进行数字签名和加密的方法。 使用OIDC时，实际上有两种用例。 第一个是要求Keycloak服务器为用户验证用户的应用程序。 成功登录后，应用程序将收到identity token(身份令牌)和access token(访问令牌)。 身份令牌包含有关用户的信息，例如用户名，电子邮件和其他个人资料信息。 访问令牌由领域进行数字签名，并包含访问信息（如用户角色映射），应用程序可以使用该信息来确定允许用户在应用程序上访问哪些资源。 第二种用例是希望获得远程服务访问权限的客户端。 在这种情况下，客户端要求Keycloak获取访问令牌，它可以代表用户在其他远程服务上调用。 Keycloak对用户进行身份验证，然后要求用户同意授予访问请求它的客户端的权限。 然后客户端接收访问令牌。 此访问令牌由领域进行数字签名。 客户端可以使用此访问令牌在远程服务上进行REST调用。 REST服务提取访问令牌，验证令牌的签名，然后根据令牌内的访问信息决定是否处理请求。 1.3.2. SAML 2.0 SAML 2.0 是与OIDC类似的规范，但是更老，更成熟。 它的根源在于SOAP和过多的WS-*规范，所以它往往比OIDC更冗长。 SAML 2.0主要是一种身份验证协议，通过在身份验证服务器和应用程序之间交换XML文档来工作。 XML签名和加密用于验证请求和响应。 在Keycloak中，SAML提供两种用例：浏览器应用程序和REST调用。 使用SAML时，实际上有两种用例。 第一个是要求Keycloak服务器为用户验证用户的应用程序。 成功登录后，应用程序将收到一个XML文档，其中包含称为SAML断言的内容，该断言指定了有关用户的各种属性。 此XML文档由领域进行数字签名，并包含访问信息（如用户角色映射），应用程序可以使用该信息来确定允许用户在应用程序上访问哪些资源。 第二种用例是希望获得远程服务访问权限的客户端。 在这种情况下，客户端要求Keycloak获取可用于代表用户在其他远程服务上调用的SAML断言。 1.3.3. OpenID Connect 与 SAML 在OpenID Connect和SAML之间进行选择不仅仅是使用更新的协议（OIDC）而不是旧的更成熟的协议（SAML）。 在大多数情况下，Keycloak建议使用OIDC。 SAML往往比OIDC更冗长。 除了交换数据的详细程度之外，如果您比较规范，您会发现OIDC旨在与Web一起工作，同时SAML被改装为在Web上运行。 例如，OIDC也更适合HTML5/JavaScript应用程序，因为它比SAML更容易在客户端实现。 由于令牌采用JSON格式，因此JavaScript更易于使用。 您还将找到一些很好的功能，可以更轻松地在Web应用程序中实现安全性。 例如，查看规范用于轻松确定用户是否仍在登录的iframe技巧。 SAML虽然有它的用途。 正如您所看到的，OIDC规范的发展，您会发现它们实现了SAML多年来所拥有的越来越多的功能。 我们经常看到人们选择SAML而不是OIDC，因为人们认为它更成熟，也因为他们已经有了现有的应用程序。 2. OpenID 连接器 本节介绍如何使用Keycloak适配器或通用OpenID Connect资源提供程序库通过OpenID Connect保护应用程序和服务。 2.1. Java 适配器 Keycloak为Java应用程序提供了一系列不同的适配器。 选择正确的适配器取决于目标平台。 所有Java适配器共享Java Adapters Config 章节中描述的一组常用配置选项。 2.1.1. Java适配器配置 Keycloak支持的每个Java适配器都可以通过简单的JSON文件进行配置。 这可能是这样的： { \"realm\" : \"demo\", \"resource\" : \"customer-portal\", \"realm-public-key\" : \"MIGfMA0GCSqGSIb3D...31LwIDAQAB\", \"auth-server-url\" : \"https://localhost:8443/auth\", \"ssl-required\" : \"external\", \"use-resource-role-mappings\" : false, \"enable-cors\" : true, \"cors-max-age\" : 1000, \"cors-allowed-methods\" : \"POST, PUT, DELETE, GET\", \"cors-exposed-headers\" : \"WWW-Authenticate, My-custom-exposed-Header\", \"bearer-only\" : false, \"enable-basic-auth\" : false, \"expose-token\" : true, \"verify-token-audience\" : true, \"credentials\" : { \"secret\" : \"234234-234234-234234\" }, \"connection-pool-size\" : 20, \"disable-trust-manager\": false, \"allow-any-hostname\" : false, \"truststore\" : \"path/to/truststore.jks\", \"truststore-password\" : \"geheim\", \"client-keystore\" : \"path/to/client-keystore.jks\", \"client-keystore-password\" : \"geheim\", \"client-key-password\" : \"geheim\", \"token-minimum-time-to-live\" : 10, \"min-time-between-jwks-requests\" : 10, \"public-key-cache-ttl\": 86400, \"redirect-rewrite-rules\" : { \"^/wsmaster/api/(.*)$\" : \"/api/$1\" } } 您可以使用${…}来替换系统属性。例如${jboss.server.config.dir}将替换为/path/to/Keycloak。环境变量的替换也通过env前缀得到支持，例如。 ${env.MY_ENVIRONMENT_VARIABLE}。 可以从管理控制台获取初始配置文件。 这可以通过打开管理控制台，从菜单中选择Clients并单击相应的客户端来完成。 打开客户端页面后，单击Installation选项卡，然后选择Keycloak OIDC JSON。 以下是每个配置选项的说明： realm 领域的名称。 这是必需的 resource 应用程序的客户端ID。 每个应用程序都有一个client-id，用于标识应用程序。 这是必需的 realm-public-key 领域公钥的PEM格式。 您可以从管理控制台获取此信息。 这是可选的，不建议设置它。 如果没有设置，适配器将从Keycloak下载它，它将在需要时总是重新下载（例如Keycloak旋转它的键）。 但是，如果设置了realm-public-key，那么适配器永远不会从Keycloak下载新密钥，所以当Keycloak旋转它的密钥时，适配器将会中断。 auth-server-url Keycloak服务器的基本URL。 所有其他Keycloak页面和REST服务端点都源于此。 它的形式通常为https://host:port/auth。 这是必需的 ssl-required 确保与Keycloak服务器之间的所有通信均通过HTTPS进行。 在生产中，这应该设置为“all”。 这是可选的。 默认值为external表示默认情况下HTTPS是外部请求所必需的。 有效值为“all”，“external”和“none”。 confidential-port Keycloak服务器用于通过SSL/TLS进行安全连接的机密端口。 这是可选的。 默认值为8443。 use-resource-role-mappings 如果设置为true，那么适配器将在令牌内查找用户的应用程序级别角色映射。 如果为false，它将查看用户角色映射的领域级别。 这是可选的。 默认值为 false。 public-client 如果设置为true，则适配器将不会将客户端的凭据发送到Keycloak。 这是可选的。 默认值为false。 enable-cors 这使CORS支持成为可能。 它将处理CORS预检请求。 它还将查看访问令牌以确定有效的来源。 这是可选的。 默认值为false。 cors-max-age 如果启用了CORS，则设置Access-Control-Max-Age标头的值。 这是可选的。 如果未设置，则在CORS响应中不返回此标头。 cors-allowed-methods 如果启用了CORS，则设置Access-Control-Allow-Methods标头的值。 这应该是逗号分隔的字符串。 这是可选的。 如果未设置，则在CORS响应中不返回此标头。 cors-allowed-headers 如果启用了CORS，则设置Access-Control-Allow-Headers标头的值。 这应该是逗号分隔的字符串。 这是可选的。 如果未设置，则在CORS响应中不返回此标头。 cors-exposed-headers 如果启用了CORS，则设置Access-Control-Expose-Headers标头的值。 这应该是逗号分隔的字符串。 这是可选的。 如果未设置，则在CORS响应中不返回此标头。 bearer-only 对于服务，应将其设置为true。 如果启用，适配器将不会尝试对用户进行身份验证，而只会验证承载令牌。 这是可选的。 默认值为false。 autodetect-bearer-only 如果您的应用程序同时提供Web应用程序和Web服务（例如SOAP或REST），则应将其设置为true。 它允许您将未经身份验证的Web应用程序用户重定向到Keycloak登录页面，但是将HTTP401状态代码发送给未经身份验证的SOAP或REST客户端，因为他们无法理解重定向到登录页面。 Keycloak基于典型的标题自动检测SOAP或REST客户端，如X-Requested-With，SOAPAction 或 Accept。 默认值为false。 enable-basic-auth 这告诉适配器也支持基本身份验证。 如果启用此选项，则还必须提供secret。 这是选的。 默认值为false。 expose-token 如果是true，则经过身份验证的浏览器客户端（通过JavaScript HTTP调用）可以通过URL root/k_query_bearer_token获取签名访问令牌。 这是可选的。 默认值为false。 credentials 指定应用程序的凭据。 这是一个对象表示法，其中键是凭证类型，值是凭证类型的值。 目前支持密码和jwt。 这是必须的仅适用于具有'Confidential(机密)'访问类型的客户。 connection-pool-size 适配器将对Keycloak服务器进行单独的HTTP调用，以将访问代码转换为访问令牌。 此配置选项定义应该合并到Keycloak服务器的连接数。 这是可选的。 默认值为20。 disable-trust-manager 如果Keycloak服务器需要HTTPS并且此配置选项设置为true，则不必指定信任库。 此设置仅应在开发期间使用，永远不要在生产中使用，因为它将禁用SSL证书的验证。 这是可选的。 默认值为false。 allow-any-hostname 如果Keycloak服务器需要HTTPS并且此配置选项设置为true，则通过信任库验证Keycloak服务器的证书，但不会进行主机名验证。 此设置仅应在开发期间使用，永远不要在生产中使用，因为它将禁用SSL证书的验证。 此测试在测试环境中可能很有用。这是可选的。 默认值为false。 proxy-url HTTP代理的URL（如果使用）。 truststore 该值是信任库文件的文件路径。 如果在路径前加上classpath:，那么将从部署的类路径中获取信任库。 用于与Keycloak服务器的传出HTTPS通信。 发出HTTPS请求的客户端需要一种方法来验证他们正在与之通信的服务器的主机。 这就是委托人所做的。 密钥库包含一个或多个可信主机证书或证书颁发机构。 您可以通过提取Keycloak服务器的SSL密钥库的公共证书来创建此信任库。 这是 必须的，除非ssl-required是none或disable-trust-manager 是 true。 truststore-password 信任库的密码。 如果设置了truststore并且信任库需要密码，那么这是必须的。 client-keystore 这是密钥库文件的文件路径。 当适配器向Keycloak服务器发出HTTPS请求时，此密钥库包含双向SSL的客户端证书。 这是可选的。 client-keystore-password 客户端密钥库的密码。 如果设置了client-keystore，这是必须的。 client-key-password 客户密钥的密码。 如果设置了client-keystore，这是必须的。 always-refresh-token 如果true，则适配器将在每个请求中刷新令牌。 register-node-at-startup 如果true，则适配器将向Keycloak发送注册请求。 它默认为false，仅在应用程序集群时才有用。 有关详细信息，请参阅应用程序群集 register-node-period 重新注册适配器到Keycloak的期限。 应用程序集群时很有用。 有关详细信息，请参阅应用程序群集 token-store 可能的值是session和cookie。 默认为session，这意味着适配器在HTTP会话中存储帐户信息。 如果是cookie表示在cookie中存储信息。 有关详细信息，请参阅应用程序群集 token-cookie-path 使用cookie存储时，此选项设置用于存储帐户信息的cookie的路径。 如果它是相对路径，则假定应用程序在上下文根中运行，并且相对于该上下文根进行解释。 如果它是绝对路径，则绝对路径用于设置cookie路径。 默认使用相对于上下文根的路径。 principal-attribute 使用OpenID Connect ID Token属性填充UserPrincipal名称。 如果token属性为null，则默认为sub。 可能的值是sub，preferred_username，email，name，nickname，given_name，family_name。 turn-off-change-session-id-on-login 默认情况下，在某些平台上成功登录时会更改会话ID以插入安全攻击向量。 如果要将其关闭，请将此更改为true这是可选的。 默认值为false。 token-minimum-time-to-live 在Keycloak服务器到期之前使用Keycloak服务器抢先刷新活动访问令牌的时间（以秒为单位）。 当访问令牌被发送到另一个REST客户端时，这在它可能在评估之前到期时特别有用。 该值不应超过领域的访问令牌寿命。 这是可选的。 默认值为0秒，因此适配器将刷新访问令牌，如果它已过期。 min-time-between-jwks-requests 指定Keycloak检索新公钥的两个请求之间的最小间隔的时间量（以秒为单位）。 默认为10秒。 当适配器识别带有未知kid的令牌时，它总是会尝试下载新的公钥。 但是，它不会每10秒尝试一次（默认情况下）。 这是为了避免DoS，当攻击者发送大量带有错误kid强制适配器的令牌向Keycloak发送大量请求时。 public-key-cache-ttl 指定Keycloak检索新公钥的两个请求之间的最大间隔的时间量（以秒为单位）。 默认为86400秒（1天）。 当适配器识别带有未知kid的令牌时，它总是会尝试下载新的公钥。 如果它识别已知kid的令牌，它将只使用先前下载的公钥。 但是，每个此配置的间隔（默认为1天）至少一次将是新的公钥，即使令牌的kid已知，也会一直下载。 ignore-oauth-query-parameter 默认为false，如果设置为true将关闭处理承载令牌处理的access_token查询参数。 如果用户只传入access_token，他们将无法进行身份验证 redirect-rewrite-rules 如果需要，请指定重定向URI重写规则。 这是一个对象表示法，其中键是要与Redirect URI匹配的正则表达式，值是替换String。 $字符可用于替换String中的反向引用。 verify-token-audience 如果设置为“true”，则在使用承载令牌进行身份验证期间，适配器将验证令牌是否包含此客户端名称（资源）作为受众。 该选项对于主要服务于由承载令牌验证的请求的服务特别有用。 默认设置为false，但为了提高安全性，建议启用此功能。 有关受众群体支持的详细信息，请参阅受众群体支持。 2.1.2. JBoss EAP/WildFly 适配器 为了能够保护部署在JBoss EAP，WildFly或JBoss AS上的WAR应用程序，您必须安装和配置Keycloak适配器子系统。 然后，您有两个选项来保护您的WAR。 您可以在WAR中提供适配器配置文件，并在web.xml中将auth-method更改为KEYCLOAK。 或者，您根本不必修改WAR，并且可以通过配置文件中的Keycloak适配器子系统配置（例如standalone.xml）来保护它。 本节将介绍这两种方法。 安装适配器 根据您使用的服务器版本，适配器可作为单独的存档提供。 我们只测试和维护适配器，并在发布时提供最新版本的WildFly。 一旦发布了新版本的WildFly，当前的适配器将被弃用，并且在下一个WildFly版本发布后将删除对它们的支持。 另一种方法是将应用程序从WildFly切换到JBoss EAP，因为JBoss EAP适配器的支持时间更长。 安装WildFly 9或更新版本: $ cd $WILDFLY_HOME $ unzip keycloak-wildfly-adapter-dist-6.0.1.zip 安装WildFly 8: $ cd $WILDFLY_HOME $ unzip keycloak-wf8-adapter-dist-6.0.1.zip 安装JBoss EAP 7: $ cd $EAP_HOME $ unzip keycloak-eap7-adapter-dist-6.0.1.zip 安装JBoss EAP 6: $ cd $EAP_HOME $ unzip keycloak-eap6-adapter-dist-6.0.1.zip 安装JBoss AS 7.1: $ cd $JBOSS_HOME $ unzip keycloak-as7-adapter-dist-6.0.1.zip 此ZIP存档包含特定于Keycloak适配器的JBoss模块。 它还包含JBoss CLI脚本以配置适配器子系统。 要在服务器未运行时配置适配器子系统，请执行： 或者，您可以在从命令行安装适配器时指定server.config属性，以使用其他配置安装适配器，例如：-Dserver.config=standalone-ha.xml。 WildFly 11 或者 更新版本 $ ./bin/jboss-cli.sh --file=bin/adapter-elytron-install-offline.cli WildFly 10 或者 更旧版本 $ ./bin/jboss-cli.sh --file=bin/adapter-install-offline.cli 可以在WildFly 11或更新版本上使用传统的非Elytron适配器，这意味着即使在这些版本上也可以使用adapter-install-offline.cli。 但是，我们建议使用较新的Elytron适配器。 或者，如果服务器正在运行，则执行： WildFly 11 或者 更新版本 $ ./bin/jboss-cli.sh -c --file=bin/adapter-elytron-install.cli WildFly 10 或者 更旧版本 $ ./bin/jboss-cli.sh -c --file=bin/adapter-install.cli JBoss SSO WildFly内置支持部署到同一WildFly实例的Web应用程序的单点登录。 使用Keycloak时不应启用此功能。 每个WAR配置必需 本节介绍如何通过在WAR包中添加配置和编辑文件来直接保护WAR。 您必须做的第一件事是在WAR的WEB-INF目录中创建一个keycloak.json适配器配置文件。 此配置文件的格式在Java适配器配置 部分中进行了描述。 接下来，您必须在web.xml中将auth-method设置为KEYCLOAK。 您还必须使用标准servlet安全性来指定URL上的角色基础约束。 这是一个例子： application Admins /admin/* admin CONFIDENTIAL Customers /customers/* user CONFIDENTIAL KEYCLOAK this is ignored currently admin user 通过适配器子系统保护WAR 您不必修改WAR以使用Keycloak保护它。 相反，您可以通过Keycloak适配器子系统从外部保护它。 虽然您不必将KEYCLOAK指定为auth-method，但仍需要在web.xml中定义security-constraints。 但是，您不必创建WEB-INF/keycloak.json文件。 而是在Keycloak子系统定义中的服务器配置（即standalone.xml）中定义此元数据。 demo http://localhost:8081/auth external customer-portal password secure-deployment``name属性标识要保护的WAR。 它的值是web.xml中定义的module-name，附加了.war。 其余的配置几乎与Java adapter configuration中定义的keycloak.json配置选项一一对应。 例外是credential元素。 为了方便您，您可以转到Keycloak管理控制台并转到此WAR所对应的应用程序的客户端/安装选项卡。 它提供了一个可以剪切和粘贴的示例XML文件。 如果您有多个由同一领域保护的部署，则可以在单独的元素中共享领域配置。 例如： http://localhost:8080/auth external demo customer-portal password demo product-portal password demo database-service true 安全域 要将安全上下文传播到EJB层，您需要将其配置为使用“keycloak”安全域。 这可以通过@SecurityDomain注释来实现： import org.jboss.ejb3.annotation.SecurityDomain; ... @Stateless @SecurityDomain(\"keycloak\") public class CustomerService { @RolesAllowed(\"user\") public List getCustomers() { return db.getCustomers(); } } 2.1.3. 从RPM安装JBoss EAP适配器 从RPM安装EAP 7适配器： 在Red Hat Enterprise Linux 7中，term channel被替换为term repository。 在这些说明中，仅使用term repository。 您必须先订阅JBoss EAP 7.2存储库，然后才能从RPM安装EAP 7适配器。 先决条件 确保您的Red Hat Enterprise Linux系统已使用Red Hat Subscription Manager注册到您的帐户。 有关更多信息，请参阅Red Hat订阅管理文档。 如果您已经订阅了另一个JBoss EAP存储库，则必须先取消订阅该存储库。 使用Red Hat订阅管理器，使用以下命令订阅JBoss EAP 7.2存储库。根据您的Red Hat Enterprise Linux版本，将替换为6或7。 $ sudo subscription-manager repos --enable=jb-eap-7-for-rhel--server-rpms 使用以下命令安装OIDC的EAP 7适配器: $ sudo yum install eap7-keycloak-adapter-sso7_3 RPM安装的默认EAP_HOME路径是:/opt/rh/eap7/root/usr/share/wildfly。 运行适当的模块安装脚本。 对于OIDC模块，输入以下命令: $ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install.cli 安装完成。 从RPM安装EAP 6适配器: 在Red Hat Enterprise Linux 7中，term channel被term repository替换。在这些指令中，只使用term repository。 在从RPM安装EAP 6适配器之前，必须订阅JBoss EAP 6.0存储库。 先决条件 确保您的Red Hat Enterprise Linux系统使用Red Hat Subscription Manager注册到您的帐户。有关更多信息，请参见Red Hat订阅管理文档。 如果您已经订阅了另一个JBoss EAP存储库，则必须首先从该存储库取消订阅。 使用Red Hat订阅管理器，使用以下命令订阅JBoss EAP 6.0存储库。根据您的Red Hat Enterprise Linux版本，将替换为6或7。 $ sudo subscription-manager repos --enable=jb-eap-6-for-rhel--server-rpms 使用以下命令安装OIDC的EAP 6适配器: $ sudo yum install keycloak-adapter-sso7_3-eap6 RPM安装的默认EAP_HOME路径是/opt/rh/eap6/root/usr/share/wildfly。 运行适当的模块安装脚本。 对于OIDC模块，输入以下命令: $ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install.cli 安装完成。 2.1.4. JBoss Fuse 6 适配器 Keycloak支持保护在JBoss Fuse 6中运行的web应用程序。 JBoss Fuse 6利用Jetty 9适配器作为JBoss Fuse 6.3.0 Rollup 5与Jetty 9.2服务器捆绑在一起和Jetty用于运行各种Web应用程序。 Fuse 6唯一受支持的版本是最新版本。 如果使用早期版本的Fuse 6，则某些功能可能无法正常工作。 特别是，Hawtio集成不适用于早期版本的Fuse 6。 Fuse支持以下项目的安全性: 使用Pax Web WAR Extender在Fuse上部署经典的WAR应用程序 使用Pax Web白板扩展器将servlet作为OSGI服务部署在Fuse上 Apache Camel使用Camel Jetty组件运行的Jetty端点 Apache CXF端点在自己独立的Jetty引擎上运行 Apache CXF在CXF servlet提供的默认引擎上运行的端点 SSH和JMX管理员访问权限 Hawtio管理控制台 在Fuse 6中保护Web应用程序 您必须先安装Keycloak Karaf功能。 接下来，您需要根据要保护的应用程序类型执行这些步骤。 所有引用的Web应用程序都需要将Keycloak Jetty身份验证器注入底层Jetty服务器。 实现此目标的步骤取决于应用程序类型。 细节描述如下。 最好的起点是看看作为fuse目录中Keycloak示例的一部分捆绑的Fuse演示。 通过测试和理解演示，大多数步骤都应该是可以理解的。 安装Keycloak功能 您必须首先在JBoss Fuse环境中安装keycloak功能。 keycloak功能包括Fuse适配器和所有第三方依赖项。 您可以从Maven存储库或存档中安装它。 从Maven存储库安装 作为先决条件，您必须在线并且可以访问Maven存储库。 对于社区来说，只要在maven中央存储库中提供所有工件和第三方依赖项就足够了。 要使用Maven存储库安装keycloak功能，请完成以下步骤： 启动JBoss Fuse 6.3.0 Rollup 5; 然后在Karaf终端类型： features:addurl mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features features:install keycloak 您可能还需要安装Jetty 9功能： features:install keycloak-jetty9-adapter 确保已安装功能： features:list | grep keycloak 从ZIP捆绑包安装 如果您处于脱机状态或不想使用Maven获取JAR文件和其他工件，这将非常有用。 要从ZIP存档安装Fuse适配器，请完成以下步骤： 下载Keycloak Fuse适配器ZIP存档文件。 将其解压缩到JBoss Fuse的根目录中。 然后将依赖项安装在system目录下。 您可以覆盖所有现有的jar文件。 将此用于JBoss Fuse 6.3.0汇总5： cd /path-to-fuse/jboss-fuse-6.3.0.redhat-254 unzip -q /path-to-adapter-zip/keycloak-fuse-adapter-6.0.1.zip 启动Fuse并在Fuse/karaf终端中运行以下命令: features:addurl mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features features:install keycloak 安装相应的Jetty适配器。 由于artifacts可直接在JBoss Fusesystem目录中使用，因此您无需使用Maven存储库。 保护经典WAR应用程序 保护WAR应用程序所需的步骤如下： 在/WEB-INF/web.xml文件中，声明必要的： 元素中的安全性约束 元素中的登录配置 元素中的安全角色。 例如： customer-portal index.html Customers /customers/* user BASIC does-not-matter admin user 将带有验证器的jetty-web.xml文件添加到/WEB-INF/jetty-web.xml文件中。 例如： 在WAR的/WEB-INF/目录中，创建一个新文件keycloak.json。 该配置文件的格式在Java Adapters Config 部分中进行了描述。 也可以按配置外部适配器中的说明在外部使用此文件。 确保您的WAR应用程序在Import-Package标题下的META-INF/MANIFEST.MF文件中导入org.keycloak.adapters.jetty和更多软件包。 在项目中使用maven-bundle-plugin可以在清单中正确生成OSGI头文件。 请注意，包的“*”解析不会导入org.keycloak.adapters.jetty包，因为它不是由应用程序或Blueprint或Spring描述符使用，而是在jetty-web.xml文件中使用。 要导入的包的列表可能是这样的: org.keycloak.adapters.jetty;version=\"6.0.1\", org.keycloak.adapters;version=\"6.0.1\", org.keycloak.constants;version=\"6.0.1\", org.keycloak.util;version=\"6.0.1\", org.keycloak.*;version=\"6.0.1\", *;resolution:=optional 配置外部适配器 如果您不希望将keycloak.json适配器配置文件捆绑在WAR应用程序中，而是根据命名约定在外部提供并加载，请使用此配置方法。 要启用该功能，请将此部分添加到/WEB_INF/web.xml文件中： keycloak.config.resolver org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver 该组件使用keycloak.config或karaf.etc java属性来搜索基本文件夹以找到配置。 然后在其中一个文件夹中搜索名为 -keycloak.json的文件。 因此，例如，如果您的Web应用程序具有上下文my-portal，那么您的适配器配置将从$FUSE_HOME/etc/my-portal-keycloak.json文件加载。 保护部署为OSGI服务的Servlet 如果在OSGI捆绑项目中有一个未部署为经典WAR应用程序的servlet类，则可以使用此方法。 Fuse使用Pax Web Whiteboard Extender将这些servlet部署为Web应用程序。 要使用Keycloak保护您的servlet，请完成以下步骤： Keycloak提供了PaxWebIntegrationService，它允许注入jetty-web.xml并为您的应用程序配置安全性约束。 您需要在应用程序内的OSGI-INF/blueprint/blueprint.xml文件中声明此类服务。 请注意，您的servlet需要依赖它。 配置示例： user 您可能需要在项目中包含WEB-INF目录（即使您的项目不是Web应用程序）并创建/WEB-INF/jetty-web.xml和/WEB-INF/keycloak.json文件，如经典WAR应用程序部分。 请注意，您不需要web.xml文件，因为在蓝图配置文件中声明了安全性约束。 META-INF/MANIFEST.MF中的Import-Package必须至少包含以下导入： org.keycloak.adapters.jetty;version=\"6.0.1\", org.keycloak.adapters;version=\"6.0.1\", org.keycloak.constants;version=\"6.0.1\", org.keycloak.util;version=\"6.0.1\", org.keycloak.*;version=\"6.0.1\", *;resolution:=optional 保护Apache Camel应用程序 您可以通过添加带有KeycloakJettyAuthenticator的securityHandler并注入适当的安全约束来保护使用camel-jetty组件实现的Apache Camel端点。 您可以使用类似以下配置将OSGI-INF/blueprint/blueprint.xml文件添加到Camel应用程序中。 角色，安全约束映射和Keycloak适配器配置可能略有不同，具体取决于您的环境和需求。 例如： admin META-INF/MANIFEST.MF中的Import-Package需要包含这些导入： javax.servlet;version=\"[3,4)\", javax.servlet.http;version=\"[3,4)\", org.apache.camel.*, org.apache.camel;version=\"[2.13,3)\", org.eclipse.jetty.security;version=\"[9,10)\", org.eclipse.jetty.server.nio;version=\"[9,10)\", org.eclipse.jetty.util.security;version=\"[9,10)\", org.keycloak.*;version=\"6.0.1\", org.osgi.service.blueprint, org.osgi.service.blueprint.container, org.osgi.service.event, Camel RestDSL Camel Rest DSL是一种Camel功能，用于以流畅的方式定义REST端点。 但您仍必须使用特定的实现类，并提供有关如何与Keycloak集成的说明。 配置集成机制的方法取决于您为其配置RestDSL定义的路由的Camel组件。 以下示例显示如何使用Jetty组件配置集成，以及对先前Blueprint示例中定义的某些bean的引用。 Hello rest service Just an helllo (__This second sentence is returned from a Camel RestDSL endpoint__) 在单独的Jetty引擎上保护Apache CXF端点 要在单独的Jetty引擎上运行Keycloak保护的CXF端点，请完成以下步骤： 将META-INF/spring/beans.xml添加到您的应用程序中，并在其中使用Jetty SecurityHandler声明httpj：ngine-factory，并注入KeycloakJettyAuthenticator。 CFX JAX-WS应用程序的配置可能类似于以下内容： user true 对于CXF JAX-RS应用程序，唯一的区别可能在于依赖于engine-factory的端点配置： META-INF/MANIFEST.MF中的Import-Package必须包含那些导入： META-INF.cxf;version=\"[2.7,3.2)\", META-INF.cxf.osgi;version=\"[2.7,3.2)\";resolution:=optional, org.apache.cxf.bus;version=\"[2.7,3.2)\", org.apache.cxf.bus.spring;version=\"[2.7,3.2)\", org.apache.cxf.bus.resource;version=\"[2.7,3.2)\", org.apache.cxf.transport.http;version=\"[2.7,3.2)\", org.apache.cxf.*;version=\"[2.7,3.2)\", org.springframework.beans.factory.config, org.eclipse.jetty.security;version=\"[9,10)\", org.eclipse.jetty.util.security;version=\"[9,10)\", org.keycloak.*;version=\"6.0.1\" 在默认Jetty引擎上保护Apache CXF端点 某些服务会在启动时自动附带已部署的servlet。 一个这样的服务是在http://localhost:8181/cxf上下文中运行的CXF servlet。 保护这些端点可能很复杂。 Keycloak目前使用的一种方法是ServletReregistrationService，它在启动时取消部署内置servlet，使您能够在Keycloak保护的上下文中重新部署它。 应用程序中的配置文件OSGI-INF/blueprint/blueprint.xml可能类似于下面的那个。 请注意，它添加了JAX-RScustomerservice端点，它是特定于端点的应用程序，但更重要的是，它保护整个/cxf上下文。 user 因此，在默认CXF HTTP目标上运行的所有其他CXF服务也是安全的。 类似地，当取消部署应用程序时，整个/cxf上下文也变得不安全。 因此，如在单独的Jetty引擎上安全CXF应用程序中所述，为您的应用程序使用自己的Jetty引擎，然后为您提供 更好地控制每个应用程序的安全性。 WEB-INF目录可能需要在您的项目中（即使您的项目不是Web应用程序）。 您可能还需要以与经典WAR应用程序类似的方式编辑/WEB-INF/jetty-web.xml和/WEB-INF/keycloak.json文件。 请注意，您不需要web.xml文件，因为蓝图配置文件中声明了安全性约束。 META-INF/MANIFEST.MF中的Import-Package必须包含以下导入： META-INF.cxf;version=\"[2.7,3.2)\", META-INF.cxf.osgi;version=\"[2.7,3.2)\";resolution:=optional, org.apache.cxf.transport.http;version=\"[2.7,3.2)\", org.apache.cxf.*;version=\"[2.7,3.2)\", com.fasterxml.jackson.jaxrs.json;version=\"[2.5,3)\", org.eclipse.jetty.security;version=\"[9,10)\", org.eclipse.jetty.util.security;version=\"[9,10)\", org.keycloak.*;version=\"6.0.1\", org.keycloak.adapters.jetty;version=\"6.0.1\", *;resolution:=optional 安全Fuse管理服务 使用SSH身份验证来融合终端 Keycloak主要处理用于Web应用程序身份验证的用例; 但是，如果您的其他Web服务和应用程序受Keycloak保护，则使用Keycloak凭据保护非Web管理服务（如SSH）是最佳实践。 您可以使用JAAS登录模块执行此操作，该模块允许远程连接到Keycloak并根据资源所有者密码凭据验证凭据。 要启用SSH身份验证，请完成以下步骤： 在Keycloak中创建一个客户端（例如，ssh-jmx-admin-client），它将用于SSH身份验证。 此客户端需要将Direct Access Grants Enabled选为On。 在$FUSE_HOME/etc/org.apache.karaf.shell.cfg文件中，更新或指定此属性： sshRealm=keycloak 添加$FUSE_HOME/etc/keycloak-direct-access.json文件，其内容类似于以下内容（基于您的环境和Keycloak客户端设置）： { \"realm\": \"demo\", \"resource\": \"ssh-jmx-admin-client\", \"ssl-required\" : \"external\", \"auth-server-url\" : \"http://localhost:8080/auth\", \"credentials\": { \"secret\": \"password\" } } 此文件指定客户端应用程序配置，该命令由来自keycloak JAAS领域的JAAS DirectAccessGrantsLoginModule用于SSH身份验证。 启动Fuse并安装keycloak JAAS领域。 最简单的方法是安装keycloak-jaas功能，它具有预定义的JAAS领域。 您可以使用自己的keycloak JAAS领域覆盖该功能的预定义领域。 有关详细信息，请参阅JBoss Fuse文档。 在Fuse终端中使用以下命令： features:addurl mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features features:install keycloak-jaas 通过在终端中键入以下内容，使用SSH作为admin用户登录： ssh -o PubkeyAuthentication=no -p 8101 admin@localhost 使用密码password登录。 在某些更高版本的操作系统上，您可能还需要使用SSH命令的-o选项-o HostKeyAlgorithms=+ssh-dss，因为以后的SSH客户端默认情况下不允许使用ssh-dss算法。 但是，默认情况下，它目前用于JBoss Fuse 6.3.0 Rollup 5。 请注意，用户需要具有领域角色admin来执行所有操作或其他角色来执行操作子集（例如，viewer角色限制用户仅运行只读的Karaf命令）。 可用角色在$FUSE_HOME/etc/org.apache.karaf.shell.cfg或$FUSE_HOME/etc/system.properties中配置。 使用JMX身份验证 如果要使用jconsole或其他外部工具通过RMI远程连接到JMX，则可能需要JMX身份验证。 否则最好使用hawt.io/jolokia，因为jolokia代理默认安装在hawt.io中。 有关详细信息，请参阅Hawtio管理控制台。 要使用JMX身份验证，请完成以下步骤： 在$FUSE_HOME/etc/org.apache.karaf.management.cfg文件中，将jmxRealm属性更改为： jmxRealm=keycloak 安装keycloak-jaas功能并配置$FUSE_HOME/etc/keycloak-direct-access.json文件，如上面的SSH部分所述。 在jconsole中，您可以使用以下URL： service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root 和凭据：admin/password（根据您的环境，具有管理员权限的用户）。 保护Hawtio管理控制台 要使用Keycloak保护Hawtio管理控制台，请完成以下步骤: 将这些属性添加到$FUSE_HOME/etc/system.properties文件中： hawtio.keycloakEnabled=true hawtio.realm=keycloak hawtio.keycloakClientConfig=file://${karaf.base}/etc/keycloak-hawtio-client.json hawtio.rolePrincipalClasses=org.keycloak.adapters.jaas.RolePrincipal,org.apache.karaf.jaas.boot.principal.RolePrincipal 在您的领域的Keycloak管理控制台中创建一个客户端。 例如，在Keycloakdemo领域，创建一个客户端hawtio-client，指定public作为Access Type，并指定一个指向Hawtio的重定向URI：http://localhost:8181/hawtio/*。 您还必须配置相应的Web Origin（在本例中为http://localhost:8181）。 使用类似于下面示例中所示的内容在$FUSE_HOME/etc目录中创建keycloak-hawtio-client.json文件。 根据您的Keycloak环境更改realm，resource和auth-server-url属性。 resource属性必须指向上一步中创建的客户端。 该文件由客户端（Hawtio JavaScript应用程序）使用。 { \"realm\" : \"demo\", \"resource\" : \"hawtio-client\", \"auth-server-url\" : \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"public-client\" : true } 使用类似于下面示例中所示的内容在$FUSE_HOME/etc 目录中创建keycloak-hawtio.json文件。 根据您的Keycloak环境更改realm和auth-server-url属性。 此文件由服务器（JAAS登录模块）端的适配器使用。 { \"realm\" : \"demo\", \"resource\" : \"jaas\", \"bearer-only\" : true, \"auth-server-url\" : \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"use-resource-role-mappings\": false, \"principal-attribute\": \"preferred_username\" } 启动JBoss Fuse 6.3.0 Rollup 5并安装keycloak功能（如果尚未安装）。 Karaf终端中的命令与此示例类似： features:addurl mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features features:install keycloak 转到http://localhost:8181/hawtio并以Keycloak领域的用户身份登录。 请注意，用户需要具有适当的领域角色才能成功向Hawtio进行身份验证。 可用角色在hawtio.roles中的$FUSE_HOME/etc/system.properties文件中配置。 保护JBoss EAP 6.4上的Hawtio 要在JBoss EAP 6.4服务器上运行Hawtio，请完成以下步骤: 按照上一节“保护Hawtio管理控制台”中的说明设置Keycloak。 假设： 你有一个Keycloak领域demo和客户hawtio-client 你的Keycloak在localhost:8080上运行 部署了Hawtio的JBoss EAP 6.4服务器将在localhost:8181上运行。 具有此服务器的目录在后续步骤中称为$EAP_HOME。 将hawtio-wildfly-1.4.0.redhat-630254.war存档复制到$EAP_HOME/standalone/configuration目录。 有关部署Hawtio的更多详细信息，请参阅Fuse Hawtio文档。 将带有上述内容的keycloak-hawtio.json和keycloak-hawtio-client.json文件复制到$EAP_HOME/standalone/configuration目录。 按照JBoss适配器文档中的说明，将Keycloak适配器子系统安装到JBoss EAP 6.4服务器上。 在$EAP_HOME/standalone/configuration/standalone.xml文件中配置系统属性，如下例所示： ... 将Hawtio域添加到security-domains部分中的同一文件： 将secure-deployment部分hawtio添加到适配器子系统。 这可确保Hawtio WAR能够找到JAAS登录模块类。 使用Hawtio重新启动JBoss EAP 6.4服务器： cd $EAP_HOME/bin ./standalone.sh -Djboss.socket.binding.port-offset=101 在http://localhost:8181/hawtio访问Hawtio。 它由Keycloak保护。 2.1.5. JBoss Fuse 7 适配器 Keycloak支持保护在JBoss Fuse 7中运行的Web应用程序。 JBoss Fuse 7利用了Undertow适配器，它与EAP 7 / WildFly适配器基本相同，因为捆绑了JBoss Fuse 7.2.0 使用Undertow HTTP引擎，Undertow用于运行各种Web应用程序。 唯一受支持的Fuse 7版本是最新版本。 如果使用早期版本的Fuse 7，则某些功能可能无法正常工作。 特别是，对于低于7.0.1的Fuse 7版本，集成将完全不起作用。 Fuse支持以下项目的安全性: 使用Pax Web War Extender部署在Fuse上的经典WAR应用程序 使用Pax Web Whiteboard Extender作为OSGI服务部署在Fuse上的Servlet以及通过org.osgi.service.http.HttpService#registerServlet()注册的servlet，这是标准的OSGi Enterprise HTTP服务 Apache Camel 使用Camel Undertow组件运行的端点 Apache CXF 端点在他们自己独立的Undertow引擎上运行 Apache CXF 在CXF servlet提供的默认引擎上运行的端点 SSH和JMX管理员访问权限 Hawtio管理控制台 在Fuse 7中保护Web应用程序 您必须先安装Keycloak Karaf功能。 接下来，您需要根据要保护的应用程序类型执行这些步骤。 所有引用的Web应用程序都需要将Keycloak Undertow身份验证机制注入底层Web服务器。 实现此目标的步骤取决于应用程序类型。 细节描述如下。 最好的起点是看看作为fuse目录中Keycloak示例的一部分捆绑的Fuse演示。 通过测试和理解演示，大多数步骤都应该是可以理解的。 安装Keycloak功能 您必须首先在JBoss Fuse环境中安装keycloak-pax-http-afow和keycloak-jaas功能。 keycloak-pax-http-undertow功能包括Fuse适配器和所有第三方依赖项。 keycloak-jaas包含用于SSH和JMX身份验证的领域中的JAAS模块。 您可以从Maven存储库或存档中安装它。 从Maven存储库安装 作为先决条件，您必须在线并且可以访问Maven存储库。 对于社区来说，只要在maven中央存储库中提供所有工件和第三方依赖项就足够了。 要使用Maven存储库安装keycloak功能，请完成以下步骤： 启动JBoss Fuse 7.2.0; 然后在Karaf终端类型： feature:repo-add mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features feature:install keycloak-pax-http-undertow keycloak-jaas 您可能还需要安装Undertow功能： feature:install pax-http-undertow 确保已安装功能： feature:list | grep keycloak 从ZIP捆绑包安装 如果您处于脱机状态或不想使用Maven获取JAR文件和其他工件，这将非常有用。 要从ZIP存档安装Fuse适配器，请完成以下步骤： 下载Keycloak Fuse适配器ZIP存档。 将其解压缩到JBoss Fuse的根目录中。 然后将依赖项安装在system目录下。 您可以覆盖所有现有的jar文件。 用于JBoss Fuse 7.2.0： cd /path-to-fuse/fuse-karaf-7.z unzip -q /path-to-adapter-zip/keycloak-fuse-adapter-6.0.1.zip 启动Fuse并在Fuse /karaf终端中运行以下命令: feature:repo-add mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features feature:install keycloak-pax-http-undertow keycloak-jaas 安装相应的Undertow适配器。 由于工件可直接在JBoss Fusesystem目录中使用，因此您无需使用Maven存储库。 保护经典WAR应用程序 保护WAR应用程序所需的步骤如下： 在/WEB-INF/web.xml文件中，声明必要的： 元素中的安全性约束 元素中的登录配置。 确保是KEYCLOAK。 元素中的安全角色 例如： customer-portal index.html Customers /customers/* user KEYCLOAK does-not-matter admin user 在WAR的/WEB-INF/目录中，创建一个新文件keycloak.json。 该配置文件的格式在Java Adapters Config部分中进行了描述。 也可以按配置外部适配器中的说明在外部使用此文件。 例如： { \"realm\": \"demo\", \"resource\": \"customer-portal\", \"auth-server-url\": \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"credentials\": { \"secret\": \"password\" } } 与Fuse 6适配器相反，MANIFEST.MF中不需要特殊的OSGi导入。 配置解析器 keycloak.json适配器配置文件可以存储在捆绑包中，这是默认行为，也可以存储在文件系统的目录中。 要指定配置文件的实际源，请将keycloak.config.resolver部署参数设置为所需的配置解析程序类。 例如，在经典的WAR应用程序中，在web.xml文件中设置keycloak.config.resolver上下文参数，如下所示： keycloak.config.resolver org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver 以下解析器可用于keycloak.config.resolver： org.keycloak.adapters.osgi.BundleBasedKeycloakConfigResolver 这是默认的解析器。 预期配置文件位于受保护的OSGi包中。 默认情况下，它加载名为WEB-INF/keycloak.json的文件，但可以通过configLocation属性配置此文件名。 org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver 此解析程序在keycloak.config系统属性指定的文件夹中搜索名为-keycloak.json的文件。 如果未设置keycloak.config，则使用karaf.etc系统属性。例如，如果您的Web应用程序部署到上下文my-portal中，那么您的适配器配置将从${keycloak.config}/my-portal-keycloak.json文件加载，或来自${karaf.etc}/my-portal-keycloak.json。 org.keycloak.adapters.osgi.HierarchicalPathBasedKeycloakConfigResolver 这个解析器类似于上面的PathBasedKeycloakConfigResolver，对于给定的URI路径，配置位置会从最特定到最不特定地进行检查。例如，对于/my/web-app/contextURI，将搜索以下配置位置，直到第一个配置位置存在:${karaf.etc}/my-web-app-context-keycloak.json``${karaf.etc}/my-web-app-keycloak.json``${karaf.etc}/my-keycloak.json``${karaf.etc}/keycloak.json 保护部署为OSGI服务的Servlet 如果在OSGI捆绑项目中有一个未部署为经典WAR应用程序的servlet类，则可以使用此方法。 Fuse使用Pax Web Whiteboard Extender将这些servlet部署为Web应用程序。 要使用Keycloak保护您的servlet，请完成以下步骤： Keycloak提供了org.keycloak.adapters.osgi.undertow.PaxWebIntegrationService，它允许为您的应用程序配置身份验证方法和安全性约束。 您需要在应用程序内的OSGI-INF/blueprint/blueprint.xml文件中声明此类服务。 请注意，您的servlet需要依赖它。 配置示例： user 您可能需要在项目中包含WEB-INF目录（即使您的项目不是Web应用程序）并创建/WEB-INF/keycloak.json文件，如Classic WAR application中所述部分。 请注意，您不需要web.xml文件，因为在蓝图配置文件中声明了安全性约束。 与Fuse 6适配器相反，MANIFEST.MF中不需要特殊的OSGi导入。 保护Apache Camel应用程序 您可以通过蓝图注入适当的安全约束并将使用过的组件更新为undertow-keycloak来保护使用camel-undertow组件实现的Apache Camel端点。 您必须使用类似以下配置将OSGI-INF/blueprint/blueprint.xml文件添加到Camel应用程序中。 角色和安全性约束映射以及适配器配置可能略有不同，具体取决于您的环境和需求。 与标准的undertow组件相比，undertow-keycloak组件增加了两个新属性： configResolver是一个解析器bean，提供Keycloak适配器配置。 可用的解析器列在配置解析器部分中。 allowedRoles是以逗号分隔的角色列表。 访问服务的用户必须至少具有一个允许访问的角色。 例如： META-INF/MANIFEST.MF中的Import-Package需要包含这些导入： javax.servlet;version=\"[3,4)\", javax.servlet.http;version=\"[3,4)\", javax.net.ssl, org.apache.camel.*, org.apache.camel;version=\"[2.13,3)\", io.undertow.*, org.keycloak.*;version=\"6.0.1\", org.osgi.service.blueprint, org.osgi.service.blueprint.container Camel RestDSL Camel Rest DSL是一种Camel功能，用于以流畅的方式定义REST端点。 但您仍必须使用特定的实现类，并提供有关如何与Keycloak集成的说明。 配置集成机制的方法取决于您为其配置RestDSL定义的路由的Camel组件。 以下示例显示如何使用undertow-keycloak组件配置集成，并引用前一个Blueprint示例中定义的一些bean。 Hello rest service Just a hello (__This second sentence is returned from a Camel RestDSL endpoint__) 在单独的Undertow引擎上保护Apache CXF端点 要在单独的Undertow引擎上运行Keycloak保护的CXF端点，请完成以下步骤： 将OSGI-INF/blueprint/blueprint.xml添加到您的应用程序中，并在其中添加与Camel配置类似的正确配置解析程序bean。 在httpu:engine-factory中使用该camel配置声明org.keycloak.adapters.osgi.undertow.CxfKeycloakAuthHandler处理程序。 CFX JAX-WS应用程序的配置可能类似于以下内容： For the CXF JAX-RS application, the only difference might be in the configuration of the endpoint dependent on engine-factory: META-INF/MANIFEST.MF中的Import-Package必须包含那些导入： META-INF.cxf;version=\"[2.7,3.3)\", META-INF.cxf.osgi;version=\"[2.7,3.3)\";resolution:=optional, org.apache.cxf.bus;version=\"[2.7,3.3)\", org.apache.cxf.bus.spring;version=\"[2.7,3.3)\", org.apache.cxf.bus.resource;version=\"[2.7,3.3)\", org.apache.cxf.transport.http;version=\"[2.7,3.3)\", org.apache.cxf.*;version=\"[2.7,3.3)\", org.springframework.beans.factory.config, org.keycloak.*;version=\"6.0.1\" 在默认的Undertow引擎上保护Apache CXF端点 某些服务会在启动时自动附带已部署的servlet。 一个这样的服务是在http:// localhost:8181/cxf上下文中运行的CXF servlet。 Fuse的Pax Web支持通过配置管理改变现有的上下文。 这可用于通过Keycloak保护端点。 应用程序中的配置文件OSGI-INF/blueprint/blueprint.xml可能类似于下面的那个。 请注意，它添加了JAX-RS customerservice端点，该端点是特定于端点的应用程序。 此外，您必须创建${karaf.etc}/org.ops4j.pax.web.context-*anyName*.cfg file。 它将被视为工厂PID配置，由pax-web-runtime包跟踪。 此类配置可能包含以下属性，这些属性对应于标准web.xml的某些属性： bundle.symbolicName = org.apache.cxf.cxf-rt-transports-http context.id = default context.param.keycloak.config.resolver = org.keycloak.adapters.osgi.HierarchicalPathBasedKeycloakConfigResolver login.config.authMethod = KEYCLOAK security.cxf.url = /cxf/customerservice/* security.cxf.roles = admin, user 有关配置管理文件中可用属性的完整说明，请参阅Fuse文档。 上述属性具有以下含义： bundle.symbolicName 和 context.id 在org.ops4j.pax.web.service.WebContainer中标识bundle及其部署上下文。 context.param.keycloak.config.resolver 为bundle提供keycloak.config.resolver上下文参数的值，与经典WAR中的web.xml相同。 可用的解析器在配置解析器部分中进行了描述。 login.config.authMethod 身份验证方法。 必须是KEYCLOAK。 security.*anyName*.url 和 security.*anyName*.roles 各个安全约束的属性值就像在web.xml中的security-constraint/web-resource-collection/url-pattern 和 security-constraint/auth-constraint/role-name中设置的那样， 分别。 角色由逗号和周围的空格分隔。 * anyName*标识符可以是任意的，但必须匹配相同安全约束的各个属性。一些Fuse版本包含一个错误，需要将角色分隔为\", \"（逗号和单个空格）。 确保使用这种表示法来分离角色。 META-INF/MANIFEST.MF中的Import-Package必须至少包含以下导入： javax.ws.rs;version=\"[2,3)\", META-INF.cxf;version=\"[2.7,3.3)\", META-INF.cxf.osgi;version=\"[2.7,3.3)\";resolution:=optional, org.apache.cxf.transport.http;version=\"[2.7,3.3)\", org.apache.cxf.*;version=\"[2.7,3.3)\", com.fasterxml.jackson.jaxrs.json;version=\"${jackson.version}\" 保护Fuse管理服务 使用SSH身份验证来Fuse终端 Keycloak主要处理用于Web应用程序身份验证的用例; 但是，如果您的其他Web服务和应用程序受Keycloak保护，则使用Keycloak凭据保护非Web管理服务（如SSH）是最佳实践。 您可以使用JAAS登录模块执行此操作，该模块允许远程连接到Keycloak并根据资源所有者密码凭据验证凭据。 要启用SSH身份验证，请完成以下步骤： 在Keycloak中创建一个客户端（例如，ssh-jmx-admin-client），它将用于SSH身份验证。 此客户端需要将Direct Access Grants Enabled选为On。 在$FUSE_HOME/etc/org.apache.karaf.shell.cfg文件中，更新或指定此属性： sshRealm=keycloak 添加$FUSE_HOME/etc/ keycloak-direct-access.json文件，其内容类似于以下内容（基于您的环境和Keycloak客户端设置）： { \"realm\": \"demo\", \"resource\": \"ssh-jmx-admin-client\", \"ssl-required\" : \"external\", \"auth-server-url\" : \"http://localhost:8080/auth\", \"credentials\": { \"secret\": \"password\" } } 此文件指定客户端应用程序配置，该命令由来自keycloak JAAS领域的JAAS DirectAccessGrantsLoginModule用于SSH身份验证。 启动Fuse并安装keycloak JAAS领域。 最简单的方法是安装keycloak-jaas功能，它具有预定义的JAAS领域。 您可以使用自己的keycloak JAAS领域覆盖该功能的预定义领域。 有关详细信息，请参阅JBoss Fuse文档。 在Fuse终端中使用以下命令： features:addurl mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features features:install keycloak-jaas 通过在终端中键入以下内容，使用SSH作为admin用户登录： ssh -o PubkeyAuthentication=no -p 8101 admin@localhost 使用密码password登录。 在某些更高版本的操作系统上，您可能还需要使用SSH命令的-o选项-o HostKeyAlgorithms=+ssh-dss，因为以后的SSH客户端默认情况下不允许使用ssh-dss算法。 但是，默认情况下，它目前在JBoss Fuse 7.2.0中使用。 请注意，用户需要具有领域角色admin来执行所有操作或其他角色来执行操作子集（例如，viewer角色限制用户仅运行只读的Karaf命令）。 可用角色在$FUSE_HOME/etc/ org.apache.karaf.shell.cfg或$FUSE_HOME/etc/system.properties中配置。 使用JMX身份验证 如果要使用jconsole或其他外部工具通过RMI远程连接到JMX，则可能需要JMX身份验证。 否则最好使用hawt.io/jolokia，因为jolokia代理默认安装在hawt.io中。 有关详细信息，请参阅Hawtio管理控制台。 要使用JMX身份验证，请完成以下步骤： 在$FUSE_HOME/etc/org.apache.karaf.management.cfg文件中，将jmxRealm属性更改为： jmxRealm=keycloak 安装keycloak-jaas功能并配置$FUSE_HOME/etc/keycloak-direct-access.json文件，如上面的SSH部分所述。 在jconsole中，您可以使用以下URL： service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root 和凭据：admin/password（根据您的环境，具有管理员权限的用户）。 保护Hawtio管理控制台 要使用Keycloak保护Hawtio管理控制台，请完成以下步骤： 在您的领域的Keycloak管理控制台中创建一个客户端。 例如，在Keycloakdemorealm中，创建一个客户端hawtio-client，指定public作为Access Type，并指定一个指向Hawtio的重定向URI：http://localhost:8181/hawtio/*。 配置相应的Web Origin(在本例中为http://localhost:8181)。 设置客户端范围映射，在hawtio-client客户端详细信息中的scope选项卡中包含view-profile client角色account client。 使用类似于下面示例中所示的内容在$FUSE_HOME/etc目录中创建keycloak-hawtio-client.json文件。 根据您的Keycloak环境更改realm，resource和auth-server-url属性。 resource属性必须指向上一步中创建的客户端。 该文件由客户端（Hawtio JavaScript应用程序）使用。 { \"realm\" : \"demo\", \"clientId\" : \"hawtio-client\", \"url\" : \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"public-client\" : true } 使用类似于下面示例中所示的内容在$ FUSE_HOME/etc目录中创建keycloak-direct-access.json文件。 根据您的Keycloak环境更改realm和url属性。 该文件由JavaScript客户端使用。 { \"realm\" : \"demo\", \"resource\" : \"ssh-jmx-admin-client\", \"auth-server-url\" : \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"credentials\": { \"secret\": \"password\" } } 使用类似于下面示例中所示的内容在$FUSE_HOME/etc 目录中创建keycloak-hawtio.json 文件。 根据您的Keycloak环境更改realm和auth-server-url属性。 此文件由服务器（JAAS登录模块）端的适配器使用。 { \"realm\" : \"demo\", \"resource\" : \"jaas\", \"bearer-only\" : true, \"auth-server-url\" : \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"use-resource-role-mappings\": false, \"principal-attribute\": \"preferred_username\" } 启动JBoss Fuse 7.2.0，安装Keycloak功能。 然后输入Karaf终端： system:property -p hawtio.keycloakEnabled true system:property -p hawtio.realm keycloak system:property -p hawtio.keycloakClientConfig file://\\${karaf.base}/etc/keycloak-hawtio-client.json system:property -p hawtio.rolePrincipalClasses org.keycloak.adapters.jaas.RolePrincipal,org.apache.karaf.jaas.boot.principal.RolePrincipal restart io.hawt.hawtio-war 转到http://localhost:8181/hawtio并以Keycloak领域的用户身份登录。 请注意，用户需要具有适当的领域角色才能成功向Hawtio进行身份验证。 可用角色在hawtio.roles中的$FUSE_HOME/etc/system.properties文件中配置。 2.1.6. Spring Boot 适配器 为了能够保护Spring Boot应用程序，您必须将Keycloak Spring Boot适配器JAR添加到您的应用程序。 然后，您必须通过正常的Spring Boot配置（application.properties）提供一些额外的配置。 我们来看看这些步骤。 适配器安装 Keycloak Spring Boot适配器利用Spring Boot的自动配置，因此您只需将Keycloak Spring Boot启动器添加到您的项目中即可。 他们的Keycloak Spring Boot Starter也可以从Spring Start Page直接获得。 要使用Maven手动添加它，请将以下内容添加到依赖项中： org.keycloak keycloak-spring-boot-starter 添加适配器BOM依赖项： org.keycloak.bom keycloak-adapter-bom 6.0.1 pom import 目前支持以下嵌入式容器，如果使用Starter，则不需要任何额外的依赖项： Tomcat Undertow Jetty 必需的Spring Boot Adapter配置 本节介绍如何配置Spring Boot应用程序以使用Keycloak。 不需要配置keycloak.json文件，您可以通过正常的Spring Boot配置为Spring Boot Keycloak适配器配置域。 例如： keycloak.realm = demorealm keycloak.auth-server-url = http://127.0.0.1:8080/auth keycloak.ssl-required = external keycloak.resource = demoapp keycloak.credentials.secret = 11111111-1111-1111-1111-111111111111 keycloak.use-resource-role-mappings = true 您可以通过设置keycloak.enabled=false来禁用Keycloak Spring Boot Adapter（例如在测试中）。 要配置策略强制实施器，与keycloak.json不同，必须使用policy-enforcer-config而不仅仅是policy-enforcer。 您还需要指定通常位于web.xml中的Java EE安全配置。 Spring Boot Adapter将login-method设置为KEYCLOAK并在启动时配置security-constraints。 这是一个示例配置： keycloak.securityConstraints[0].authRoles[0] = admin keycloak.securityConstraints[0].authRoles[1] = user keycloak.securityConstraints[0].securityCollections[0].name = insecure stuff keycloak.securityConstraints[0].securityCollections[0].patterns[0] = /insecure keycloak.securityConstraints[1].authRoles[0] = admin keycloak.securityConstraints[1].securityCollections[0].name = admin stuff keycloak.securityConstraints[1].securityCollections[0].patterns[0] = /admin 如果您计划将Spring应用程序部署为WAR，那么不应该使用Spring引导适配器，而应该为您正在使用的应用程序服务器或servlet容器使用专用适配器。您的Spring Boot还应该包含一个 web.xml文件。 2.1.7. Tomcat 6, 7 and 8 适配器 为了能够保护部署在Tomcat 6,7和8上的WAR应用程序，您必须在Tomcat安装中安装Keycloak Tomcat 6,7或8适配器。 然后，您必须在部署到Tomcat的每个WAR中提供一些额外的配置。 我们来看看这些步骤。 适配器安装 适配器不再包含在设备或war分发版中。每个适配器在Keycloak下载站点上都是单独的下载。它们也可以作为maven构件使用。 您必须将适配器发行版解压到Tomcat的lib/目录中。在WEB-INF/lib目录中包含适配器的jar将不起作用!Keycloak适配器实现为一个Valve，而Valve代码必须驻留在Tomcat的主lib/目录中。 $ cd $TOMCAT_HOME/lib $ unzip keycloak-tomcat6-adapter-dist.zip or $ unzip keycloak-tomcat7-adapter-dist.zip or $ unzip keycloak-tomcat8-adapter-dist.zip 每个WAR配置所需 本节描述如何通过在WAR包中添加配置和编辑文件来直接保护WAR。 您必须做的第一件事是在WAR包中创建一个META-INF/context.xml文件。 这是一个特定于Tomcat的配置文件，您必须定义一个Keycloak特定的Valve。 接下来，您必须在WAR的WEB-INF目录中创建一个keycloak.json适配器配置文件。 该配置文件的格式在Java适配器配置中进行了描述 最后，您必须同时指定login-config并使用标准servlet安全性来指定URL上的角色基础约束。 这是一个例子： customer-portal Customers /* user BASIC this is ignored currently admin user 2.1.8. Jetty 9.x 适配器 Keycloak有一个单独的适配器，适用于Jetty 9.2.x，Jetty 9.3.x和Jetty 9.4.x，您必须安装到Jetty安装中。 然后，您必须在部署到Jetty的每个WAR中提供一些额外的配置。 我们来看看这些步骤。 适配器安装 适配器不再包含在设备或war分发版中。每个适配器在Keycloak下载站点上都是单独的下载。它们也可以作为maven构件使用。 您必须将Jetty 9.x发行版解压缩到Jetty 9.x的基本目录。 在WEB-INF/lib目录中包含适配器的jar将不起作用！ 在下面的例子中，Jetty基本名为your-base： $ cd your-base $ unzip keycloak-jetty93-adapter-dist-2.5.0.Final.zip 接下来，您必须为Jetty基础启用keycloak模块： $ java -jar $JETTY_HOME/start.jar --add-to-startd=keycloak 每个WAR配置必需 本节介绍如何通过在WAR包中添加配置和编辑文件来直接保护WAR。 您必须做的第一件事是在WAR包中创建一个WEB-INF/jetty-web.xml文件。 这是Jetty特定的配置文件，您必须在其中定义Keycloak特定的身份验证器。 接下来，您必须在WAR的WEB-INF目录中创建一个keycloak.json适配器配置文件。 该配置文件的格式在Java适配器配置 部分中进行了描述。 Jetty 9.x适配器将无法找到keycloak.json文件。 您必须在jetty-web.xml文件中定义所有适配器设置，如下所述。 您可以在jetty-web.xml中定义所有内容，而不是使用keycloak.json。 您只需要弄清楚json设置如何与org.keycloak.representations.adapters.config.AdapterConfig类匹配。 tomcat customer-portal http://localhost:8081/auth external secret password 您不必破解打开WAR以使用keycloak保护它。 而是使用yourwar.xml的名称在webapps目录中创建jetty-web.xml文件。 Jetty应该捡起来。 在此模式下，您必须直接在xml文件中声明keycloak.json配置。 最后，您必须同时指定login-config并使用标准servlet安全性来指定URL上的角色基础约束。 这是一个例子： customer-portal Customers /* user CONFIDENTIAL BASIC this is ignored currently admin user 2.1.9. Spring Security 适配器 要使用Spring Security和Keycloak保护应用程序，请将此适配器添加为项目的依赖项。 然后，您必须在Spring Security配置文件中提供一些额外的bean，并将Keycloak安全过滤器添加到管道中。 与其他Keycloak Adapters不同，您不应在web.xml中配置安全性。 但是，仍然需要keycloak.json。 适配器安装 添加Keycloak Spring Security适配器作为Maven POM或Gradle构建的依赖项。 org.keycloak keycloak-spring-security-adapter 6.0.1 Spring安全配置 Keycloak Spring Security适配器利用Spring Security灵活的安全配置语法。 Java配置 Keycloak提供了一个KeycloakWebSecurityConfigurerAdapter作为创建WebSecurityConfigurer实例。 该实现允许通过重写方法进行自定义。 虽然不需要使用它，但它极大地简化了安全上下文配置。 @KeycloakConfiguration public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter { /** * Registers the KeycloakAuthenticationProvider with the authentication manager. */ @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception { auth.authenticationProvider(keycloakAuthenticationProvider()); } /** * Defines the session authentication strategy. */ @Bean @Override protected SessionAuthenticationStrategy sessionAuthenticationStrategy() { return new RegisterSessionAuthenticationStrategy(new SessionRegistryImpl()); } @Override protected void configure(HttpSecurity http) throws Exception { super.configure(http); http .authorizeRequests() .antMatchers(\"/customers*\").hasRole(\"USER\") .antMatchers(\"/admin*\").hasRole(\"ADMIN\") .anyRequest().permitAll(); } } 您必须为公共或机密应用程序提供一个会话身份验证策略bean，其类型应为RegisterSessionAuthenticationStrategy，对于仅承载应用程序，您必须提供NullAuthenticatedSessionStrategy。 目前不支持Spring Security的SessionFixationProtectionStrategy，因为它在通过Keycloak登录后更改会话标识符。 如果会话标识符更改，则通用注销将不起作用，因为Keycloak不知道新的会话标识符。 @KeycloakConfiguration注释是一个元数据注释，它定义了在Spring Security中集成Keycloak所需的所有注释。 如果你有一个复杂的Spring Security设置，你可以简单地看一下@KeycloakConfiguration注释的注释，并创建你自己的自定义元注释，或者只是为Keycloak适配器使用特定的Spring注释。 XML配置 虽然Spring Security的XML命名空间简化了配置，但自定义配置可能有点冗长。 多租户 Keycloak Spring Security适配器还支持多租户。 而不是使用keycloak.json的路径注入AdapterDeploymentContextFactoryBean，您可以注入KeycloakConfigResolver接口的实现。 有关如何实现KeycloakConfigResolver的更多详细信息，请参见多租户。 命名安全角色 使用基于角色的身份验证时，Spring Security要求角色名称以ROLE_开头。 例如，必须在Keycloak中将管理员角色声明为ROLE_ADMIN或类似名称，而不仅仅是ADMIN。 类org.keycloak.adapters.springsecurity.authentication.KeycloakAuthenticationProvider支持可选的org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper，它可用于将来自Keycloak的角色映射到Spring Security认可的角色。 例如，使用org.springframework.security.core.authority.mapping.SimpleAuthorityMapper插入ROLE_前缀并将角色名称转换为大写。 该类是Spring Security Core模块的一部分。 客户端到客户端的支持 为了简化客户端之间的通信，Keycloak提供了Spring的RestTemplate的扩展，为您处理承载令牌认证。 要启用此功能，您的安全配置必须添加KeycloakRestTemplatebean。 请注意，它必须作为原型确定范围才能正常运行。 对于Java配置： @Configuration @EnableWebSecurity @ComponentScan(basePackageClasses = KeycloakSecurityComponents.class) public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter { ... @Autowired public KeycloakClientRequestFactory keycloakClientRequestFactory; @Bean @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public KeycloakRestTemplate keycloakRestTemplate() { return new KeycloakRestTemplate(keycloakClientRequestFactory); } ... } 对于XML配置： 然后，只要需要调用另一个客户端，您的应用程序代码就可以使用KeycloakRestTemplate。 例如： @Service public class RemoteProductService implements ProductService { @Autowired private KeycloakRestTemplate template; private String endpoint; @Override public List getProducts() { ResponseEntity response = template.getForEntity(endpoint, String[].class); return Arrays.asList(response.getBody()); } } Spring Boot集成 可以组合Spring Boot和Spring Security适配器。 如果您使用Keycloak Spring Boot Starter来使用Spring Security适配器，您只需添加Spring Security启动器： org.springframework.boot spring-boot-starter-security 使用Spring Boot配置 默认情况下，Spring Security Adapter会查找keycloak.json配置文件。 您可以通过添加此bean来确保它查看Spring Boot Adapter提供的配置： @Bean public KeycloakConfigResolver KeycloakConfigResolver() { return new KeycloakSpringBootConfigResolver(); } 避免Bean注册两次 Spring Boot尝试使用Web应用程序上下文急切地注册过滤器bean。 因此，在Spring Boot环境中运行Keycloak Spring Security适配器时，可能需要将FilterRegistrationBean添加到安全配置中，以防止Keycloak过滤器被注册两次。 Spring Boot 2.1默认情况下也会禁用spring.main.allow-bean-definition-overriding。 这可能意味着如果扩展KeycloakWebSecurityConfigurerAdapter的Configuration类注册了一个已被@ComponentScan检测到的bean，则会遇到BeanDefinitionOverrideException。 通过覆盖注册以使用特定于Boot的@ConditionalOnMissingBean注释可以避免这种情况，如下面的HttpSessionManager。 @Configuration @EnableWebSecurity public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter { ... @Bean public FilterRegistrationBean keycloakAuthenticationProcessingFilterRegistrationBean( KeycloakAuthenticationProcessingFilter filter) { FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter); registrationBean.setEnabled(false); return registrationBean; } @Bean public FilterRegistrationBean keycloakPreAuthActionsFilterRegistrationBean( KeycloakPreAuthActionsFilter filter) { FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter); registrationBean.setEnabled(false); return registrationBean; } @Bean public FilterRegistrationBean keycloakAuthenticatedActionsFilterBean( KeycloakAuthenticatedActionsFilter filter) { FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter); registrationBean.setEnabled(false); return registrationBean; } @Bean public FilterRegistrationBean keycloakSecurityContextRequestFilterBean( KeycloakSecurityContextRequestFilter filter) { FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter); registrationBean.setEnabled(false); return registrationBean; } @Bean @Override @ConditionalOnMissingBean(HttpSessionManager.class) protected HttpSessionManager httpSessionManager() { return new HttpSessionManager(); } ... } 2.1.10. Java Servlet Filter 适配器 如果要在没有Keycloak适配器的平台上部署Java Servlet应用程序，则选择使用servlet过滤器适配器。 此适配器的工作方式与其他适配器略有不同。 您没有在web.xml中定义安全性约束。 而是使用Keycloak servlet过滤器适配器定义过滤器映射，以保护要保护的URL模式。 Backchannel注销与标准适配器的工作方式略有不同。 它不会使HTTP会话无效，而是将会话ID标记为已注销。 没有标准方法可以根据会话ID使HTTP会话无效。 application Keycloak Filter org.keycloak.adapters.servlet.KeycloakOIDCFilter Keycloak Filter /keycloak/* /protected/* 在上面的代码片段中有两个url模式。 /protected/* 是我们想要保护的文件，而/keycloak/* url-pattern处理来自Keycloak服务器的回调。 如果需要在配置的url-patterns下面排除一些路径，可以使用Filter init-paramkeycloak.config.skipPattern来配置一个正则表达式，该表达式描述了keycloak过滤器应立即委托给的路径模式。 过滤链。 默认情况下，不配置skipPattern。 模式与requestURI匹配，没有context-path。 给定context-path /myapp，对/myapp/index.html的请求将与/index.html匹配跳过模式。 keycloak.config.skipPattern ^/(path1|path2|path3).* 请注意，您应该在Keycloak管理控制台中使用管理URL配置客户端，该URL指向过滤器的url-pattern所涵盖的安全部分。 管理员URL将对管理员URL进行回调，以执行backchannel注销等操作。 因此，此示例中的Admin URL应为http[s]://hostname/{context-root}/keycloak。 Keycloak过滤器具有与其他适配器相同的配置参数，除非您必须将它们定义为过滤器init参数而不是上下文参数。 要使用此过滤器，请在WAR poms中包含此maven工件： org.keycloak keycloak-servlet-filter-adapter 6.0.1 在OSGi上使用 servlet过滤器适配器打包为OSGi包，因此可以在具有HTTP服务和HTTP白板的通用OSGi环境（R6及更高版本）中使用。 安装 适配器及其依赖项作为Maven工件分发，因此您需要使用Internet连接来访问Maven Central，或者将工件缓存在本地Maven存储库中。 如果您使用的是Apache Karaf，则可以直接从Keycloak功能仓库安装一个功能： karaf@root()> feature:repo-add mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features karaf@root()> feature:install keycloak-servlet-filter-adapter 对于其他OSGi运行时，请参阅运行时文档，了解如何安装适配器包及其依赖项。 如果你的OSGi平台是带有Pax Web的Apache Karaf，你应该考虑使用JBoss Fuse 6或JBoss Fuse 7适配器。 配置 首先，需要使用OSGi HTTP服务将适配器注册为servlet过滤器。 最常见的方法是编程（例如通过bundle激活器）和声明（使用OSGi注释）。 我们建议使用后者，因为它简化了动态注册和取消注册过滤器的过程： package mypackage; import javax.servlet.Filter; import org.keycloak.adapters.servlet.KeycloakOIDCFilter; import org.osgi.service.component.annotations.Component; import org.osgi.service.http.whiteboard.HttpWhiteboardConstants; @Component( immediate = true, service = Filter.class, property = { KeycloakOIDCFilter.CONFIG_FILE_PARAM + \"=\" + \"keycloak.json\", HttpWhiteboardConstants.HTTP_WHITEBOARD_FILTER_PATTERN + \"=\" +\"/*\", HttpWhiteboardConstants.HTTP_WHITEBOARD_CONTEXT_SELECT + \"=\" + \"(osgi.http.whiteboard.context.name=mycontext)\" } ) public class KeycloakFilter extends KeycloakOIDCFilter { // } 上面的代码片段使用OSGi声明性服务规范将过滤器公开为javax.servlet.Filter类下的OSGI服务。 一旦在OSGi服务注册表中发布了类，它将由OSGi HTTP服务实现获取并用于过滤对指定servlet上下文的请求。 这将为每个匹配servlet上下文路径+过滤器路径的请求触发Keycloak适配器。 由于组件处于OSGi Configuration Admin Service的控制之下，因此可以动态配置其属性。 为此，要在OSGi运行时的标准配置位置下创建一个mypackage.KeycloakFilter.cfg文件： keycloak.config.file = /path/to/keycloak.json osgi.http.whiteboard.filter.pattern = /secure/* 或者使用交互式控制台，如果您的运行时允许： karaf@root()> config:edit mypackage.KeycloakFilter karaf@root()> config:property-set keycloak.config.file '${karaf.etc}/keycloak.json' karaf@root()> config:update 如果您需要更多控制权，例如 提供自定义KeycloakConfigResolver来实现多租户，您可以通过编程方式注册过滤器： public class Activator implements BundleActivator { private ServiceRegistration registration; public void start(BundleContext context) throws Exception { Hashtable props = new Hashtable(); props.put(HttpWhiteboardConstants.HTTP_WHITEBOARD_FILTER_PATTERN, \"/secure/*\"); props.put(KeycloakOIDCFilter.CONFIG_RESOLVER_PARAM, new MyConfigResolver()); this.registration = context.registerService(Filter.class.getName(), new KeycloakOIDCFilter(), props); } public void stop(BundleContext context) throws Exception { this.registration.unregister(); } } 有关程序化注册的更多信息，请参阅Apache Felix HTTP服务。 2.1.11. JAAS 插件 通常不需要在大多数应用程序中使用JAAS，特别是如果它们是基于HTTP的，并且您最有可能选择我们的其他适配器之一。 但是，某些应用程序和系统仍可能依赖纯粹的传统JAAS解决方案。 Keycloak提供了两个登录模块来帮助解决这些问题。 提供的登录模块是： org.keycloak.adapters.jaas.DirectAccessGrantsLoginModule 此登录模块允许使用Keycloak中的用户名/密码进行身份验证。 它使用资源所有者密码凭证流来验证提供的用户名/密码是否有效。 它对非基于Web的系统非常有用，它需要依赖JAAS并希望使用Keycloak，但由于其非Web性质而无法使用基于标准浏览器的流程。 此类应用程序的示例可以是消息传递或SSH。 org.keycloak.adapters.jaas.BearerTokenLoginModule 此登录模块允许通过CallbackHandler作为密码传递给它的Keycloak访问令牌进行身份验证。 例如，当您从基于标准的身份验证流程获得Keycloak访问令牌并且您的Web应用程序需要与依赖于JAAS的外部非基于Web的系统进行通信时，它可能很有用。 例如，消息传递系统。 两个模块都使用以下配置属性： keycloak-config-file keycloak.json配置文件的位置。 配置文件可以位于文件系统上，也可以位于类路径上。 如果它位于类路径上，则需要在该位置前加上classpath:（例如classpath:/path/keycloak.json）。 这是REQUIRED role-principal-class 为附加到JAAS Subject的Role主体配置备用类。 默认值为org.keycloak.adapters.jaas.RolePrincipal。 注意：该类需要具有带有单个String参数的构造函数。 scope 此选项仅适用于DirectAccessGrantsLoginModule。 指定的值将用作资源所有者密码凭据授予请求中的OAuth2 scope 参数。 2.1.12. CLI / Desktop 应用 Keycloak支持通过系统浏览器执行身份验证步骤，通过KeycloakInstalledadapter保护桌面（例如Swing，JavaFX）或CLI应用程序。 KeycloakInstalled适配器支持desktop和manual变体。 桌面版本使用系统浏览器来收集用户凭据。 手动变体从STDIN读取用户凭据。 提示：Google在OAuth2InstalledApp上提供了有关此方法的更多信息。 它是如何工作的 为了使用desktop变体对用户进行身份验证，KeycloakInstalled适配器打开一个桌面浏览器窗口，当在KeycloakInstalled对象上调用loginDesktop()方法时，用户使用常规的Keycloak登录页面进行登录。 使用redirect参数打开登录页面URL，该参数指向本地ServerSocket，该地址ServerSocket在由适配器启动的localhost上的空闲临时端口上进行侦听。 成功登录后，KeycloakInstalled从传入的HTTP请求接收授权代码并执行授权代码流。 一旦令牌交换的代码完成，ServerSocket就会关闭。 如果用户已经有一个活动的Keycloak会话，则不会显示登录表单，但会继续进行令牌交换的代码，这样可以实现基于Web的SSO平滑体验。 客户端最终会收到令牌（access_token，refresh_token，id_token），然后可以使用这些令牌来调用后端服务。 KeycloakInstalled适配器支持更新陈旧令牌。 适配器安装 org.keycloak keycloak-installed-adapter 6.0.1 客户端配置 应用程序需要配置为public OpenID Connect客户端，其中Standard Flow Enabled和 http://localhost:*作为允许的`Valid Redirect URI`。 用法 KeycloakInstalled适配器从类路径上的META-INF/keycloak.json读取它的配置。 可以通过KeycloakInstalledconstructor为InputStream或KeycloakDeployment提供自定义配置。 在下面的示例中，desktop-app的客户端配置使用以下keycloak.json： { \"realm\": \"desktop-app-auth\", \"auth-server-url\": \"http://localhost:8081/auth\", \"ssl-required\": \"external\", \"resource\": \"desktop-app\", \"public-client\": true, \"use-resource-role-mappings\": true } 下面的草图演示了如何使用KeycloakInstalled适配器： // reads the configuration from classpath: META-INF/keycloak.json KeycloakInstalled keycloak = new KeycloakInstalled(); // opens desktop browser keycloak.loginDesktop(); AccessToken token = keycloak.getToken(); // use token to send backend request // ensure token is valid for at least 30 seconds long minValidity = 30L; String tokenString = keycloak.getTokenString(minValidity, TimeUnit.SECONDS); // when you want to logout the user. keycloak.logout(); KeycloakInstalled类支持通过loginResponseWriter和logoutResponseWriter属性自定义登录/注销请求返回的http响应。 例子 以下提供了上述配置的示例。 import java.util.Locale; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import org.keycloak.adapters.installed.KeycloakInstalled; import org.keycloak.representations.AccessToken; public class DesktopApp { public static void main(String[] args) throws Exception { KeycloakInstalled keycloak = new KeycloakInstalled(); keycloak.setLocale(Locale.ENGLISH); keycloak.loginDesktop(); AccessToken token = keycloak.getToken(); Executors.newSingleThreadExecutor().submit(() -> { System.out.println(\"Logged in...\"); System.out.println(\"Token: \" + token.getSubject()); System.out.println(\"Username: \" + token.getPreferredUsername()); try { System.out.println(\"AccessToken: \" + keycloak.getTokenString()); } catch (Exception ex) { ex.printStackTrace(); } int timeoutSeconds = 20; System.out.printf(\"Logging out in...%d Seconds%n\", timeoutSeconds); try { TimeUnit.SECONDS.sleep(timeoutSeconds); } catch (Exception e) { e.printStackTrace(); } try { keycloak.logout(); } catch (Exception e) { e.printStackTrace(); } System.out.println(\"Exiting...\"); System.exit(0); }); } } 2.1.13. 安全上下文 如果您需要直接访问令牌，则可以使用KeycloakSecurityContext接口。 如果要从令牌中检索其他详细信息（例如用户配置文件信息），或者要调用受Keycloak保护的RESTful服务，这可能很有用。 在servlet环境中，它在安全调用中可用作HttpServletRequest中的属性： httpServletRequest .getAttribute(KeycloakSecurityContext.class.getName()); 或者，它在HttpSession中的不安全请求中可用： httpServletRequest.getSession() .getAttribute(KeycloakSecurityContext.class.getName()); 2.1.14. 错误处理 Keycloak为基于servlet的客户端适配器提供了一些错误处理功能。 在身份验证中遇到错误时，Keycloak将调用HttpServletResponse.sendError()。 您可以在web.xml文件中设置一个错误页面来处理您想要的错误。 Keycloak可能会丢失400,401,403和500错误。 403 /ErrorHandler Keycloak还设置了一个可以检索的HttpServletRequest属性。 属性名称是org.keycloak.adapters.spi.AuthenticationError，应该将其转换为org.keycloak.adapters.OIDCAuthenticationError。 例如： import org.keycloak.adapters.OIDCAuthenticationError; import org.keycloak.adapters.OIDCAuthenticationError.Reason; ... OIDCAuthenticationError error = (OIDCAuthenticationError) httpServletRequest .getAttribute('org.keycloak.adapters.spi.AuthenticationError'); Reason reason = error.getReason(); System.out.println(reason.name()); 2.1.15. 注销 您可以通过多种方式注销Web应用程序。 对于Java EE servlet容器，可以调用HttpServletRequest.logout()。 对于其他浏览器应用程序，您可以将浏览器重定向到http://auth-server/auth/realms/{realm-name}/protocol/openid-connect/logout?redirect_uri=encodedRedirectUri，如果您有与您的浏览器进行SSO会话。 当使用HttpServletRequest.logout()选项时，适配器对传递刷新令牌的Keycloak服务器执行反向通道POST调用。 如果该方法是从未受保护的页面（不检查有效令牌的页面）执行的，则刷新令牌可能不可用，在这种情况下，适配器会跳过该调用。 因此，建议使用受保护的页面来执行HttpServletRequest.logout()，以便始终考虑当前令牌，并在需要时执行与Keycloak服务器的交互。 如果您希望在注销过程中避免注销外部身份提供程序，则可以提供参数initiating_idp，其值为相关身份提供程序的标识（别名）。 当注销端点作为外部身份提供程序启动的单一注销的一部分进行调用时，这非常有用。 2.1.16. 参数转发 Keycloak初始授权端点请求支持各种参数。 大多数参数在OIDC规范中描述。 某些参数由适配器根据适配器配置自动添加。 但是，还可以在每次调用的基础上添加一些参数。 打开受保护的应用程序URI时，特定参数将转发到Keycloak授权端点。 例如，如果您请求脱机令牌，则可以使用scope参数打开受保护的应用程序URI，如： http://myappserver/mysecuredapp?scope=offline_access 并且参数scope = offline_access将自动转发到Keycloak授权端点。 支持的参数是： scope - 使用以空格分隔的范围列表。 以空格分隔的列表通常引用在特定客户端上定义的客户端范围。 请注意，范围openid将始终由适配器添加到作用域列表中。 例如，如果输入范围选项address phone，则对Keycloak的请求将包含范围参数scope=openid address phone。 prompt - Keycloak支持以下设置： login - 即使用户已经过身份验证，也会忽略SSO并始终显示Keycloak登录页面 consent - 仅适用于Consent Required(需要同意)的客户。 如果使用它，即使用户先前已同意此客户端，也将始终显示“同意”页面。 none - 登录页面永远不会显示; 相反，如果用户尚未通过身份验证，则会将用户重定向到应用程序，并显示错误。 此设置允许您在应用程序端创建过滤器/拦截器，并向用户显示自定义错误页面。 请参阅规范中的更多详细信息。 max_age - 仅在用户已经过身份验证时使用。 指定身份验证持续的最长允许时间（从用户进行身份验证时开始计算）。 如果用户的身份验证时间超过maxAge，则会忽略SSO并且必须重新进行身份验证。 login_hint - 用于预填充登录表单上的用户名/电子邮件字段。 kc_idp_hint - 用于告诉Keycloak跳过显示登录页面并自动重定向到指定的身份提供者。 身份提供商文档中的更多信息。 大多数参数在OIDC规范中描述。 唯一的例外是参数kc_idp_hint，它特定于Keycloak并包含要自动使用的身份提供者的名称。 有关更多信息，请参阅服务器管理指南中的Identity Brokering部分。 如果使用附加参数打开URL，则如果已在应用程序中进行了身份验证，则适配器不会将您重定向到Keycloak。 例如，如果您已经对应用程序mysecredapp进行了身份验证，则打开http://myappserver/mysecuredapp?prompt=login将不会自动将您重定向到Keycloak登录页面。 将来可能会更改此行为。 2.1.17. 客户端身份验证 当机密OIDC客户端需要发送反向信道请求（例如，交换令牌代码或刷新令牌）时，它需要针对Keycloak服务器进行身份验证。 默认情况下，有三种方法可以对客户端进行身份验证：客户端ID和客户端密钥，使用签名JWT的客户端身份验证，或使用客户端密钥的签名JWT进行客户端身份验证。 客户端ID和客户端Secret 这是OAuth2规范中描述的传统方法。 客户端有一个secret，需要知道适配器（应用程序）和Keycloak服务器。 您可以在Keycloak管理控制台中为特定客户端生成密码，然后将此密钥粘贴到应用程序端的keycloak.json文件中： \"credentials\": { \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\" } 使用签名JWT的客户端身份验证 这基于RFC7523规范。 它以这种方式工作： 客户端必须具有私钥和证书。 对于Keycloak，可以通过传统的keystore文件获得，该文件可以在客户端应用程序的类路径上或文件系统上的某个位置获得。 启动客户端应用程序后，它允许使用URL等JWKS格式下载其公钥。 作为http://myhost.com/myapp/k_jwks，假设http://myhost.com/myapp是客户端应用程序的基本URL。 Keycloak可以使用此URL（见下文）。 在身份验证期间，客户端生成JWT令牌并使用其私钥对其进行签名，并在client_assertion参数中的特定反向通道请求（例如，代码到令牌请求）中将其发送到Keycloak。 Keycloak必须具有客户端的公钥或证书，以便它可以验证JWT上的签名。 在Keycloak中，您需要为客户端配置客户端凭据。 首先，您需要选择Signed JWT作为在管理控制台的“凭据”选项卡中验证客户端的方法。 然后你可以选择： 配置JWKS URL，Keycloak可以在其中下载客户端的公钥。 这可以是诸如http://myhost.com/myapp/k_jwks之类的URL（参见上面的详细信息）。 此选项是最灵活的，因为客户端可以随时旋转其键，然后Keycloak总是在需要时下载新密钥而无需更改配置。 更准确地说，Keycloak在看到由未知的kid（密钥ID）签名的令牌时下载新密钥。 以PEM格式，JWK格式或从密钥库上载客户端的公钥或证书。 使用此选项，公钥是硬编码的，必须在客户端生成新密钥对时进行更改。 如果您没有自己的密钥库，您甚至可以从Keycloak管理控制台生成自己的密钥库。 有关如何设置Keycloak管理控制台的更多详细信息，请参阅服务器管理指南。 要在适配器端进行设置，您需要在keycloak.json文件中使用这样的内容： \"credentials\": { \"jwt\": { \"client-keystore-file\": \"classpath:keystore-client.jks\", \"client-keystore-type\": \"JKS\", \"client-keystore-password\": \"storepass\", \"client-key-password\": \"keypass\", \"client-key-alias\": \"clientkey\", \"token-expiration\": 10 } } 使用此配置，密钥库文件keystore-client.jks必须在WAR中的类路径上可用。 如果不使用前缀classpath:，则可以指向运行客户端应用程序的文件系统上的任何文件。 为了获得灵感，您可以查看示例分发到主要演示示例中的product-portal应用程序。 使用客户端密钥使用签名JWT进行客户端身份验证 这与使用签名JWT的客户端身份验证相同，除了使用客户端密钥而不是私钥和证书。 客户端有一个secret(秘密)，需要知道适配器（应用程序）和Keycloak服务器。 您需要选择Signed JWT with Client Secret作为在管理控制台的Credentials凭据选项卡中验证客户端的方法，然后将此secret(秘密)粘贴到应用程序端的keycloak.json文件中： \"credentials\": { \"secret-jwt\": { \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\" } } 添加自己的客户端身份验证方法 您也可以添加自己的客户端身份验证方法。 您将需要实现客户端和服务器端提供程序。 有关更多详细信息，请参阅服务器开发人员指南中的Authentication SPI部分。 2.1.18. 多租户 在我们的上下文中，多租户意味着可以使用多个Keycloak领域来保护单个目标应用程序（WAR）。 领域可以位于同一个Keycloak实例中，也可以位于不同的实例上。 实际上，这意味着应用程序需要有多个keycloak.json适配器配置文件。 您可以拥有多个WAR实例，并将不同的适配器配置文件部署到不同的上下文路径。 但是，这可能不方便，您可能还希望基于上下文之外的其他内容选择领域。 Keycloak可以使用自定义配置解析器，因此您可以选择每个请求使用的适配器配置。 要实现此目的，首先需要创建org.keycloak.adapters.KeycloakConfigResolver的实现。 例如： package example; import org.keycloak.adapters.KeycloakConfigResolver; import org.keycloak.adapters.KeycloakDeployment; import org.keycloak.adapters.KeycloakDeploymentBuilder; public class PathBasedKeycloakConfigResolver implements KeycloakConfigResolver { @Override public KeycloakDeployment resolve(OIDCHttpFacade.Request request) { if (path.startsWith(\"alternative\")) { KeycloakDeployment deployment = cache.get(realm); if (null == deployment) { InputStream is = getClass().getResourceAsStream(\"/tenant1-keycloak.json\"); return KeycloakDeploymentBuilder.build(is); } } else { InputStream is = getClass().getResourceAsStream(\"/default-keycloak.json\"); return KeycloakDeploymentBuilder.build(is); } } } 您还需要配置与web.xml中的keycloak.config.resolvercontext-param一起使用的KeycloakConfigResolver实现： ... keycloak.config.resolver example.PathBasedKeycloakConfigResolver 2.1.19. 应用程序集群 本章涉及支持部署到JBoss EAP，WildFly和JBoss AS的集群应用程序。 根据您的应用程序是否有以下几种选项： 无状态或有状态 可分发的(复制的http会话)或不可分发的 依赖负载均衡器提供的粘性会话 与Keycloak在同一个域名中托管 处理群集并不像普通应用程序那么简单。 主要是因为浏览器和服务器端应用程序都向Keycloak发送请求，因此它不像在负载均衡器上启用粘性会话那么简单。 无状态令牌存储 默认情况下，Keycloak保护的Web应用程序使用HTTP会话来存储安全上下文。 这意味着您必须启用粘性会话或复制HTTP会话。 作为在HTTP会话中存储安全上下文的替代方法，可以将适配器配置为将其存储在cookie中。 如果要使应用程序无状态或者您不希望在HTTP会话中存储安全上下文，这将非常有用。 要使用cookie存储来保存安全上下文，请编辑应用程序WEB-INF/keycloak.json并添加： \"token-store\": \"cookie\" token-store的默认值是session，它将安全上下文存储在HTTP会话中。 使用cookie存储的一个限制是整个安全上下文在cookie中传递给每个HTTP请求。 这可能会影响性能。 另一个小限制是对单点登出的有限支持。 如果您从应用程序本身初始化servlet注销（HttpServletRequest.logout），它将正常工作，因为适配器将删除KEYCLOAK_ADAPTER_STATE cookie。 但是，Keycloak不会将从其他应用程序初始化的反向通道注销传播到使用cookie存储的应用程序。 因此，建议对访问令牌超时使用短值（例如1分钟）。 某些负载均衡器不允许任何配置粘性会话cookie名称或内容，例如Amazon ALB。 对于这些，建议将shouldAttachRoute选项设置为false。 相对URI优化 在Keycloak和应用程序托管在同一域（通过反向代理或负载平衡器）的部署方案中，在客户端配置中使用相对URI选项会很方便。 使用相对URI，URI将相对于用于访问Keycloak的URL进行解析。 例如，如果您的应用程序的URL是https://acme.org/myapp，而Keycloak的URL是https://acme.org/auth，那么您可以使用redirect-uri /myapp 而不是 https://acme.org/myapp。 管理员URL配置 可以在Keycloak管理控制台中配置特定客户端的管理URL。 它由Keycloak服务器用于向应用程序发送后端请求以执行各种任务，例如注销用户或推送撤销策略。 例如，反向通道注销的工作方式是： 用户从一个应用程序发送注销请求 应用程序向Keycloak发送注销请求 Keycloak服务器使用户会话无效 然后，Keycloak服务器向应用程序发送反向通道请求，其中包含与会话关联的管理URL 当应用程序收到注销请求时，它会使相应的HTTP会话无效 如果admin URL包含 ${application.session.host} ，它将被替换为与HTTP会话关联的节点的URL。 注册应用程序节点 上一节描述了Keycloak如何向与特定HTTP会话关联的节点发送注销请求。 但是，在某些情况下，管理员可能希望将管理任务传播到所有已注册的群集节点，而不仅仅是其中一个。 例如，将新的not before策略推送到应用程序或从应用程序注销所有用户。 在这种情况下，Keycloak需要知道所有应用程序集群节点，因此它可以将事件发送给所有这些节点。 为此，我们支持自动发现机制： 当新的应用程序节点加入群集时，它会向Keycloak服务器发送注册请求 该请求可以以配置的周期性间隔重新发送到Keycloak 如果Keycloak服务器在指定的超时内未收到重新注册请求，则它会自动取消注册特定节点 当Keycloak发送取消注册请求时，该节点也会在Keycloak中取消注册，这通常是在节点关闭或应用程序取消部署期间。 当未调用未部署侦听器时，这可能无法正常执行强制关闭，这导致需要自动取消注册 默认情况下禁用发送启动注册和定期重新注册，因为只有某些群集应用程序才需要它。 要启用该功能，请编辑应用程序的WEB-INF/keycloak.json文件并添加： \"register-node-at-startup\": true, \"register-node-period\": 600, 这意味着适配器将在启动时发送注册请求，并每10分钟重新注册一次。 在Keycloak管理控制台中，您可以指定最大节点重新注册超时（应该大于适配器配置中的register-node-period）。 您还可以通过管理控制台手动添加和删除群集节点，如果您不想依赖自动注册功能，或者如果您想要在不使用自动注销功能的情况下删除陈旧的应用程序节点，这将非常有用。 刷新每个请求中的令牌 默认情况下，应用程序适配器仅在访问令牌过期时刷新。 但是，您还可以配置适配器以在每个请求上刷新令牌。 这可能会对性能产生影响，因为您的应用程序将向Keycloak服务器发送更多请求。 要启用该功能，请编辑应用程序的WEB-INF/keycloak.json文件并添加： \"always-refresh-token\": true 这可能会对性能产生重大影响。 如果您不能依赖反向通道消息传播注销而不是策略之前，则仅启用此功能。 另一件需要考虑的事情是，默认情况下，访问令牌的到期时间很短，因此即使未传播注销，令牌也会在注销后的几分钟内到期。 2.2. JavaScript 适配器 Keycloak附带了一个客户端JavaScript库，可以用来保护HTML5/JavaScript应用程序。JavaScript适配器内置了对Cordova应用程序的支持。 该库可以直接从Keycloak服务器检索到/auth/js/keycloak.js，也可以作为ZIP存档分发。 最佳做法是直接从Keycloak Server加载JavaScript适配器，因为它会在升级服务器时自动更新。 如果将适配器复制到Web应用程序，请确保仅在升级服务器后升级适配器。 关于使用客户端应用程序的一个重要注意事项是客户端必须是公共客户端，因为没有安全的方法来在客户端应用程序中存储客户端凭据。 这使得确保为客户端配置的重定向URI正确且尽可能具体非常重要。 要使用JavaScript适配器，必须首先在Keycloak管理控制台中为您的应用程序创建客户端。 确保为Access Type选择public。 您还需要配置有效的重定向URI和有效的Web源。 尽可能具体，因为未能这样做可能会导致安全漏洞。 创建客户端后，单击Installation(安装)选项卡，选择Format Option(格式选项)的Keycloak OIDC JSON，然后单击Download(下载)。 下载的keycloak.json文件应该存放在您的Web服务器上与HTML页面相同的位置。 或者，您可以跳过配置文件并手动配置适配器。 以下示例显示如何初始化JavaScript适配器： var keycloak = Keycloak(); keycloak.init().success(function(authenticated) { alert(authenticated ? 'authenticated' : 'not authenticated'); }).error(function() { alert('failed to initialize'); }); 如果keycloak.json文件位于不同的位置，您可以指定它： var keycloak = Keycloak('http://localhost:8080/myapp/keycloak.json'); 或者，您可以使用所需的配置传入JavaScript对象： var keycloak = Keycloak({ url: 'http://keycloak-server/auth', realm: 'myrealm', clientId: 'myapp' }); 默认情况下，您需要调用login函数进行身份验证。 但是，有两个选项可用于使适配器自动进行身份验证。 您可以将login-required或check-sso传递给init函数。 如果用户登录到Keycloak，则login-required将对客户端进行身份验证，否则将显示登录页面。 check-sso将仅在用户已登录时验证客户端，如果用户未登录，则浏览器将被重定向回应用程序并保持未经身份验证。 要启用login-required，请将onLoad设置为login-required并传递给init方法： keycloak.init({ onLoad: 'login-required' }) 在对用户进行身份验证之后，应用程序可以通过在Authorization标头中包含承载令牌来向Keycloak保护对RESTful服务的请求。 例如： var loadData = function () { document.getElementById('username').innerText = keycloak.subject; var url = 'http://localhost:8080/restful-service'; var req = new XMLHttpRequest(); req.open('GET', url, true); req.setRequestHeader('Accept', 'application/json'); req.setRequestHeader('Authorization', 'Bearer ' + keycloak.token); req.onreadystatechange = function () { if (req.readyState == 4) { if (req.status == 200) { alert('Success'); } else if (req.status == 403) { alert('Forbidden'); } } } req.send(); }; 需要记住的一件事是，默认情况下，访问令牌的生命周期很短，因此您可能需要在发送请求之前刷新访问令牌。 您可以通过updateToken方法执行此操作。 updateToken方法返回一个promise对象，只有在成功刷新令牌时才能轻松调用服务，例如，如果不是，则向用户显示错误。 例如： keycloak.updateToken(30).success(function() { loadData(); }).error(function() { alert('Failed to refresh token'); }); 2.2.1. 会话状态iframe 默认情况下，JavaScript适配器会创建一个隐藏的iframe，用于检测是否已发生单一注销。 这不需要任何网络流量，而是通过查看特殊状态cookie来检索状态。 可以通过在传递给init方法的选项中设置checkLoginIframe:false来禁用此功能。 你不应该直接看这个cookie。 它的格式可以更改，它也与Keycloak服务器的URL相关联，而不是与您的应用程序相关联。 2.2.2. 隐式和混合流 默认情况下，JavaScript适配器使用授权代码 流程。 通过此流程，Keycloak服务器向应用程序返回授权代码，而不是身份验证令牌。 在将浏览器重定向回应用程序后，JavaScript适配器会交换访问令牌和刷新令牌的code。 Keycloak还支持Implicit 流程，其中在使用Keycloak成功进行身份验证后立即发送访问令牌。 这可能比标准流具有更好的性能，因为没有额外的请求来交换令牌的代码，但是当访问令牌到期时它会产生影响。 但是，在URL片段中发送访问令牌可能是一个安全漏洞。 例如，令牌可以通过Web服务器日志和/或浏览器历史记录泄露。 要启用隐式流，您需要在Keycloak管理控制台中为客户端启用Implicit Flow Enabled标志。 您还需要将值为implicit的参数flow传递给init方法： keycloak.init({ flow: 'implicit' }) 需要注意的一点是，只提供了访问令牌，并且没有刷新令牌。 这意味着一旦访问令牌到期，应用程序必须再次重定向到Keycloak以获取新的访问令牌。 Keycloak还支持Hybrid 流程。 这要求客户端在管理控制台中启用Standard Flow Enabled和Implicit Flow Enabled标志。 然后Keycloak服务器将代码和令牌发送到您的应用程序。 可以立即使用访问令牌，同时可以交换代码以访问和刷新令牌。 与隐式流类似，混合流有利于提高性能，因为访问令牌可立即使用。 但是，令牌仍然在URL中发送，前面提到的安全漏洞可能仍然适用。 混合流程的一个优点是刷新令牌可供应用程序使用。 对于Hybrid流，您需要将值为hybrid的参数flow传递给init方法： keycloak.init({ flow: 'hybrid' }) 2.2.3. 与Cordova的混合应用程序 Keycloak支持使用Apache Cordova开发的混合移动应用程序。 Javascript适配器有两种模式：cordova和cordova-native： 默认值为cordova，如果未配置适配器类型且window.cordova存在，则适配器将自动选择。 登录时，它将打开InApp浏览器，让用户与Keycloak交互，然后返回到app通过重定向到http://localhost。 因此，您必须将此URL列入白名单，作为管理控制台的客户端配置部分中的有效redirect-uri。 虽然这种模式易于设置，但它也有一些缺点：InApp-Browser是嵌入在应用程序中的浏览器，不是手机的默认浏览器。 因此，它将具有不同的设置，并且存储的凭据将不可用. InApp-Browser可能也会更慢，尤其是在渲染更复杂的主题时。 * 在使用此模式之前，需要考虑安全问题，例如应用程序可以访问用户的凭据，因为它可以完全控制浏览器呈现登录页面，因此不要允许 在您不信任的应用中使用。 使用此示例应用程序可帮助您入门：https://github.com/keycloak/keycloak/tree/master/examples/cordova 替代模式cordova-nativei采用不同的方法。 它使用系统的浏览器打开登录页面。 用户通过身份验证后，浏览器会使用特殊URL重定向回应用程序。 从那里，Keycloak适配器可以通过从URL读取代码或令牌来完成登录。 您可以通过将适配器类型cordova-native传递给init方法来激活本机模式： keycloak.init({ adapter: 'cordova-native' }) 此适配器需要两个额外的插件： cordova-plugin-browsertab: 允许该应用在系统浏览器中打开网页 cordova-plugin-deeplinks: 允许浏览器通过特殊网址重定向回您的应用 链接到应用程序的技术细节在每个平台上都有所不同，需要进行特殊设置。 有关详细说明，请参阅deeplinks插件文档的Android和iOS部分。 打开应用程序有不同类型的链接:自定义方案(即myapp://login或android-app://com.example.myapp/https/example.com/login)和Universal Links(iOS) ))/ Deep Links(Android). 虽然前者更容易设置并且更容易工作,但后者提供了额外的安全性,因为它们是唯一的,只有域的所有者才能注册它们. iOS上不推荐使用自定义网址. 我们建议您使用通用链接,并在其上附带自定义网址链接的备用网站,以获得最佳可靠性. 此外，我们建议采用以下步骤来改善与Keycloak适配器的兼容性： 当response-mode设置为query时，iOS上的Universal Links似乎更可靠 为防止Android在重定向上打开您的应用的新实例，请将以下代码段添加到config.xml： 有一个示例应用程序，显示如何使用本机模式：https://github.com/keycloak/keycloak/tree/master/examples/cordova-native 2.2.4. 早期的浏览器 JavaScript适配器依赖于Base64（window.btoa和window.atob），HTML5 History API和可选的Promise API。 如果您需要支持那些没有这些的浏览器（例如，IE9），则需要添加polyfillers。 示例polyfill库： Base64 - https://github.com/davidchambers/Base64.js HTML5 History - https://github.com/devote/HTML5-History-API Promise - https://github.com/stefanpenner/es6-promise 2.2.5. JavaScript适配器参考 构造函数 new Keycloak(); new Keycloak('http://localhost/keycloak.json'); new Keycloak({ url: 'http://localhost/auth', realm: 'myrealm', clientId: 'myApp' }); 属性 authenticated 如果用户通过身份验证，则为true，否则为false。 token base64编码的令牌，可以在对服务的请求中的Authorization头中发送。 tokenParsed 解析后的令牌作为JavaScript对象。 subject 用户ID。 idToken base64编码的ID令牌。 idTokenParsed 解析的id令牌作为JavaScript对象。 realmAccess 与令牌关联的域角色。 resourceAccess 与令牌关联的资源角色。 refreshToken base64编码的刷新令牌，可用于检索新令牌。 refreshTokenParsed 解析后的刷新令牌作为JavaScript对象。 timeSkew 浏览器时间与Keycloak服务器之间的估计时间差，以秒为单位。 此值只是一个估计值，但在确定令牌是否已过期时足够准确。 responseMode 在init中传递的响应模式（默认值为fragment）。 flow 流程在init中传递。 adapter 允许您覆盖重定向的方式以及库处理其他与浏览器相关的函数。 可用选项：“default(默认)” - 库使用浏览器api进行重定向（这是默认设置）“cordova” - 库将尝试使用InAppBrowser cordova插件加载keycloak登录/注册页面（这在库时自动使用） 正在使用Cordova生态系统）“cordova-native” - 图书馆尝试使用BrowserTabs cordova插件使用手机的系统浏览器打开登录和注册页面。 这需要额外设置以重定向回应用程序(请参阅使用Cordova的混合应用程序).custom - 允许您实现自定义适配器（仅适用于高级用例） responseType 响应类型通过登录请求发送到Keycloak。 这是根据初始化期间使用的流量值确定的，但可以通过设置此值来覆盖。 方法 init（选项） 调用初始化适配器。 选项是一个对象，其中： onLoad - 指定要在加载时执行的操作。 支持的值为login-required或check-sso。 token - 设置令牌的初始值。 refreshToken - 设置刷新令牌的初始值。 idToken - 设置id令牌的初始值（仅与token或refreshToken一起）。 timeSkew - 在几秒钟内设置本地时间和Keycloak服务器之间的偏差初始值（仅与token或refreshToken一起）。 checkLoginIframe - 设置为启用/禁用监控登录状态（默认为true）。 checkLoginIframeInterval - 设置检查登录状态的时间间隔（默认为5秒）。 responseMode - 将OpenID Connect响应模式设置为在登录请求时发送到Keycloak服务器。 有效值是查询或片段。 默认值为fragment，这意味着在成功进行身份验证后，Keycloak将重定向到javascript应用程序，并在URL片段中添加OpenID Connect参数。 这通常比查询更安全和推荐。 flow - 设置OpenID Connect流程。 有效值是standard(标准值)，implicit (隐式值)或hybrid(混合值)。 promiseType - 如果设置为native，则返回promise的所有方法都将返回本机JavaScript promise。 如果未设置，将返回Keycloak特定的promise对象。 返回promise设置在成功或错误时调用的函数。 login(选项) 重定向到登录表单（选项是带有redirectUri和/或提示字段的可选对象）。 选项是一个对象，其中： redirectUri - 指定登录后要重定向到的URI。 prompt - 此参数允许稍微自定义Keycloak服务器端的登录流程。 例如，在值为login的情况下强制显示登录屏幕。 有关prompt参数的详细信息和所有可能值，请参见参数转发部分 。 maxAge - 仅在用户已经过身份验证时使用。 指定自用户身份验证以来的最长时间。 如果用户的身份验证时间比maxAge长，则会忽略SSO，并且需要重新进行身份验证。 loginHint - 用于预填充登录表单上的用户名/电子邮件字段。 scope - 用于将scope参数转发到Keycloak登录端点。 使用以空格分隔的范围列表。 这些通常引用在特定客户端上定义的客户端范围。 请注意，范围openid将始终由适配器添加到作用域列表中。 例如，如果输入范围选项address phone，则对Keycloak的请求将包含范围参数scope=openid address phone。 idpHint - 用于告诉Keycloak跳过显示登录页面并自动重定向到指定的身份提供者。 [身份提供商文档]中的更多信息(https://www.keycloak.org/docs/6.0/server_admin/#_client_suggested_idp)。 action - 如果值为'register'，则将用户重定向到注册页面，否则重定向到登录页面。 locale - 根据OIDC 1.0规范的3.1.2.1节设置'ui_locales'查询参数。 kcLocale - 为UI指定所需的Keycloak语言环境。 这与locale param的不同之处在于它告诉Keycloak服务器设置cookie并将用户的配置文件更新为新的首选语言环境。 cordovaOptions - 指定传递给Cordova应用程序内浏览器的参数（如果适用）。 选项hidden和location不受这些参数的影响。 所有可用选项均在https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/中定义。 使用示例：{ zoom: \"no\", hardwareback: \"yes\" }; createLoginUrl(选项) 返回登录表单的URL（选项是带有redirectUri和/或提示字段的可选对象）。 Options是一个Object，它支持相同的选项，如函数login。 logout(选项) 重定向到注销。 选项是一个对象，其中： redirectUri - 指定注销后要重定向到的URI。 createLogoutUrl(选项) 返回用于注销用户的URL。 选项是一个对象，其中： redirectUri - 指定注销后要重定向到的URI。 register(选项) 重定向到注册表单。 使用选项 action = 'register'登录的快捷方式 选项与登录方法相同，但'action'设置为'register' createRegisterUrl(选项) 返回注册页面的url。 带有选项action = 'register'的createLoginUrl的快捷方式 选项与createLoginUrl方法相同，但'action'设置为'register' accountManagement() 重定向到帐户管理控制台。 createAccountUrl() 返回帐户管理控制台的URL。 hasRealmRole(role) 如果令牌具有给定的域角色，则返回true。 hasResourceRole(role, resource) 如果令牌具有资源的给定角色，则返回true（如果未使用指定的clientId，则资源是可选的）。 loadUserProfile() 加载用户个人资料。 如果成功加载配置文件，或者无法加载配置文件，则返回promise设置要调用的函数。 例如： keycloak.loadUserProfile().success(function(profile) { alert(JSON.stringify(profile, null, \" \")); }).error(function() { alert('Failed to load user profile'); }); isTokenExpired(minValidity) 如果令牌在到期之前的剩余时间小于minValidity秒，则返回true（minValidity是可选的，如果未指定0则使用）。 updateToken(minValidity) 如果令牌在minValidity秒内到期（minValidity是可选的，如果未指定5，则使用）令牌将被刷新。 如果启用了会话状态iframe，则还会检查会话状态。 如果令牌仍然有效，或者令牌不再有效，则返回承诺设置可以调用的函数。 例如： keycloak.updateToken(5).success(function(refreshed) { if (refreshed) { alert('Token was successfully refreshed'); } else { alert('Token is still valid'); } }).error(function() { alert('Failed to refresh the token, or the session has expired'); }); clearToken() 清除身份验证状态，包括令牌。 如果应用程序检测到会话已过期，例如更新令牌失败，则此功能非常有用。 调用此结果会导致调用onAuthLogout回调侦听器。 Callback Events 适配器支持为某些事件设置回调侦听器。 例如： keycloak.onAuthSuccess = function() { alert('authenticated'); } 可用的事件是： onReady(authenticated) - 初始化适配器时调用。 onAuthSuccess - 在成功验证用户时调用。 onAuthError - 如果在身份验证期间出错，则调用。 onAuthRefreshSuccess - 刷新令牌时调用。 onAuthRefreshError - 如果在尝试刷新令牌时出现错误，则调用此方法。 onAuthLogout - 如果用户已注销，则调用（仅在启用会话状态iframe时或在Cordova模式下调用）。 onTokenExpired - 访问令牌过期时调用。 如果刷新令牌可用，则可以使用updateToken刷新令牌，或者在不使用updateToken的情况下（即使用implicit flow），您可以重定向到登录屏幕以获取新的访问令牌。 2.3. Node.js 适配器 Keycloak提供了一个构建在Connect之上的Node.js适配器，以保护服务器端JavaScript应用程序 - 目标是足够灵活，可以与Express.js等框架集成。 该库可以直接从Keycloak组织下载，源代码可以在GitHub上获得。 要使用Node.js适配器，首先必须在Keycloak管理控制台中为应用程序创建客户端。 适配器支持公共，机密和仅承载访问类型。 选择哪一个取决于用例场景。 创建客户端后，单击Installation选项卡，为Format Option选择Keycloak OIDC JSON，然后单击Download。 下载的keycloak.json文件应该位于项目的根文件夹中。 2.3.1. 安装 假设您已经安装了Node.js，请为您的应用程序创建一个文件夹： mkdir myapp && cd myapp 使用npm init命令为您的应用程序创建package.json。 现在在依赖项列表中添加Keycloak连接适配器： \"dependencies\": { \"keycloak-connect\": \"6.0.1\" } 2.3.2. 用法 实例化Keycloak类 Keycloak类提供了与应用程序配置和集成的中心点。 最简单的创建不涉及任何参数。 var session = require('express-session'); var Keycloak = require('keycloak-connect'); var memoryStore = new session.MemoryStore(); var keycloak = new Keycloak({ store: memoryStore }); 默认情况下，这将在应用程序的主要可执行文件旁边找到名为keycloak.json的文件，以初始化特定于keycloak的设置（公钥，域名，各种URL）。 keycloak.json文件是从Keycloak管理控制台获得的。 使用此方法进行实例化会导致使用所有合理的默认值。 作为替代方案，也可以提供配置对象，而不是keycloak.json文件： let kcConfig = { clientId: 'myclient', bearerOnly: true, serverUrl: 'http://localhost:8080/auth', realm: 'myrealm', realmPublicKey: 'MIIBIjANB...' }; let keycloak = new Keycloak({ store: memoryStore }, kcConfig); 应用程序还可以使用以下方法将用户重定向到其首选身份提供程 let keycloak = new Keycloak({ store: memoryStore, idpHint: myIdP }, kcConfig); 配置Web会话存储 如果要使用Web会话来管理服务器端状态以进行身份验证，则需要使用至少一个store参数初始化Keycloak(...)，传入express-session正在使用的实际会话存储。 var session = require('express-session'); var memoryStore = new session.MemoryStore(); var keycloak = new Keycloak({ store: memoryStore }); 传递自定义范围值 默认情况下，范围值openid作为查询参数传递给Keycloak的登录URL，但您可以添加其他自定义值： var keycloak = new Keycloak({ scope: 'offline_access' }); 2.3.3. 安装中间件 实例化后，将中间件安装到支持connect的应用程序中： var app = express(); app.use( keycloak.middleware() ); 2.3.4. 检查身份验证 要在访问资源之前检查用户是否已通过身份验证，只需使用keycloak.checkSso()。 它只会在用户已登录时进行身份验证。 如果用户未登录，浏览器将重定向回原始请求的URL并保持未经身份验证： app.get( '/check-sso', keycloak.checkSso(), checkSsoHandler ); 2.3.5. 保护资源 简单认证 要强制在访问资源之前必须对用户进行身份验证，只需使用keycloak.protect()的无参数版本： app.get( '/complain', keycloak.protect(), complaintHandler ); 基于角色的授权 要保护具有当前应用程序的应用程序角色的资源： app.get( '/special', keycloak.protect('special'), specialHandler ); 要保护具有不同应用程序的应用程序角色的资源： app.get( '/extra-special', keycloak.protect('other-app:special'), extraSpecialHandler ); 要保护具有领域角色的资源： app.get( '/admin', keycloak.protect( 'realm:admin' ), adminHandler ); 高级授权 为了保护基于URL本身部分的资源，假设每个部分都存在一个角色： function protectBySection(token, request) { return token.hasRole( request.params.section ); } app.get( '/:section/:page', keycloak.protect( protectBySection ), sectionHandler ); 2.3.6. 其他URLs 显式用户触发的注销 默认情况下，中间件捕获对/logout的调用，以通过以Keycloak为中心的注销工作流发送用户。 这可以通过为middleware()调用指定logout配置参数来改变： app.use( keycloak.middleware( { logout: '/logoff' } )); Keycloak Admin Callbacks 此外，中间件支持来自Keycloak控制台的回调，以注销单个会话或所有会话。 默认情况下，这些类型的管理回调相对于/的根URL发生，但可以通过向middleware()调用提供admin参数来更改： app.use( keycloak.middleware( { admin: '/callbacks' } ); 2.4. Keycloak 看门人 Keycloak提供了一个Go编程语言适配器，用于OpenID Connect（OIDC），它支持浏览器cookie或承载令牌中的访问令牌。 本文档详细介绍了如何构建和配置keycloak-gatekeeper，以及如何使用其每个功能的详细信息。 有关详细信息，请参阅随附的帮助文件，其中包含命令和开关的完整列表。 通过在命令行输入以下内容来查看文件（修改位置以匹配安装keycloak-gatekeeper的位置）： $ bin/keycloak-gatekeeper help 2.4.1. 构建 先决条件 Golang 必须安装. Make 必须安装. 过程 运行make dep-install来安装所有需要的依赖项。 运行make test来运行包含的测试。 运行make来构建项目。 如果您希望构建一个包含所有必需依赖项的二进制文件，则可以使用make static。 您还可以通过docker容器构建：make docker-build。 Docker镜像可在https://hub.docker.com/r/keycloak/keycloak-gatekeeper/上找到。 2.4.2. 配置选项 配置可以来自yaml/json文件或使用命令行选项。 这是一个选项列表。 # is the url for retrieve the OpenID configuration - normally the /auth/realm/ discovery-url: https://keycloak.example.com/auth/realms/ # the client id for the 'client' application client-id: # the secret associated to the 'client' application client-secret: # the interface definition you wish the proxy to listen, all interfaces is specified as ':', unix sockets as unix://| listen: 127.0.0.1:3000 # whether to enable refresh tokens enable-refresh-tokens: true # the location of a certificate you wish the proxy to use for TLS support tls-cert: # the location of a private key for TLS tls-private-key: # the redirection url, essentially the site url, note: /oauth/callback is added at the end redirection-url: http://127.0.0.1:3000 # the encryption key used to encode the session state encryption-key: # the upstream endpoint which we should proxy request upstream-url: http://127.0.0.1:80 # additional scopes to add to add to the default (openid+email+profile) scopes: - vpn-user # a collection of resource i.e. urls that you wish to protect resources: - uri: /admin/test # the methods on this url that should be protected, if missing, we assuming all methods: - GET # a list of roles the user must have in order to access urls under the above # If all you want is authentication ONLY, simply remove the roles array - the user must be authenticated but # no roles are required roles: - openvpn:vpn-user - openvpn:prod-vpn - test - uri: /admin/* methods: - GET roles: - openvpn:vpn-user - openvpn:commons-prod-vpn 在命令行发出的选项具有更高的优先级，并将覆盖或合并配置文件中引用的选项。 这里显示了每种样式的示例。 2.4.3. 示例用法和配置 假设您有一些Web服务，您希望受到Keycloak的保护： 使用Keycloak GUI或CLI创建客户端; 客户端协议是'openid-connect'，访问类型：confidential。 添加http://127.0.0.1:3000/oauth/callback的有效重定向URI。 抓住客户端ID和客户端密钥。 在客户端或现有客户端下创建各种角色以进行授权。 这是一个示例配置文件。 client-id: client-secret: # require for access_type: confidential # Note the redirection-url is optional, it will default to the X-Forwarded-Proto / X-Forwarded-Host r the URL scheme and host not found discovery-url: https://keycloak.example.com/auth/realms/ enable-default-deny: true encryption_key: AgXa7xRcoClDEU0ZDSH4X0XhL5Qy2Z2j listen: 127.0.0.1:3000 redirection-url: http://127.0.0.1:3000 upstream-url: http://127.0.0.1:80 resources: - uri: /admin* methods: - GET roles: - client:test1 - client:test2 require-any-role: true groups: - admins - users - uri: /backend* roles: - client:test1 - uri: /public/* white-listed: true - uri: /favicon white-listed: true - uri: /css/* white-listed: true - uri: /img/* white-listed: true headers: myheader1: value_1 myheader2: value_2 也可以使用命令行选项配置配置文件中定义的任何内容，例如在此示例中。 bin/keycloak-gatekeeper \\ --discovery-url=https://keycloak.example.com/auth/realms/ \\ --client-id= \\ --client-secret= \\ --listen=127.0.0.1:3000 \\ # unix sockets format unix://path --redirection-url=http://127.0.0.1:3000 \\ --enable-refresh-tokens=true \\ --encryption-key=AgXa7xRcoClDEU0ZDSH4X0XhL5Qy2Z2j \\ --upstream-url=http://127.0.0.1:80 \\ --enable-default-deny=true \\ --resources=\"uri=/admin*|roles=test1,test2\" \\ --resources=\"uri=/backend*|roles=test1\" \\ --resources=\"uri=/css/*|white-listed=true\" \\ --resources=\"uri=/img/*|white-listed=true\" \\ --resources=\"uri=/public/*|white-listed=true\" \\ --headers=\"myheader1=value1\" \\ --headers=\"myheader2=value2\" 默认情况下，资源上定义的角色执行逻辑AND，因此指定的所有角色必须存在于声明中，但是，这种行为可以通过require-any-role选项进行更改，因此只要一个角色是 目前授予许可。 2.4.4. OpenID提供商通信 默认情况下，与OpenID提供程序的通信是直接的。 如果您愿意，可以在配置文件中指定转发代理服务器： openid-provider-proxy: http://proxy.example.com:8080 2.4.5. HTTP路由 默认情况下，所有请求都将代理到上游，如果您希望确保所有请求都是身份验证，您可以使用此命令： --resource=uri=/* # note, unless specified the method is assumed to be 'any|ANY' HTTP路由规则遵循chi的指导原则。 资源的排序无关紧要，路由器将为您处理。 2.4.6. 仅限会话的cookie 默认情况下，访问和刷新cookie仅限会话，并在浏览器关闭时处理; 您可以使用--enable-session-cookies选项禁用此功能。 2.4.7. 转发签名代理 转发签名提供了一种使用IdP发出的令牌在服务之间进行身份验证和授权的机制。 在此模式下运行时，代理将自动获取访问令牌（代表您处理刷新或登录）并使用Authorization标头标记出站请求。 您可以使用--forwarding-domains选项控制标记哪些域。 注意，此选项在域上使用contains比较。 因此，如果您想匹配*.svc.cluster.local下的所有域，您可以使用： - forwarding-domain=svc.cluster.local。 目前，该服务使用oauth client_credentials授权类型执行登录，因此您的IdP服务必须支持直接（用户名/密码）登录。 示例设置： 您收集了允许彼此交谈的微服务; 您已经在Keycloak中设置了凭据，角色和客户端，为问题令牌提供了精细的角色控制。 - name: keycloak-gatekeeper image: quay.io/gambol99/keycloak-generic-adapter:latest args: - --enable-forwarding=true - --forwarding-username=projecta - --forwarding-password=some_password - --forwarding-domains=projecta.svc.cluster.local - --forwarding-domains=projectb.svc.cluster.local - --tls-ca-certificate=/etc/secrets/ca.pem - --tls-ca-key=/etc/secrets/ca-key.pem # Note: if you don't specify any forwarding domains, all domains will be signed; Also the code checks is the # domain 'contains' the value (it's not a regex) so if you wanted to sign all requests to svc.cluster.local, just use # svc.cluster.local volumeMounts: - name: keycloak-socket mountPoint: /var/run/keycloak - name: projecta image: some_images # test the forward proxy $ curl -k --proxy http://127.0.0.1:3000 https://test.projesta.svc.cluster.local 在接收方，您可以设置Keycloak Gatekeeper（--no=redirects=true）并允许此项验证并处理您的入场许可。 或者，可以在请求中找到访问令牌作为承载令牌。 2.4.8. 转发已签名的HTTPS连接 处理HTTPS需要中间人进行TLS连接。 默认情况下，如果没有提供--tls-ca-certificate和--tls-ca-key，代理将使用默认证书。 如果您希望验证信任，则需要生成CA. $ openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ca.key -out ca.pem $ bin/keycloak-gatekeeper \\ --enable-forwarding \\ --forwarding-username=USERNAME \\ --forwarding-password=PASSWORD \\ --client-id=CLIENT_ID \\ --client-secret=SECRET \\ --discovery-url=https://keycloak.example.com/auth/realms/test \\ --tls-ca-certificate=ca.pem \\ --tls-ca-key=ca-key.pem 2.4.9. HTTPS重定向 代理支持HTTP侦听器，因此这里唯一真正的要求是执行HTTP→HTTPS重定向。 您可以启用以下选项： --listen-http=127.0.0.1:80 --enable-security-filter=true # is required for the https redirect --enable-https-redirection 2.4.10. 我们加密配置 以下是Let's Encrypt支持所需配置的示例： listen: 0.0.0.0:443 enable-https-redirection: true enable-security-filter: true use-letsencrypt: true letsencrypt-cache-dir: ./cache/ redirection-url: https://domain.tld:443/ hostnames: - domain.tld 必须通过端口443进行侦听。 2.4.11. 访问令牌加密 默认情况下，会话令牌以明文形式放入cookie中。 如果您更喜欢加密会话cookie，请使用--enable-encrypted-token和--encryption-key选项。 请注意，在X-Auth-Token标头中转发到上游的访问令牌不受影响。 2.4.12. 上游标题 在受保护的资源上，上游端点将接收代理添加的多个标头以及自定义声明，如下所示： # add the header to the upstream endpoint id := user.(*userContext) cx.Request().Header.Set(\"X-Auth-Email\", id.email) cx.Request().Header.Set(\"X-Auth-ExpiresIn\", id.expiresAt.String()) cx.Request().Header.Set(\"X-Auth-Groups\", strings.Join(id.groups, \",\")) cx.Request().Header.Set(\"X-Auth-Roles\", strings.Join(id.roles, \",\")) cx.Request().Header.Set(\"X-Auth-Subject\", id.id) cx.Request().Header.Set(\"X-Auth-Token\", id.token.Encode()) cx.Request().Header.Set(\"X-Auth-Userid\", id.name) cx.Request().Header.Set(\"X-Auth-Username\", id.name) // step: add the authorization header if requested if r.config.EnableAuthorizationHeader { cx.Request().Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", id.token.Encode())) } 要控制Authorization头，请使用enable-authorization-header yaml配置或--enable-authorization-header命令行选项。 默认情况下，此选项设置为true。 2.4.13. 自定义声明标头 您可以使用--add-claims选项将访问令牌中的其他声明注入到授权标头中。 例如，来自Keycloak提供商的令牌可能包含以下声明： \"resource_access\": {}, \"name\": \"Beloved User\", \"preferred_username\": \"beloved.user\", \"given_name\": \"Beloved\", \"family_name\": \"User\", \"email\": \"beloved@example.com\" 为了请求您在身份验证标头中收到given_name，family_name和name，我们将添加--add-claims=given_name 和 --add-claims=family_name等等，或者我们可以在配置中执行此操作 文件，像这样： add-claims: - given_name - family_name - name 这会将附加标头与标准请求一起添加到经过身份验证的请求中。 X-Auth-Family-Name: User X-Auth-Given-Name: Beloved X-Auth-Name: Beloved User 2.4.14. 自定义标题 您可以使用--headers=\"name=value\"选项或配置文件注入自定义标头： headers: name: value 2.4.15. 加密密钥 为了保持无状态而不必依赖中央缓存来持久化refresh_tokens，刷新令牌被加密并使用crypto/aes 作为cookie添加。 如果您在负载均衡器后面运行，则密钥必须相同。 密钥长度应为16或32字节，具体取决于您是否需要AES-128或AES-256。 2.4.16. 要求匹配 代理支持针对所呈现的令牌添加声明匹配的变量列表以用于附加访问控制。 您可以将'iss'或'aud'与令牌或自定义属性进行匹配; 每个匹配都是正则表达式。 例如，--match-claims'aud=sso.*'或--claim iss = https//.*'或通过配置文件，如下所示： match-claims: aud: openvpn iss: https://keycloak.example.com/auth/realms/commons 或者通过CLI，像这样： --match-claims=auth=openvpn --match-claims=iss=http://keycloak.example.com/realms/commons 您可以限制允许的电子邮件域; 例如，如果您要仅限于example.com域上的用户： match-claims: email: ^.*@example.com$ 适配器支持匹配多值字符串声明。 如果其中一个值匹配，匹配将成功，例如： match-claims: perms: perm1 将成功匹配 { \"iss\": \"https://sso.example.com\", \"sub\": \"\", \"perms\": [\"perm1\", \"perm2\"] } 2.4.17. 组要求 您可以通过资源中可用的groups参数匹配令牌中的组声明。 虽然隐含地要求角色，例如roles=admin,user，其中用户必须具有角色'admin'和'user'，组应用OR操作，因此groups=users,testers要求用户必须 在'users'或'testers'中。 声明名称被硬编码为groups，因此JWT标记看起来像这样： { \"iss\": \"https://sso.example.com\", \"sub\": \"\", \"aud\": \"test\", \"exp\": 1515269245, \"iat\": 1515182845, \"email\": \"beloved@example.com\", \"groups\": [ \"group_one\", \"group_two\" ], \"name\": \"Beloved\" } 2.4.18. 自定义页面 默认情况下，Keycloak Gatekeeper会立即重定向您进行身份验证，并返回403以拒绝访问。 大多数用户可能希望向用户显示更友好的登录和访问被拒绝的页面。 您可以使用--signin-page=PATH将命令行选项（或通过配置文件）路径传递给文件。 登录页面将有一个“重定向”变量传递到作用域并保存oauth重定向URL。 如果你想将其他变量传递给模板，比如title，sitename等，你可以使用--tags key=pair选项，如下所示：--tags title=\"This is my site\"并且可以从``访问该变量。 Sign-in 2.4.19. 白名单 URL's 根据应用程序URL的布局方式，您可能需要保护根/ URL，但在路径列表中有例外，例如/health。 虽然通过调整路径可以最好地解决这个问题，但您可以向受保护资源添加例外，如下所示： resources: - uri: /some_white_listed_url white-listed: true - uri: /* methods: - GET roles: - : - : 或者在命令行上 --resources \"uri=/some_white_listed_url|white-listed=true\" --resources \"uri=/*\" # requires authentication on the rest --resources \"uri=/admin*|roles=admin,superuser|methods=POST,DELETE\" 2.4.20. 交互 TLS 代理支持通过添加--tls-ca-certificate命令行选项或配置文件选项为客户端强制执行相互TLS。 连接的所有客户端必须提供由正在使用的CA签名的证书。 2.4.21. 证书轮换 如果文件在磁盘上更改，代理将自动轮换服务器证书。 请注意，内联更改不会发生停机时间。 在证书轮换之前连接的客户端将不受影响，并且将继续正常使用新证书提供的所有新连接。 2.4.22. 刷新 tokens 如果对访问令牌的请求包含刷新令牌并且--enable-refresh-tokens设置为true，则代理将自动为您刷新访问令牌。 令牌本身保存为加密的 (--encryption-key=KEY) cookie (cookie name: kc-state).。或存储 (still requires encryption key)。 目前支持的唯一存储选项是Redis 和Boltdb。 要启用本地boltdb存储，请使用--store-url boltdb:///PATH或使用相对路径boltdb://PATH。 要启用本地redis存储，请使用redis://[USER:PASSWORD@]HOST:PORT。 在这两种情况下，刷新令牌在放入商店之前都会被加密。 2.4.23. 注销端点 提供/oauth/logout?redirect=url作为帮助记录用户的帮助程序。 除了删除任何会话cookie之外，我们还尝试通过提供者撤销通过吊销URL(config revocation-url or --revocation-url)的访问权限。 对于Keycloak，其网址为https://keycloak.example.com/auth/realms/REALM_NAME/protocol/openid-connect/logout。 如果未指定url，我们将尝试从OpenID发现响应中获取url。 2.4.24. 跨域资源共享 (CORS) 您可以使用这些配置选项通过--cors-[method]添加CORS头。 Access-Control-Allow-Origin Access-Control-Allow-Methods Access-Control-Allow-Headers Access-Control-Expose-Headers Access-Control-Allow-Credentials Access-Control-Max-Age 您可以使用配置文件添加： cors-origins: - '*' cors-methods: - GET - POST 或通过命令行： --cors-origins [--cors-origins option] 一组要添加到CORS访问控制的起源 (Access-Control-Allow-Origin) --cors-methods [--cors-methods option] 访问控制中允许的方法 (Access-Control-Allow-Methods) --cors-headers [--cors-headers option] 要添加到CORS访问控制的一组标头 (Access-Control-Allow-Headers) --cors-exposes-headers [--cors-exposes-headers option] 设置公开的cors标头访问控制 (Access-Control-Expose-Headers) 2.4.25. 上游URL 您可以通过--upstream-url选项控制上游端点。 通过--skip-upstream-tls-verify / --upstream-keepalives选项配置TLS验证和保持活动支持，支持HTTP和HTTPS。 注意，代理也可以通过UNIX套接字上游，--upstream-url unix://path/to/the/file.sock。 2.4.26. 端点 /oauth/authorize 是身份验证端点，它将生成OpenID重定向到提供程序 /oauth/callback 是提供者OpenID回调端点 /oauth/expired 是一个辅助端点，用于检查访问令牌是否已过期，200表示ok，401表示无令牌，401表示已过期 /oauth/health 是代理的运行状况检查端点，您也可以从标头中获取版本 /oauth/login 提供一个通过grant_type=password登录的中继端点，例如，POST /oauth/login表单值为username=USERNAME＆password=PASSWORD`（必须启用） /oauth/logout 提供了一个方便的端点来记录用户，它总是会尝试从脱机令牌中执行反向通道注销 /oauth/token 是一个帮助端点，它将为您显示当前的访问令牌 /oauth/metrics 是一个Prometheus指标处理程序 2.4.27. 度量 假设已经设置了--enable-metrics，可以在/oauth/metrics 上找到Prometheus端点; 目前，唯一公开的度量标准是每个HTTP代码的计数器。 2.4.28. 限制 如果您在浏览器cookie中使用访问权限或刷新令牌，请记住[浏览器cookie限制]（http://browsercookielimits.squawky.net/）。 如果您的cookie超过4093字节，Keycloak-generic-adapter会自动划分cookie。 cookie的实际大小取决于发布的访问令牌的内容。 此外，加密可能会为cookie大小添加额外的字节。 如果您有大型Cookie（> 200 KB），则可能会达到浏览器Cookie限制。 所有cookie都是标头请求的一部分，因此您可能会发现基础结构中的最大标头大小限制存在问题（某些负载平衡器的此值非常低，例如8 KB）。 确保所有网络设备都有足够的标头大小限制。 否则，您的用户将无法获得访问令牌。 2.4.29. 已知的问题 Keycloak服务器4.7.0.Final存在一个已知问题，其中Gatekeeper无法在aud声明中找到client_id。 这是因为client_id不再在观众中。 解决方法是将“Audience(受众)”协议映射器添加到客户端，并将受众指向client_id。 有关详细信息，请参阅KEYCLOAK-8954。 ==== mod_auth_openidc Apache HTTPD模块 mod_auth_openidc是OpenID Connect的Apache HTTP插件。 如果您的语言/环境支持使用Apache HTTPD作为代理，那么您可以使用mod_auth_openidc来使用OpenID Connect保护您的Web应用程序。 此模块的配置超出了本文档的范围。 有关配置的更多详细信息，请参阅mod_auth_openidc GitHub 仓库。 要配置mod_auth_openidc，您需要 The client_id. The client_secret. redirect_uri到您的应用程序。 Keycloak openid配置网址 mod_auth_openidc特定的Apache HTTPD模块配置。 示例配置如下所示。 LoadModule auth_openidc_module modules/mod_auth_openidc.so ServerName ${HOSTIP} ServerAdmin webmaster@localhost DocumentRoot /var/www/html #this is required by mod_auth_openidc OIDCCryptoPassphrase a-random-secret-used-by-apache-oidc-and-balancer OIDCProviderMetadataURL ${KC_ADDR}/auth/realms/${KC_REALM}/.well-known/openid-configuration OIDCClientID ${CLIENT_ID} OIDCClientSecret ${CLIENT_SECRET} OIDCRedirectURI http://${HOSTIP}/${CLIENT_APP_NAME}/redirect_uri # maps the prefered_username claim to the REMOTE_USER environment variable OIDCRemoteUserClaim preferred_username AuthType openid-connect Require valid-user 有关如何配置mod_auth_openidc的更多信息，请参见mod_auth_openidc 项目页面。 2.5. 其他OpenID连接库 Keycloak可以通过提供的适配器进行保护，这些适配器通常更易于使用，并且可以更好地与Keycloak集成。 但是，如果适配器不适用于您的编程语言，框架或平台，则可以选择使用通用OpenID Connect资源提供程序（RP）库。 本章介绍了Keycloak的具体细节，但不包含特定的协议详细信息。 有关详细信息，请参阅OpenID Connect规范和OAuth2规范。 2.5.1. 端点 要了解的最重要的端点是well-known(众所周知的)配置端点。 它列出了与Keycloak中的OpenID Connect实现相关的端点和其他配置选项。 端点是： /realms/{realm-name}/.well-known/openid-configuration 要获取完整的URL，请添加Keycloak的基本URL，并将{realm-name}替换为您的域的名称。 例如： http://localhost:8080/auth/realms/master/.well-known/openid-configuration 某些RP库从此端点检索所有必需的端点，但对于其他端点，您可能需要单独列出端点。 授权端点 /realms/{realm-name}/protocol/openid-connect/auth 授权端点执行最终用户的身份验证。 这是通过将用户代理重定向到此端点来完成的。 有关更多详细信息，请参阅OpenID Connect规范中的授权端点 部分。 令牌端点 /realms/{realm-name}/protocol/openid-connect/token 令牌端点用于获取令牌。 可以通过交换授权代码或直接提供凭证来获取令牌，具体取决于使用的流程。 令牌端点还用于在到期时获取新的访问令牌。 有关更多详细信息，请参阅OpenID Connect规范中的令牌端点部分。 Userinfo端点 /realms/{realm-name}/protocol/openid-connect/userinfo userinfo端点返回有关经过身份验证的用户的标准声明，并受承载令牌保护。 有关更多详细信息，请参阅OpenID Connect规范中的Userinfo端点部分。 注销端点 /realms/{realm-name}/protocol/openid-connect/logout 注销端点注销经过身份验证的用户。 可以将用户代理重定向到端点，在这种情况下，将注销活动用户会话。 之后，用户代理将重定向回应用程序。 端点也可以由应用程序直接调用。 要直接调用此端点，需要包含刷新令牌以及验证客户端所需的凭据。 证书端点 /realms/{realm-name}/protocol/openid-connect/certs 证书端点返回由领域启用的公钥，编码为JSON Web密钥（JWK）。 根据领域设置，可以启用一个或多个密钥来验证令牌。 有关详细信息，请参阅服务器管理指南 和JSON Web密钥规范。 内省端点 /realms/{realm-name}/protocol/openid-connect/token/introspect 内省端点用于检索令牌的活动状态。 换句话说，您可以使用它来验证访问或刷新令牌。 它只能由机密客户端调用。 有关如何在此端点上调用的更多详细信息，请参阅OAuth 2.0 Token Introspection规范。 动态客户端注册端点 /realms/{realm-name}/clients-registrations/openid-connect 动态客户端注册端点用于动态注册客户端。 有关详细信息，请参阅客户端注册章节和OpenID Connect动态客户端注册规范。 2.5.2. 验证访问令牌 如果您需要手动验证Keycloak发出的访问令牌，您可以调用内省端点。 这种方法的缺点是您必须对Keycloak服务器进行网络调用。 如果您同时进行太多验证请求，这可能会很慢并且可能会使服务器过载。 Keycloak颁发的访问令牌是JSON Web令牌（JWT），使用JSON Web签名（JWS）进行数字签名和编码。 因为它们是以这种方式编码的，所以这允许您使用发布领域的公钥在本地验证访问令牌。 您可以在验证代码中对域的公钥进行硬编码，也可以使用[证书端点]查找和缓存公钥(https://www.keycloak.org/docs/latest/securing_apps/index.html#_certificate_endpoint)使用JWS中嵌入的密钥ID（KID）。 根据您编写的语言，有许多第三方库可以帮助您进行JWS验证。 2.5.3. 流 授权码 授权代码流将用户代理重定向到Keycloak。 一旦用户成功通过Keycloak进行身份验证，就会创建一个授权码，并将用户代理重定向回应用程序。 然后，应用程序使用授权代码及其凭据从Keycloak获取访问令牌，刷新令牌和ID令牌。 该流程针对Web应用程序，但也建议用于本机应用程序，包括可以嵌入用户代理的移动应用程序。 有关更多详细信息，请参阅OpenID Connect规范中的授权代码流程 。 隐式 隐式流重定向的工作方式与授权代码流类似，但不返回授权代码，而是返回访问令牌和ID令牌。 这减少了额外调用以交换访问令牌的授权码的需要。 但是，它不包括刷新令牌。 这导致需要允许具有长期到期的访问令牌，这是有问题的，因为很难使这些无效。 或者在初始访问令牌过期后需要新的重定向来获取新的访问令牌。 如果应用程序只想验证用户并处理注销本身，则隐式流非常有用。 还有一个混合流程，其中返回访问令牌和授权代码。 需要注意的一点是，隐式流和混合流都存在潜在的安全风险，因为访问令牌可能会通过Web服务器日志和浏览器历史泄漏。 通过使用访问令牌的短期到期，可以稍微减轻这种情况。 有关更多详细信息，请参阅OpenID Connect规范中的Implicit Flow。 资源所有者密码凭据 资源所有者密码凭据（在Keycloak中称为直接授权）允许为令牌交换用户凭据。 除非您绝对需要，否则不建议使用此流程。 这可能有用的示例是遗留应用程序和命令行界面。 使用此流程有许多限制，包括： 用户凭据将公开给应用程序 应用需要登录页面 应用程序需要了解身份验证方案 对身份验证流程的更改需要更改应用程序 不支持身份代理或社交登录 不支持流程（用户自行注册，所需操作等） 要允许客户端使用资源所有者密码凭据授予，客户端必须启用Direct Access Grants Enabled选项。 此流程不包含在OpenID Connect中，但是是OAuth 2.0规范的一部分。 有关更多详细信息，请参阅OAuth 2.0规范中的资源所有者密码凭据授权章节。 使用CURL的示例 以下示例显示如何使用用户名user和密码password为领域master中的用户获取访问令牌。 示例使用机密客户端myclient： curl \\ -d \"client_id=myclient\" \\ -d \"client_secret=40cc097b-2a57-4c17-b36a-8fdf3fc2d578\" \\ -d \"username=user\" \\ -d \"password=password\" \\ -d \"grant_type=password\" \\ \"http://localhost:8080/auth/realms/master/protocol/openid-connect/token\" 客户端凭据 客户端（应用程序和服务）希望代表自己而不是代表用户获取访问权限时使用客户端凭据。 例如，这对于通常而不是针对特定用户应用对系统的更改的后台服务是有用的。 Keycloak支持客户端使用密钥或公钥/私钥进行身份验证。 此流程不包含在OpenID Connect中，但是是OAuth 2.0规范的一部分。 有关更多详细信息，请参阅OAuth 2.0规范中的Client Credentials Grant章节。 2.5.4. 重定向URI 使用基于重定向的流时，为您的客户使用有效的重定向uris很重要。 重定向uris应尽可能具体。 这尤其适用于客户端（公共客户端）应用程序。 如果不这样做可能会导致： Open redirects - 这可以允许攻击者创建看似他们来自您的域的欺骗链接 Unauthorized entry - 当用户已经使用Keycloak进行身份验证时，攻击者可以使用公共客户端，其中未正确配置重定向uris以通过重定向用户而无需用户知识来获取访问权限 在Web应用程序的生产中，始终对所有重定向URI使用https。 不允许重定向到http。 还有一些特殊的重定向URI： http://localhost 此重定向URI对本机应用程序很有用，并允许本机应用程序在随机端口上创建可用于获取授权代码的Web服务器。 这个重定向uri允许任何端口。 urn:ietf:wg:oauth:2.0:oob 如果无法在客户端启动Web服务器（或浏览器不可用），则可以使用特殊的urn:ietf:wg:oauth:2.0:oob重定向uri。 使用此重定向uri时，Keycloak会显示一个页面，其中包含标题中的代码和页面上的框。 应用程序可以检测到浏览器标题已更改，或者用户可以手动将代码复制/粘贴到应用程序。 通过此重定向uri，用户还可以使用不同的设备来获取要粘贴回应用程序的代码。 3. SAML 本节介绍如何使用Keycloak客户端适配器或通用SAML提供程序库使用SAML保护应用程序和服务。 3.1. Java 适配器 Keycloak为Java应用程序提供了一系列不同的适配器。 选择正确的适配器取决于目标平台。 3.1.1. 通用适配器配置 Keycloak支持的每个SAML客户端适配器都可以通过简单的XML文本文件进行配置。 这可能是这样的： 其中一些配置开关可能是适配器特定的，有些在所有适配器上都是通用的。 对于Java适配器，您可以使用${…}enclosure作为System属性替换。 例如${jboss.server.config.dir}。 SP元素 以下是SP元素属性的说明： ... entityID 这是此客户端的标识符。 IdP需要此值来确定与之通信的客户端。 此设置为REQUIRED。 sslPolicy 这是适配器将强制执行的SSL策略。 有效值为：ALL，EXTERNAL和NONE。 对于ALL，所有请求必须通过HTTPS进入。 对于EXTERNAL，只有非私有IP地址必须通过HTTPS连接。 对于NONE，不需要通过HTTPS接收请求。 此设置为OPTIONAL。 默认值为EXTERNAL。 nameIDPolicyFormat SAML客户端可以请求特定的NameID主题格式。 如果需要特定格式，请填写此值。 它必须是标准的SAML格式标识符：urn:oasis:names:tc:SAML:2.0:nameid-format:transient。 此设置为OPTIONAL。 默认情况下，不请求特殊格式。 forceAuthentication SAML客户端可以请求用户重新进行身份验证，即使他们已经在IdP登录也是如此。 将其设置为true以启用。 此设置为OPTIONAL。 默认值为false。 isPassive SAML客户端可以请求永远不会要求用户进行身份验证，即使他们未在IdP登录也是如此。 如果你想要这个，请将其设置为true。 不要与forceAuthentication一起使用，因为它们相反。 此设置为OPTIONAL。 默认值为false。 turnOffChangeSessionIdOnLogin 默认情况下，在某些平台上成功登录时会更改会话ID以插入安全攻击媒介。 将其更改为true以禁用此功能。 建议您不要将其关闭。 默认值为false。 autodetectBearerOnly 如果您的应用程序同时提供Web应用程序和Web服务（例如SOAP或REST），则应将其设置为true。 它允许您将未经身份验证的Web应用程序用户重定向到Keycloak登录页面，但是将HTTP401状态代码发送给未经身份验证的SOAP或REST客户端，因为他们无法理解重定向到登录页面。 Keycloak基于典型的标题自动检测SOAP或REST客户端，如X-Requested-With，SOAPAction或Accept。 默认值为false。 logoutPage 这会将页面设置为在注销后显示。 如果页面是完整的URL，例如http://web.example.com/logout.html，则在使用HTTP302状态代码注销到该页面后，将重定向用户。 如果指定了没有scheme部分的链接，例如/ logout.jsp，则在注销后会显示该页面， 根据web.xml中的安全性约束声明，它是否位于受保护区域中，并且相对于部署上下文根解析页面。 服务提供商密钥和关键元素 如果IdP要求客户端应用程序（或SP）签署其所有请求和/或IdP将加密断言，则必须定义用于执行此操作的密钥。 对于客户端签名的文档，您必须定义用于签署文档的私钥和公钥或证书。 对于加密，您只需定义用于解密它的私钥。 有两种方法可以描述您的密钥。 它们可以存储在Java KeyStore中，也可以直接在PEM格式的keycloak-saml.xml中复制/粘贴密钥。 ... Key元素有两个可选属性signing和encryption。 设置为true时，这些将告诉适配器密钥的用途。 如果两个属性都设置为true，则密钥将用于签名文档和解密加密断言。 您必须将这些属性中的至少一个设置为true。 KeyStore元素 在Key元素中，您可以从Java Keystore加载密钥和证书。 这是在KeyStore元素中声明的。 以下是使用KeyStore元素定义的XML配置属性。 file 密钥库的文件路径。 此选项为OPTIONAL。 必须设置文件或资源属性。 resource KeyStore的WAR资源路径。 这是对ServletContext.getResourceAsStream()的方法调用中使用的路径。 此选项为OPTIONAL。 必须设置文件或资源属性。 password KeyStore的密码。 此选项为REQUIRED。 如果要定义SP将用于签署文档的密钥，则还必须在Java KeyStore中指定对私钥和证书的引用。 上例中的PrivateKey和Certificate元素定义了一个指向密钥库中的密钥或证书的alias。 密钥库需要额外的密码才能访问私钥。 在PrivateKey元素中，您必须在password属性中定义此密码。 Key PEMS 在Key元素中，您使用子元素PrivateKeyPem，PublicKeyPem和CertificatePem直接声明您的键和证书。 这些元素中包含的值必须符合PEM密钥格式。 如果使用openssl或类似的命令行工具生成密钥，通常使用此选项。 2341251234AB31234==231BB998311222423522334 211111341251234AB31234==231BB998311222423522334 SP PrincipalNameMapping 元素 此元素是可选的。 在创建从诸如HttpServletRequest.getUserPrincipal()之类的方法获得的Java Principal对象时，可以定义Principal.getName()方法返回的名称。 policy属性定义用于填充此值的策略。 此属性的可能值为： FROM_NAME_ID 此策略仅使用SAML主题值。 这是默认设置 FROM_ATTRIBUTE 这将从服务器收到的SAML断言中声明的其中一个属性中提取值。 您需要指定要在attribute XML属性中使用的SAML断言属性的名称。 RoleIdentifiers 元素 RoleIdentifiers元素定义从用户接收的断言中的SAML属性应该用作用户的Java EE安全上下文中的角色标识符。 默认情况下，Role属性值将转换为Java EE角色。 一些IdP使用member或memberOfattribute断言发送角色。 您可以定义一个或多个Attribute元素，以指定必须将哪些SAML属性转换为角色。 IDP 元素 IDP元素中的所有内容都描述了SP正在与之通信的身份提供者（身份验证服务器）的设置。 ... 以下是您可以在IDP元素声明中指定的属性配置选项。 entityID 这是IDP的发行者ID。 此设置为REQUIRED。 signaturesRequired 如果设置为true，则客户端适配器将对它发送给IDP的每个文档进行签名。 此外，客户将期望IDP将签署发送给它的任何文件。 此开关设置所有请求和响应类型的默认值，但稍后您将看到您对此有一些细粒度控制。 此设置为OPTIONAL，默认为false。 signatureAlgorithm 这是IDP期望签名文档使用的签名算法。 允许的值为：RSA_SHA1，RSA_SHA256，RSA_SHA512和DSA_SHA1。 此设置为OPTIONAL，默认为RSA_SHA256。 signatureCanonicalizationMethod 这是IDP期望签名文档使用的签名规范化方法。 此设置为OPTIONAL。 默认值为http://www.w3.org/2001/10/xml-exc-c14n#，对大多数IPDs应该是好的。 metadataUrl 用于检索IDP元数据的URL，目前仅用于定期获取签名和加密密钥，允许在IDP上循环使用这些密钥，而无需在SP端手动更改。 IDP SingleSignOnService 子元素 SingleSignOnService子元素定义IDP的登录SAML端点。 当客户端适配器要登录时，它将通过此元素中的设置向IDP发送请求。 以下是您可以在此元素上定义的配置属性： signRequest 客户应该签署authn请求吗？ 此设置为OPTIONAL。 默认为IDPignaturesRequired元素值。 validateResponseSignature 客户是否希望IDP签署从auhtn请求发回的断言响应文档？ 此设置OPTIONAL。 默认为IDPvalidateResponseSignature元素值。 requestBinding 这是用于与IDP通信的SAML绑定类型。 此设置为OPTIONAL。 默认值为POST，但您也可以将其设置为REDIRECT。 responseBinding SAML允许客户端请求它想要authn响应使用的绑定类型。 这个值可以是POST或REDIRECT。 此设置为OPTIONAL。 默认情况下，客户端不会为响应请求特定的绑定类型。 assertionConsumerServiceUrl IDP登录服务应向其发送响应的断言使用者服务（ACS）的URL。 此设置为OPTIONAL。 默认情况下，它取消设置，依赖于IdP中的配置。 设置时，它必须以/saml结尾，例如http://sp.domain.com/my/endpoint/for/saml。 此属性的值在SAMLAuthnRequest消息的AssertionConsumerServiceURL属性中发送。 该属性通常伴随着responseBinding属性。 bindingUrl 这是客户端将请求发送到的IDP登录服务的URL。 此设置为REQUIRED。 IDP SingleLogoutService 子元素 SingleLogoutService子元素定义IDP的注销SAML端点。 当客户端适配器要注销时，它将通过此元素中的设置向IDP发送请求。 signRequest 客户应该签署注销请求吗？ 此设置为OPTIONAL。 默认为IDPsignaturesRequired元素值。 signResponse 如果客户端签署注销响应，它会发送给IDP请求吗？ 此设置为OPTIONAL。 默认为IDPsignaturesRequired元素值。 validateRequestSignature 客户是否应该期待来自IDP的签名退出请求文件？ 此设置为OPTIONAL。 默认为IDPsignaturesRequired元素值。 validateResponseSignature 客户是否应该期待来自IDP的签名注销响应文档？ 此设置为OPTIONAL。 默认为IDPsignaturesRequired元素值。 requestBinding 这是用于将SAML请求传递给IDP的SAML绑定类型。 此设置为OPTIONAL。 默认值为POST，但您也可以将其设置为REDIRECT。 responseBinding 这是用于将SAML响应传递给IDP的SAML绑定类型。 这个值可以是POST或REDIRECT。 此设置为OPTIONAL。 默认值为POST，但您也可以将其设置为REDIRECT。 postBindingUrl 这是使用POST绑定时IDP注销服务的URL。 如果使用POST绑定，则此设置为REQUIRED。 redirectBindingUrl 这是使用REDIRECT绑定时IDP注销服务的URL。 如果使用REDIRECT绑定，此设置为REQUIRED。 IDP Keys 子元素 IDP的Keys子元素仅用于定义用于验证IDP签名的文档的证书或公钥。 它的定义方式与SP的Keys元素相同。 但同样，您只需要定义一个证书或公钥引用。 请注意，如果IDP和SP分别由Keycloak服务器和适配器实现，则无需指定用于签名验证的密钥，请参阅下文。 如果SP和IDP都由Keycloak实现，则可以将SP配置为自动从已发布的证书获取IDP签名验证的公钥。 这是通过删除Keys子元素中签名验证密钥的所有声明来完成的。 如果Keys子元素将保持为空，则可以完全省略它。 然后，SP从SAML描述符自动获取密钥，其位置来自IDP SingleSignOnService子元素中指定的SAML端点URL。用于SAML描述符检索的HTTP客户端的设置通常不需要额外配置，但可以在IDP HttpClient子元素中配置。 还可以为签名验证指定多个密钥。 这是通过在Keys子元素中声明signed属性设置为true的多个Key元素来完成的。 例如，在旋转IDP签名密钥的情况下，这很有用：通常有一个过渡期，当新的SAML协议消息和断言用新密钥签名但仍应接受由先前密钥签名的那些消息和断言。 无法将Keycloak配置为自动获取签名验证密钥并定义其他静态签名验证密钥。 ... IDP HttpClient 子元素 HttpClient可选子元素定义HTTP客户端的属性，用于在启用时通过IDP的SAML描述符自动获取包含用于IDP签名验证的公钥的证书。 connectionPoolSize 适配器将对Keycloak服务器进行单独的HTTP调用，以将访问代码转换为访问令牌。 此配置选项定义应该合并到Keycloak服务器的连接数。 这是OPTIONAL。 默认值为10。 disableTrustManager 如果Keycloak服务器需要HTTPS并且此配置选项设置为true，则不必指定信任库。 此设置仅应在开发期间使用，永远不会在生产中使用，因为它将禁用SSL证书的验证。 这是OPTIONAL。 默认值为false。 allowAnyHostname 如果Keycloak服务器需要HTTPS并且此配置选项设置为true，则通过信任库验证Keycloak服务器的证书，但不会进行主机名验证。 此设置应仅在开发期间使用，永远不会在生产中使用，因为它将部分禁用SSL证书的验证。 这种设置在测试环境中可能很有用。 这是OPTIONAL。 默认值为false。 truststore 该值是信任库文件的文件路径。 如果在路径前加上classpath:，那么将从部署的类路径中获取信任库。 用于与Keycloak服务器的传出HTTPS通信。 发出HTTPS请求的客户端需要一种方法来验证他们正在与之通信的服务器的主机。 这就是委托人所做的。 密钥库包含一个或多个可信主机证书或证书颁发机构。 您可以通过提取Keycloak服务器的SSL密钥库的公共证书来创建此信任库。 除非disableTrustManager为'true`，否则这是REQUIRED。 truststorePassword 信任库的密码。 如果设置了truststore并且信任库需要密码，那么这是REQUIRED。 clientKeystore 这是密钥库文件的文件路径。 当适配器向Keycloak服务器发出HTTPS请求时，此密钥库包含双向SSL的客户端证书。 这是OPTIONAL。 clientKeystorePassword 客户端密钥库和客户端密钥的密码。 如果设置了clientKeystore，这是REQUIRED。 proxyUrl 用于HTTP连接的HTTP代理的URL。 这是OPTIONAL。 3.1.2. JBoss EAP/WildFly 适配器 为了能够保护部署在JBoss EAP或WildFly上的WAR应用程序，您必须安装和配置Keycloak SAML适配器子系统。 然后，在WAR中提供keycloak配置，/WEB-INF/keycloak-saml.xml文件，并在web.xml中将auth-method更改为KEYCLOAK-SAML。 本节将介绍这两种方法。 适配器安装 每个适配器都是Keycloak下载站点上的单独下载。 我们只测试和维护适配器，并在发布时提供最新版本的WildFly。 一旦发布了新版本的WildFly，当前的适配器将被弃用，并且在下一个WildFly版本发布后将删除对它们的支持。 另一种方法是将应用程序从WildFly切换到JBoss EAP，因为JBoss EAP适配器的支持时间更长。 在WildFly 9或更高版本或JBoss EAP 7上安装： $ cd $WILDFLY_HOME $ unzip keycloak-saml-wildfly-adapter-dist.zip 在JBoss EAP 6.x上安装： $ cd $JBOSS_HOME $ unzip keycloak-saml-eap6-adapter-dist.zip 这些zip文件在WildFly或JBoss EAP发行版中创建特定于WildFly/JBoss EAP SAML适配器的新JBoss模块。 添加模块后，必须在应用服务器的服务器配置中启用Keycloak SAML子系统：domain.xml或standalone.xml。 有一个CLI脚本可以帮助您修改服务器配置。 启动服务器并从服务器的bin目录运行脚本： WildFly 11或更新版本 $ cd $JBOSS_HOME $ ./bin/jboss-cli.sh -c --file=bin/adapter-elytron-install-saml.cli WildFly 10或更老版本 $ cd $JBOSS_HOME $ /bin/boss-cli.sh -c --file=bin/adapter-install-saml.cli 可以在WildFly 11或更新版本上使用传统的非Elytron适配器，这意味着您甚至可以在这些版本上使用adapter-install-saml.cli。 但是，我们建议使用较新的Elytron适配器。 该脚本将添加扩展，子系统和可选的安全域，如下所述。 ... ... 当您需要在安全Web层中创建的安全上下文传播到您正在调用的EJB（其他EE组件）时，keycloak安全域应该与EJB和其他组件一起使用。 否则此配置是可选的。 ... 例如，如果您的WEB-INF/classes目录中有一个EJB的JAX-RS服务，则需要使用@SecurityDomain注释对其进行注释，如下所示： import org.jboss.ejb3.annotation.SecurityDomain; import org.jboss.resteasy.annotations.cache.NoCache; import javax.annotation.security.RolesAllowed; import javax.ejb.EJB; import javax.ejb.Stateless; import javax.ws.rs.GET; import javax.ws.rs.Path; import javax.ws.rs.Produces; import java.util.ArrayList; import java.util.List; @Path(\"customers\") @Stateless @SecurityDomain(\"keycloak\") public class CustomerService { @EJB CustomerDB db; @GET @Produces(\"application/json\") @NoCache @RolesAllowed(\"db_user\") public List getCustomers() { return db.getCustomers(); } } 我们希望将来改进我们的集成，以便在您希望将keycloak安全上下文传播到EJB层时不必指定@SecurityDomain注释。 JBoss SSO WildFly内置支持部署到同一WildFly实例的Web应用程序的单点登录。 使用Keycloak时不应启用此功能。 3.1.3. 从RPM安装JBoss EAP适配器 从RPM安装EAP 7适配器： 在Red Hat Enterprise Linux 7中，术语channel被替换为术语库。 在这些说明中，仅使用术语库。 您必须先订阅JBoss EAP 7存储库，然后才能从RPM安装EAP 7适配器。 先决条件 确保您的Red Hat Enterprise Linux系统已使用Red Hat Subscription Manager注册到您的帐户。 有关更多信息，请参阅Red Hat订阅管理文档。 如果您已经订阅了另一个JBoss EAP存储库，则必须先取消订阅该存储库。 使用Red Hat Subscription Manager，使用以下命令订阅JBoss EAP 7存储库。 将替换为6或7，具体取决于您的Red Hat Enterprise Linux版本。 $ sudo subscription-manager repos --enable=jb-eap-7-for-rhel--server-rpms 使用以下命令为SAML安装EAP 7适配器： $ sudo yum install eap7-keycloak-saml-adapter-sso7_2 RPM安装的默认EAP_HOME路径是/opt/rh/eap7/root/usr/share/wildfly。 运行相应的模块安装脚本。 对于SAML模块，请输入以下命令： $ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install-saml.cli 您的安装已完成。 从RPM安装EAP 6适配器： 在Red Hat Enterprise Linux 7中，术语channel被替换为术语库。 在这些说明中，仅使用术语库。 您必须先订阅JBoss EAP 6存储库，然后才能从RPM安装EAP 6适配器。 先决条件 确保您的Red Hat Enterprise Linux系统已使用Red Hat Subscription Manager注册到您的帐户。 有关更多信息，请参阅Red Hat订阅管理文档。 如果您已经订阅了另一个JBoss EAP存储库，则必须先取消订阅该存储库。 使用Red Hat Subscription Manager，使用以下命令订阅JBoss EAP 6存储库。 将替换为6或7，具体取决于您的Red Hat Enterprise Linux版本。 $ sudo subscription-manager repos --enable=jb-eap-6-for-rhel--server-rpms 使用以下命令为SAML安装EAP 6适配器： $ sudo yum install keycloak-saml-adapter-sso7_2-eap6 RPM安装的默认EAP_HOME路径是/opt/rh/eap6/root/usr/share/wildfly。 运行相应的模块安装脚本。 对于SAML模块，请输入以下命令： $ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install-saml.cli 您的安装已完成。 每个WAR配置 本节介绍如何通过在WAR包中添加配置和编辑文件来直接保护WAR。 您必须做的第一件事是在WAR的WEB-INF目录中创建一个keycloak-saml.xml适配器配置文件。 该配置文件的格式在General Adapter Config部分中描述。 接下来，您必须在web.xml中将auth-method设置为KEYCLOAK-SAML。 您还必须使用标准servlet安全性来指定URL上的角色基础约束。 这是一个示例web.xml文件： customer-portal Admins /admin/* admin CONFIDENTIAL Customers /customers/* user CONFIDENTIAL KEYCLOAK-SAML this is ignored currently admin user 除了auth-method设置之外的所有标准servlet设置。 通过Keycloak SAML子系统保护WAR 您不必破解打开WAR以使用Keycloak保护它。 或者，您可以通过Keycloak SAML适配器子系统从外部保护它。 虽然您不必将KEYCLOAK-SAML指定为auth-method，但仍需要在web.xml中定义security-constraints。 但是，您不必创建WEB-INF/keycloak-saml.xml文件。 而是在服务器的domain.xml或standalone.xml子系统配置部分的XML中定义此元数据。 ... secure-deployment``name属性标识要保护的WAR。 它的值是web.xml中定义的module-name，附加了.war。 其余配置使用与General Adapter Config中定义的keycloak-saml.xml配置相同的XML语法。 配置示例： 3.1.4. Tomcat SAML 适配器 为了能够保护部署在Tomcat 6,7和8上的WAR应用程序，您必须将Keycloak Tomcat 6,7或8 SAML适配器安装到Tomcat安装中。 然后，您必须在部署到Tomcat的每个WAR中提供一些额外的配置。 我们来看看这些步骤。 适配器安装 适配器不再包含在设备或war分发版中。每个适配器在Keycloak下载站点上都是单独的下载。它们也可以作为maven构件使用。 您必须将适配器发行版解压缩到Tomcat的lib/目录中。 在WEB-INF/lib目录中包含适配器的jar将不起作用！ Keycloak SAML适配器实现为Valve，Valve代码必须驻留在Tomcat的主lib/目录中。 $ cd $TOMCAT_HOME/lib $ unzip keycloak-saml-tomcat6-adapter-dist.zip or $ unzip keycloak-saml-tomcat7-adapter-dist.zip or $ unzip keycloak-saml-tomcat8-adapter-dist.zip 每个 WAR 配置 本节介绍如何通过在WAR包中添加配置和编辑文件来直接保护WAR。 您必须做的第一件事是在WAR包中创建一个META-INF/context.xml文件。 这是一个特定于Tomcat的配置文件，您必须定义一个Keycloak特定的Valve。 接下来，您必须在WAR的WEB-INF目录中创建一个keycloak-saml.xml适配器配置文件。 该配置文件的格式在General Adapter Config 部分中描述。 最后，您必须同时指定login-config并使用标准servlet安全性来指定URL上的角色基础约束。 这是一个例子： customer-portal Customers /* user BASIC this is ignored currently admin user 3.1.5. Jetty SAML 适配器 为了能够保护部署在Jetty上的WAR应用程序，您必须将Keycloak Jetty 9.x SAML适配器安装到Jetty安装中。 然后，您必须在部署到Jetty的每个WAR中提供一些额外的配置。 我们来看看这些步骤。 Jetty 9 适配器安装 Keycloak为Jetty 9.x提供了一个单独的SAML适配器。 然后，您必须在部署到Jetty的每个WAR中提供一些额外的配置。 我们来看看这些步骤。 适配器不再包含在设备或war分发版中。每个适配器在Keycloak下载站点上都是单独的下载。它们也可以作为maven构件使用。 您必须将Jetty 9.x发行版解压缩到Jetty 9.x的根目录中。 在WEB-INF/lib目录中包含适配器的jar将不起作用！ $ cd $JETTY_HOME $ unzip keycloak-saml-jetty92-adapter-dist.zip 接下来，您必须为jetty.base启用keycloak模块。 $ cd your-base $ java -jar $JETTY_HOME/start.jar --add-to-startd=keycloak Jetty 9 每个 WAR 配置 本节介绍如何通过在WAR包中添加配置和编辑文件来直接保护WAR。 您必须做的第一件事是在WAR包中创建一个WEB-INF/jetty-web.xml文件。 这是Jetty特定的配置文件，您必须在其中定义Keycloak特定的身份验证器。 接下来，您必须在WAR的WEB-INF目录中创建一个keycloak-saml.xml适配器配置文件。 该配置文件的格式在General Adapter Config 部分中描述。 最后，您必须同时指定login-config并使用标准servlet安全性来指定URL上的角色基础约束。 这是一个例子： customer-portal Customers /* user CONFIDENTIAL BASIC this is ignored currently admin user 3.1.6. Java Servlet 过滤器适配器 如果要将SAML与不具有该servlet平台适配器的Java servlet应用程序一起使用，则可以选择使用Keycloak具有的servlet过滤器适配器。 此适配器与其他适配器的工作方式略有不同。 您仍然必须指定General Adapter Config中定义的/WEB-INF/keycloak-saml.xml文件部分，但是您没有在web.xml中定义安全性约束。 而是使用Keycloak servlet过滤器适配器定义过滤器映射，以保护要保护的URL模式。 Backchannel注销与标准适配器的工作方式略有不同。 而不是使http会话无效，而是将会话ID标记为已注销。 根据会话ID，无法任意使http会话无效。 当您拥有使用SAML筛选器的群集应用程序时，Backchannel注销当前不起作用。 customer-portal Keycloak Filter org.keycloak.adapters.saml.servlet.SamlFilter Keycloak Filter /* Keycloak过滤器具有与其他适配器相同的配置参数，除非您必须将它们定义为过滤器init参数而不是上下文参数。 如果您有各种不同的安全和不安全的URL模式，则可以定义多个过滤器映射。 您必须有一个覆盖/saml的过滤器映射。 此映射涵盖所有服务器回调。 当向IdP注册SPs时，必须将http[s]://主机名/{context-root}/saml注册为断言消费者服务URL和单个注销服务URL。 要使用此过滤器，请在WAR poms中包含此maven工件： org.keycloak keycloak-saml-servlet-filter-adapter 6.0.1 为了使用Multi Tenancy，应将keycloak.config.resolver参数作为过滤器参数传递。 Keycloak Filter org.keycloak.adapters.saml.servlet.SamlFilter keycloak.config.resolver example.SamlMultiTenantResolver 3.1.7. 注册身份提供商 对于每个基于servlet的适配器，您注册断言使用者服务URL和单个注销服务的端点必须是附加了/saml的servlet应用程序的基本URL，即https://example.com/contextPath/saml。 3.1.8. 注销 您可以通过多种方式从Web应用程序注销。 对于Java EE servlet容器，可以调用HttpServletRequest.logout()。 对于任何其他浏览器应用程序，您可以将浏览器指向具有安全约束的Web应用程序的任何URL，并传入查询参数GLO，即http://myapp?GLO=true。 如果您的浏览器有SSO会话，这将退出。 在群集环境中注销 在内部，SAML适配器存储SAML会话索引，主体名称（已知）和HTTP会话ID之间的映射。 可以在群集中为可分发的应用程序在JBoss应用程序服务器系列（WildFly 10/11，EAP 6/7）中维护此映射。 作为前提条件，HTTP会话需要跨集群分布（即应用程序在应用程序的web.xml中标有标签）。 要启用该功能，请将以下部分添加到/WEB_INF/web.xml文件中： 对于 EAP 7, WildFly 10/11: keycloak.sessionIdMapperUpdater.classes org.keycloak.adapters.saml.wildfly.infinispan.InfinispanSessionCacheIdMapperUpdater 对于 EAP 6: keycloak.sessionIdMapperUpdater.classes org.keycloak.adapters.saml.jbossweb.infinispan.InfinispanSessionCacheIdMapperUpdater 如果部署的会话缓存名为*deployment-cache*，则用于SAML映射的缓存将命名为*deployment-cache*.ssoCache。 缓存的名称可以被上下文参数keycloak.sessionIdMapperUpdater.infinispan.cacheName覆盖。 包含缓存的缓存容器将与包含部署会话缓存的缓存容器相同，但可以由上下文参数keycloak.sessionIdMapperUpdater.infinispan.containerName覆盖。 默认情况下，SAML映射缓存的配置将从会话缓存中派生。 可以在服务器的缓存配置部分中手动覆盖配置，就像其他缓存一样。 目前，为了提供可靠的服务，建议为SAML会话缓存使用复制缓存。 使用分布式缓存可能会导致SAML注销请求落到某个节点而无法访问SAM会话索引到HTTP会话映射的结果，从而导致注销失败。 在Cross DC场景中注销 交叉DC场景仅适用于WildFly 10及更高版本，以及EAP 7及更高版本。 处理跨多个数据中心的会话需要特殊处理。 想象一下以下场景： 登录请求在数据中心1的集群内处理。 管理员发出特定SAML会话的注销请求，请求登陆数据中心2。 数据中心2必须注销数据中心1中存在的所有会话（以及共享HTTP会话的所有其他数据中心）。 为了涵盖这种情况，上面 描述的SAML会话缓存,不仅需要在单个群集中复制，还需要在所有数据中复制 中心，例如 通过独立的Infinispan/JDG服务器： 必须将缓存添加到独立的Infinispan/JDG服务器。 必须将先前项目的缓存添加为相应SAML会话缓存的远程存储。 在部署期间发现SAML会话高速缓存存在远程存储后，将监视其更改并相应地更新本地SAML会话高速缓存。 3.1.9. 获取断言属性 成功进行SAML登录后，您的应用程序代码可能希望获取通过SAML断言传递的属性值。 HttpServletRequest.getUserPrincipal()返回一个Principal对象，您可以将其转换为名为org.keycloak.adapters.saml.SamlPrincipal的Keycloak特定类。 此对象允许您查看原始断言，并具有查找属性值的便捷功能。 package org.keycloak.adapters.saml; public class SamlPrincipal implements Serializable, Principal { /** * Get full saml assertion * * @return */ public AssertionType getAssertion() { ... } /** * Get SAML subject sent in assertion * * @return */ public String getSamlSubject() { ... } /** * Subject nameID format * * @return */ public String getNameIDFormat() { ... } @Override public String getName() { ... } /** * Convenience function that gets Attribute value by attribute name * * @param name * @return */ public List getAttributes(String name) { ... } /** * Convenience function that gets Attribute value by attribute friendly name * * @param friendlyName * @return */ public List getFriendlyAttributes(String friendlyName) { ... } /** * Convenience function that gets first value of an attribute by attribute name * * @param name * @return */ public String getAttribute(String name) { ... } /** * Convenience function that gets first value of an attribute by attribute name * * * @param friendlyName * @return */ public String getFriendlyAttribute(String friendlyName) { ... } /** * Get set of all assertion attribute names * * @return */ public Set getAttributeNames() { ... } /** * Get set of all assertion friendly attribute names * * @return */ public Set getFriendlyNames() { ... } } 3.1.10. 错误处理 Keycloak为基于servlet的客户端适配器提供了一些错误处理功能。 在身份验证中遇到错误时，客户端适配器将调用HttpServletResponse.sendError()。 您可以在web.xml文件中设置error-page来处理您想要的错误。 客户端适配器可能会抛出400,401,403和500错误。 403 /ErrorHandler 客户端适配器还设置了可以检索的HttpServletRequest属性。 属性名称是org.keycloak.adapters.spi.AuthenticationError。 Typecast这个对象：org.keycloak.adapters.saml.SamlAuthenticationError。 这个类可以告诉你到底发生了什么。 如果未设置此属性，则适配器不对错误代码负责。 public class SamlAuthenticationError implements AuthenticationError { public static enum Reason { EXTRACTION_FAILURE, INVALID_SIGNATURE, ERROR_STATUS } public Reason getReason() { return reason; } public StatusResponseType getStatus() { return status; } } 3.1.11. 故障排除 解决问题的最佳方法是在客户端适配器和Keycloak Server中打开SAML的调试。 使用您的日志记录框架，将日志级别设置为org.keycloak.samlpackage的DEBUG。 启用此选项可以查看发送到服务器和从服务器发送的SAML请求和响应文档。 3.1.12. 多租户 SAML为多租户提供与OIDC相同的功能，这意味着可以使用多个安全保护单个目标应用程序（WAR） Keycloak领域。 领域可以位于同一个Keycloak实例上，也可以位于不同的实例上。 为此，应用程序必须具有多个keycloak-saml.xml适配器配置文件。 虽然您可以将WAR的多个实例与不同的适配器配置文件部署到不同的上下文路径，但这可能不方便，您可能还希望根据context-path之外的其他内容选择域。 Keycloak可以使用自定义配置解析器，因此您可以选择为每个请求使用哪个适配器配置。 在SAML中，配置仅在登录处理中很有意义; 一旦用户登录，会话就会被验证，并且返回的keycloak-saml.xml是不同的并不重要。 因此，为同一会话返回相同的配置是正确的方法。 为此，请创建org.keycloak.adapters.saml.SamlConfigResolver的实现。 下面的示例使用Host标头来定位正确的配置并加载它以及应用程序的Java类路径中的相关元素： package example; import java.io.InputStream; import org.keycloak.adapters.saml.SamlConfigResolver; import org.keycloak.adapters.saml.SamlDeployment; import org.keycloak.adapters.saml.config.parsers.DeploymentBuilder; import org.keycloak.adapters.saml.config.parsers.ResourceLoader; import org.keycloak.adapters.spi.HttpFacade; import org.keycloak.saml.common.exceptions.ParsingException; public class SamlMultiTenantResolver implements SamlConfigResolver { @Override public SamlDeployment resolve(HttpFacade.Request request) { String host = request.getHeader(\"Host\"); String realm = null; if (host.contains(\"tenant1\")) { realm = \"tenant1\"; } else if (host.contains(\"tenant2\")) { realm = \"tenant2\"; } else { throw new IllegalStateException(\"Not able to guess the keycloak-saml.xml to load\"); } InputStream is = getClass().getResourceAsStream(\"/\" + realm + \"-keycloak-saml.xml\"); if (is == null) { throw new IllegalStateException(\"Not able to find the file /\" + realm + \"-keycloak-saml.xml\"); } ResourceLoader loader = new ResourceLoader() { @Override public InputStream getResourceAsStream(String path) { return getClass().getResourceAsStream(path); } }; try { return new DeploymentBuilder().build(is, loader); } catch (ParsingException e) { throw new IllegalStateException(\"Cannot load SAML deployment\", e); } } } 您还必须在web.xml中配置与keycloak.config.resolvercontext-param一起使用的SamlConfigResolver实现： ... keycloak.config.resolver example.SamlMultiTenantResolver 3.1.13. 从旧版本迁移 迁移到1.9.0 SAML SP 客户端 适配器更改 Keycloak SAML SP客户端适配器现在需要一个特定的端点，/saml将在您的IdP中注册。 除了它具有的任何其他绑定之外，SamlFilter还必须绑定到/saml。 必须这样做，因为SAML POST绑定会占用请求输入流，这对依赖它的客户来说真的很糟糕。 3.2. mod_auth_mellon Apache HTTPD 模块 mod_auth_mellon 模块是SAML的Apache HTTPD插件。 如果您的语言/环境支持使用Apache HTTPD作为代理，那么您可以使用mod_auth_mellon通过SAML保护您的Web应用程序。 有关此模块的更多详细信息，请参阅mod_auth_mellon GitHub 仓库。 要配置mod_auth_mellon，您需要： 身份提供者（IdP）实体描述符XML文件，描述与Keycloak或其他SAML IdP的连接 SP实体描述符XML文件，描述您正在保护的应用程序的SAML连接和配置。 私钥PEM文件，它是PEM格式的文本文件，用于定义应用程序用于签署文档的私钥。 证书PEM文件，它是一个文本文件，用于定义应用程序的证书。 mod_auth_mellon 特定的Apache HTTPD模块配置。 如果您已经在Keycloak应用程序服务器的领域内定义并注册了客户端应用程序，则Keycloak可以生成除Apache HTTPD模块配置之外所需的所有文件。 要生成Apache HTTPD模块配置，请完成以下步骤： 转到SAML客户端的“安装”页面，然后选择“Mod Auth Mellon files”选项。 mod_auth_mellon 配置下载 单击Download以下载包含所需XML描述符和PEM文件的zip文件。 3.2.1. 使用Keycloak配置mod_auth_mellon 涉及两个主机： 运行Keycloak的主机，将被称为$idp_host，因为Keycloak是SAML身份提供程序（IdP）。 运行Web应用程序的主机，将称为$sp_host。 在SAML中，使用IdP的应用程序称为服务提供者（SP）。 需要在具有root权限的$sp_host上执行以下所有步骤。 安装包 要安装必要的软件包，您需要： Apache Web服务器 (httpd) 用于Apache的Mellon SAML SP附加模块 用于创建X509证书的工具 要安装必要的软件包，请运行以下命令： yum install httpd mod_auth_mellon mod_ssl openssl 为Apache SAML创建配置目录 建议在一个位置保留与Apache使用SAML相关的配置文件。 在Apache配置root /etc/httpd下创建一个名为saml2的新目录： mkdir /etc/httpd/saml2 配置Mellon服务提供商 Apache附加模块的配置文件位于/etc/httpd/conf.d目录中，文件扩展名为.conf。 您需要创建/etc/httpd/conf.d/mellon.conf文件并将Mellon的配置指令放入其中。 Mellon’s配置指令大致可以分为两类信息： 使用SAML身份验证保护哪些URL 引用受保护的URL时将使用哪些SAML参数。 Apache配置指令通常遵循URL空间中的分层树结构，称为位置。 您需要为Mellon指定一个或多个URL位置以进行保护。 您可以灵活地添加适用于每个位置的配置参数。 您可以将所有必需参数添加到位置块，也可以将Mellon参数添加到特定受保护位置继承的URL位置层次结构中的公共位置（或两者的某种组合）。 由于无论哪个位置触发SAML操作，SP都以相同的方式操作，这里使用的示例配置将常用的Mellon配置指令放在层次结构的根中，然后可以使用Mellon保护的特定位置定义 最小指令。 此策略避免为每个受保护位置复制相同的参数。 此示例只有一个受保护的位置:https://$sp_host/protected。 要配置Mellon服务提供商，请完成以下步骤： 使用以下内容创建文件/etc/httpd/conf.d/mellon.conf： MellonEnable info MellonEndpointPath /mellon/ MellonSPMetadataFile /etc/httpd/saml2/mellon_metadata.xml MellonSPPrivateKeyFile /etc/httpd/saml2/mellon.key MellonSPCertFile /etc/httpd/saml2/mellon.crt MellonIdPMetadataFile /etc/httpd/saml2/idp_metadata.xml AuthType Mellon MellonEnable auth Require valid-user 上面代码中引用的某些文件是在后面的步骤中创建的。 创建服务提供者元数据 在SAML中，IdP和SP交换SAML元数据，这是XML格式的。 元数据的模式是标准，因此确保参与的SAML实体可以消耗彼此的元数据。 你需要： SP使用的IdP的元数据 描述提供给IdP的SP的元数据 SAML元数据的一个组件是X509证书。 这些证书用于两个目的： 签署SAML消息，以便接收端可以证明消息来自预期的一方。 在传输过程中加密消息（很少使用，因为SAML消息通常发生在受TLS保护的传输上） 如果您已拥有证书颁发机构（CA），则可以使用自己的证书，也可以生成自签名证书。 为简单起见，在此示例中使用自签名证书。 因为Mellon的SP元数据必须反映已安装的mod_auth_mellon版本的功能，所以必须是有效的SP元数据XML，并且必须包含X509证书（除非您熟悉X509证书生成，否则其创建可能是钝的）是生成 SP元数据将使用mod_auth_mellon包中包含的工具（mellon_create_metadata.sh）。 生成的元数据总是可以在以后编辑，因为它是一个文本文件。 该工具还会创建您的X509密钥和证书。 SAML IdP和SP使用称为EntityID的唯一名称来标识自己。 要使用Mellon元数据创建工具，您需要： EntityID，通常是SP的URL，通常是可以检索SP元数据的SP的URL 将使用SP的SAML消息的URL，Mellon将其称为MellonEndPointPath。 要创建SP元数据，请完成以下步骤： 创建一些辅助shell变量： fqdn=`hostname` mellon_endpoint_url=\"https://${fqdn}/mellon\" mellon_entity_id=\"${mellon_endpoint_url}/metadata\" file_prefix=\"$(echo \"$mellon_entity_id\" | sed 's/[^A-Za-z.]/_/g' | sed 's/__*/_/g')\" 通过运行以下命令调用Mellon元数据创建工具： /usr/libexec/mod_auth_mellon/mellon_create_metadata.sh $mellon_entity_id $mellon_endpoint_url 将生成的文件移动到目标位置（在上面创建的/etc/httpd/conf.d/mellon.conf文件中引用）： mv ${file_prefix}.cert /etc/httpd/saml2/mellon.crt mv ${file_prefix}.key /etc/httpd/saml2/mellon.key mv ${file_prefix}.xml /etc/httpd/saml2/mellon_metadata.xml 将Mellon服务提供商添加到Keycloak身份提供商 假设：Keycloak IdP已经安装在$idp_host上。 Keycloak支持多租户，其中所有用户，客户等都被分组在所谓的领域中。 每个领域都独立于其他领域。 您可以在Keycloak中使用现有领域，但此示例显示如何创建名为test_realm的新领域并使用该领域。 所有这些操作都是使用Keycloak管理Web控制台执行的。 您必须拥有$idp_host的管理员用户名和密码。 要完成以下步骤： 打开管理控制台，然后输入管理员用户名和密码登录。 登录管理控制台后，将存在现有领域。 首次设置Keycloak时，默认情况下会创建一个根域master。 任何以前创建的域都在管理控制台的左上角列在下拉列表中。 从领域下拉列表中选择Add realm。 在Name字段中输入test_realm并单击Create。 将Mellon服务提供程序添加为领域的客户端 在Keycloak中，SAML SP称为客户端。 要添加SP，我们必须位于领域的“客户端”部分。 单击左侧的“客户端”菜单项，然后单击右上角的“Create”以创建新客户端。 添加Mellon SP客户端 要添加Mellon SP客户端，请完成以下步骤： 将客户端协议设置为SAML。 从客户端协议下拉列表中，选择saml。 提供上面创建的Mellon SP元数据文件(/etc/httpd/saml2/mellon_metadata.xml)。 根据浏览器的运行位置，您可能必须将SP元数据从$sp_host复制到运行浏览器的计算机，以便浏览器可以找到该文件。 点击 Save. 编辑Mellon SP客户端 我们建议设置几个客户端配置参数： 确保\"Force POST Binding\"处于打开状态。 将paosResponse添加到Valid Redirect URIs列表中： 复制\"Valid Redirect URIs\"中的postResponse URL并将其粘贴到\"+\"下方的空添加文本字段中。 将“postResponse”更改为“paosResponse”。 （SAML ECP需要paosResponse URL。） 点击底部的Save。 许多SAML SP根据用户在组中的成员身份确定授权。 Keycloak IdP可以管理用户组信息，但它不提供用户的组，除非IdP配置为将其作为SAML属性提供。 要配置IdP以将用户组作为SAML属性提供，请完成以下步骤： 单击客户端的Mappers选项卡。 在Mappers页面的右上角，单击Create。 从Mapper Type下拉列表中选择Group list。 将名称设置为“group list”。 将SAML属性名称设置为“groups”。 点击 Save. 其余步骤在$sp_host上执行。 检索身份提供程序元数据 现在您已经在IdP上创建了领域，您需要检索与其关联的IdP元数据，以便Mellon SP识别它。 在先前创建的/etc/httpd/conf.d/mellon.conf文件中，MellonIdPMetadataFile指定为/etc/httpd/saml2/idp_metadata.xml，但直到现在该文件在$ sp_host上不存在。 要获取该文件，我们将从IdP中检索它。 通过用$idp_host替换正确的值来从IdP中检索文件： curl -k -o /etc/httpd/saml2/idp_metadata.xml \\ https://$idp_host/auth/realms/test_realm/protocol/saml/descriptor Mellon 现已完全配置。 要运行Apache配置文件的语法检查： apachectl configtest Configtest等同于apachectl的-t参数。 如果配置测试显示任何错误，请在继续之前更正它们。 重启Apache服务器： systemctl restart httpd.service 您现在已将testcalm中的Keycloak设置为SAML IdP，将mod_auth_mellon设置为SAML SP，通过对$idp_hostIdP进行身份验证来保护URL $sp_host/protected（及其下的所有内容）。 4. Docker注册表配置 默认情况下禁用Docker身份验证。 要启用，请参阅Profiles。 本节介绍如何配置Docker注册表以将Keycloak用作其身份验证服务器。 有关如何设置和配置Docker注册表的更多信息，请参阅Docker注册表配置指南。 4.1. Docker注册表配置文件安装 对于具有更高级Docker注册表配置的用户，通常建议您提供自己的注册表配置文件。 Keycloak Docker提供程序通过Registry Config File 格式化选项支持此机制。 选择此选项将生成类似于以下内容的输出： auth: token: realm: http://localhost:8080/auth/realms/master/protocol/docker-v2/auth service: docker-test issuer: http://localhost:8080/auth/realms/master 然后可以将此输出复制到任何现有的注册表配置文件中。 有关如何设置文件的更多信息，请参阅注册表配置文件规范，或者以基本示例开头。 不要忘记使用Keycloak领域的pulic证书的位置配置rootcertbundle字段。 没有此参数，auth配置将不起作用。 4.2. Docker注册表环境变量覆盖安装 通常，对开发或POC Docker注册表使用简单的环境变量覆盖是合适的。 虽然这种方法通常不建议用于生产用途，但是当需要快速而肮脏的方式来建立注册表时，它可能会有所帮助。 只需使用客户端安装选项卡中的Variable Override 格式选项，输出应如下所示： REGISTRY_AUTH_TOKEN_REALM: http://localhost:8080/auth/realms/master/protocol/docker-v2/auth REGISTRY_AUTH_TOKEN_SERVICE: docker-test REGISTRY_AUTH_TOKEN_ISSUER: http://localhost:8080/auth/realms/master 不要忘记使用Keycloak领域的pulic证书的位置配置REGISTRY_AUTH_TOKEN_ROOTCERTBUNDLE覆盖。 没有此参数，auth配置将不起作用。 4.3. Docker撰写YAML文件 此安装方法旨在让docker注册表针对Keycloak服务器进行身份验证。 它仅用于开发目的，不应在生产或类似生产的环境中使用。 zip文件安装机制为想要了解Keycloak服务器如何与Docker注册表进行交互的开发人员提供了快速入门。 为了配置： 从所需的领域，创建客户端配置。 此时您将没有Docker注册表 - 快速入门将负责该部分。 从安装选项卡中选择“Docker Compose YAML”选项并下载.zip文件 将存档解压缩到所需位置，然后打开目录。 使用docker-compose up启动Docker注册表 建议您在master以外的域中配置Docker注册表客户端，因为HTTP Basic身份验证流程不会显示表单。 完成上述配置，并且keycloak服务器和Docker注册表正在运行时，docker身份验证应该成功： [user ~]#??docker login localhost:5000 -u $username Password: ******* Login Succeeded 5. 客户端注册 为了使应用程序或服务能够使用Keycloak，它必须在Keycloak中注册客户端。 管理员可以通过管理控制台（或管理员REST端点）执行此操作，但客户端也可以通过Keycloak客户端注册服务注册自己。 客户注册服务为Keycloak客户端表示，OpenID Connect客户端元数据和SAML实体描述符提供内置支持。 客户端注册服务端点是/auth/realms//clients-registrations/。 内置支持的providers是： default - Keycloak客户端表示 (JSON) install - Keycloak适配器配置 (JSON) openid-connect - OpenID Connect客户端元数据描述 (JSON) saml2-entity-descriptor - SAML实体描述符 (XML) 以下部分将介绍如何使用不同的提供程序。 5.1. 认证 要调用客户端注册服务，通常需要令牌。 令牌可以是承载令牌，初始访问令牌或注册访问令牌。 有一种替代方案可以在没有任何令牌的情况下注册新客户端，但是您需要配置客户端注册策略（见下文）。 5.1.1. 承载令牌 可以代表用户或服务帐户发出承载令牌。 调用端点需要以下权限（有关详细信息，请参阅服务器管理指南 for more details)）： create-client或manage-client - 创建客户端 view-client或manage-client - 查看客户端 manage-client - 更新或删除客户端 如果您使用不记名令牌来创建客户端，建议使用仅具有“create-client”角色的服务帐户中的令牌（请参阅服务器管理指南了解更多详情）。 5.1.2. 初始访问令牌 注册新客户端的推荐方法是使用初始访问令牌。 初始访问令牌只能用于创建客户端，并且具有可配置的到期时间以及可以创建的客户端数量的可配置限制。 可以通过管理控制台创建初始访问令牌。 要创建新的初始访问令牌，首先在管理控制台中选择域，然后单击左侧菜单中的Realm Settings，然后单击页面中显示的选项卡中的Client Registration。 然后最后点击Initial Access Tokens子标签。 您现在可以看到任何现有的初始访问令牌。 如果您有权访问权限，则可以删除不再需要的令牌。 您只能在创建令牌时检索令牌的值。 要创建新标记，请单击Create。 您现在可以选择添加令牌有效的时间，也可以使用令牌创建多少客户端。 单击Save后，将显示标记值。 现在复制/粘贴此令牌非常重要，因为以后您将无法检索它。 如果您忘记复制/粘贴它，则删除令牌并创建另一个令牌。 通过将客户端注册服务添加到请求中的Authorization标头，令牌值在调用客户端注册服务时用作标准承载令牌。 例如： Authorization: bearer eyJhbGciOiJSUz... 5.1.3. 注册访问令牌 通过客户端注册服务创建客户端时，响应将包括注册访问令牌。 注册访问令牌提供访问权限以便稍后检索客户端配置，还可以更新或删除客户端。 注册访问令牌以与承载令牌或初始访问令牌相同的方式包含在请求中。 注册访问令牌仅有效一次，当使用时，响应将包含新令牌。 如果客户端是在客户端注册服务之外创建的，则它将没有与之关联的注册访问令牌。 您可以通过管理控制台创建一个。 如果您丢失特定客户端的令牌，这也很有用。 要创建新令牌，请在管理控制台中找到客户端，然后单击Credentials。 然后单击Generate registration access token。 5.2. Keycloak表示 default客户端注册提供程序可用于创建，检索，更新和删除客户端。 它使用Keycloak客户端表示格式，该格式为通过管理控制台配置客户端提供了完全配置支持，包括配置协议映射器。 要创建客户端，请创建客户端表示（JSON），然后对/auth/realms//clients-registrations/default执行HTTP POST请求。 它将返回一个客户端表示，其中还包括注册访问令牌。 如果要稍后检索配置，更新或删除客户端，则应将注册访问令牌保存在某处。 要检索客户端表示，请对/auth/realms//clients-registrations/default/执行HTTP GET请求。 它还将返回一个新的注册访问令牌。 要更新客户端表示，请使用更新的客户端表示执行HTTP PUT请求：/auth/realms//clients-registrations/default/。 它还将返回一个新的注册访问令牌。 要删除客户端表示，请执行HTTP DELETE请求：/auth/realms//clients-registrations/default/ 5.3. Keycloak适配器配置 installation客户端注册提供程序可用于检索客户端的适配器配置。 除了令牌身份验证，您还可以使用HTTP基本身份验证对客户端凭据进行身份验证。 为此，请在请求中包含以下标头： Authorization: basic BASE64(client-id + ':' + client-secret) 要检索适配器配置，然后对/auth/realms//clients-registrations/install/执行HTTP GET请求。 公共客户端无需身份验证。 这意味着对于JavaScript适配器，您可以使用上述URL直接从Keycloak加载客户端配置。 5.4. OpenID连接动态客户端注册 Keycloak实现了OpenID Connect动态客户端注册，它扩展了OAuth 2.0动态客户端注册协议和OAuth 2.0动态客户端注册管理协议。 使用这些规范在Keycloak中注册客户端的端点是/auth/realms//clients-registrations/openid-connect[/]。 此端点也可以在域的OpenID Connect Discovery端点中找到，/auth/realms//.well-known/openid-configuration。 5.5. SAML实体描述符 SAML实体描述符端点仅支持使用SAML v2实体描述符来创建客户端。 它不支持检索，更新或删除客户端。 对于这些操作，应使用Keycloak表示端点。 创建客户端时，将返回Keycloak Client Representation，其中包含有关已创建客户端的详细信息，包括注册访问令牌。 要创建客户端，请使用SAML实体描述符对/auth/realms//clients-registrations/saml2-entity-descriptor执行HTTP POST请求。 5.6. 使用CURL的示例 以下示例使用CURL使用clientIdmyclient创建客户端。 您需要使用正确的初始访问令牌或承载令牌替换eyJhbGciOiJSUz ...。 curl -X POST \\ -d '{ \"clientId\": \"myclient\" }' \\ -H \"Content-Type:application/json\" \\ -H \"Authorization: bearer eyJhbGciOiJSUz...\" \\ http://localhost:8080/auth/realms/master/clients-registrations/default 5.7. 使用Java客户端注册API的示例 客户端注册Java API可以使用Java轻松使用客户端注册服务。 要使用包含来自Maven的依赖项org.keycloak:keycloak-client-registration-api:>VERSION。 有关使用客户端注册的完整说明，请参阅JavaDocs。 以下是创建客户端的示例。 您需要使用正确的初始访问令牌或承载令牌替换eyJhbGciOiJSUz ...。 String token = \"eyJhbGciOiJSUz...\"; ClientRepresentation client = new ClientRepresentation(); client.setClientId(CLIENT_ID); ClientRegistration reg = ClientRegistration.create() .url(\"http://localhost:8080/auth\", \"myrealm\") .build(); reg.auth(Auth.token(token)); client = reg.create(client); String registrationAccessToken = client.getRegistrationAccessToken(); 5.8. 客户端注册政策 Keycloak目前支持2种方式如何通过客户注册服务注册新客户。 经过身份验证的请求 - 注册新客户端的请求必须包含上面提到的Initial Access Token(初始访问令牌) 或 Bearer Token(承载令牌)。 匿名请求 - 注册新客户端的请求根本不需要包含任何令牌 匿名客户端注册请求是非常有趣和强大的功能，但是您通常不希望任何人能够无任何限制地注册新客户端。 因此，我们有“客户注册策略SPI”，它提供了一种限制谁可以注册新客户以及在何种条件下的方法。 在Keycloak管理控制台中，您可以单击Client Registration(客户端注册)选项卡，然后单击“客户端注册策略”子选项卡。 在这里，您将看到默认情况下为匿名请求配置了哪些策略，以及为经过身份验证的请求配置了哪些策略。 匿名请求（没有任何令牌的请求）仅允许创建（注册）新客户端。 因此，当您通过匿名请求注册新客户端时，响应将包含注册访问令牌，该令牌必须用于特定客户端的读取，更新或删除请求。 但是，使用匿名注册的注册访问令牌也将受到匿名策略的约束！ 这意味着，例如，如果您具有Trusted Hosts(可信主机)策略，则更新客户端的请求也需要来自可信主机。 另外，例如，在更新客户端以及存在Consent Required(同意所需)策略时，将不允许禁用Consent Required(同意所需)等。 目前我们有这些策略实施： Trusted Hosts Policy(可信主机策略) - 您可以配置可信主机和可信域的列表。 可以从这些主机或域发送对客户注册服务的请求。 某些不受信任的IP发送的请求将被拒绝。 新注册客户端的URL也必须仅使用那些可信主机或域。 例如，不允许将客户端的“重定向URI”设置为指向某个不受信任的主机。 默认情况下，没有任何列入白名单的主机，因此事实上禁用匿名客户端注册。 Consent Required Policy(需要同意策略) - 新注册的客户端将启用Consent Allowed(允许同意)切换。 因此，在成功进行身份验证后，用户在需要批准权限（客户端范围）时将始终看到同意屏幕。 这意味着除非用户批准，否则客户端将无法访问任何个人信息或用户的许可。 Protocol Mappers Policy(协议映射器策略) - 允许配置列入白名单的协议映射器实现。 如果新客户端包含一些非白名单的协议映射器，则无法注册或更新新客户端。 请注意，此策略也用于经过身份验证的请求，因此即使对于经过身份验证的请求，也存在可以使用协议映射器的一些限制。 Client Scope Policy(客户端范围策略) - 允许将Client Scopes(客户端范围)列入白名单，可以与新注册或更新的客户端一起使用。 默认情况下，没有列入白名单的范围; 只有客户端作用域（定义为Realm Default Client Scopes）默认列入白名单。 Full Scope Policy(全范围策略) - 新注册的客户端将禁用Full Scope Allowed(允许全范围)开关。 这意味着他们将不具有任何作用域领域角色或其他客户端的客户角色。 Max Clients Policy(最大客户端策略) - 如果域中的当前客户端数量大于指定限制，则拒绝注册。 匿名注册默认为200。 Client Disabled Policy(客户端已禁用策略) - 将禁用新注册的客户端。 这意味着管理员需要手动批准并启用所有新注册的客户端。 即使是匿名注册，也不会默认使用此策略。 6. 客户端注册 CLI 客户端注册CLI是一个命令行界面（CLI）工具，供应用程序开发人员在与Keycloak集成时以自助服务方式配置新客户端。 它专门设计用于与Keycloak客户端注册REST端点交互。 必须为任何能够使用Keycloak的应用程序创建或获取客户端配置。 您通常为托管在唯一主机名上的每个新应用程序配置新客户端。 当应用程序与Keycloak交互时，应用程序使用客户端ID识别自身，因此Keycloak可以提供登录页面，单点登录（SSO）会话管理和其他服务。 您可以使用客户端注册CLI从命令行配置应用程序客户端，并且可以在shell脚本中使用它。 为了允许特定用户使用客户端注册CLI，Keycloak管理员通常使用管理控制台配置具有适当角色的新用户，或者配置新客户端和客户端密钥以授予对客户端注册REST API的访问权限。 6.1. 配置新常规用户以使用客户端注册CLI 以admin身份登录管理控制台（例如http://localhost:8080/auth/admin）。 选择要管理的领域。 如果要使用现有用户，请选择要编辑的用户; 否则，创建一个新用户。 选择Role Mappings > Client Roles > realm-management。 如果您在主域中，请选择NAME-realm，其中NAME是目标域的名称。 您可以向主域中的用户授予对任何其他域的访问权限。 选择Available Roles>manage-client以授予一整套客户端管理权限。 另一个选择是选择view-clients为只读或create-client来创建新客户。 这些权限授予用户执行操作的能力，而无需使用初始访问令牌或注册访问令牌。 可以不向用户分配任何realm-management角色。 在这种情况下，用户仍然可以使用客户端注册CLI登录，但如果没有初始访问令牌，则无法使用它。 尝试在没有令牌的情况下执行任何操作会导致403 Forbidden错误。 管理员可以通过Realm Settings > Client Registration > Initial Access Token菜单从管理控制台发出初始访问令牌。 6.2. 配置客户端以与客户端注册CLI一起使用 默认情况下，服务器将客户端注册CLI识别为admin-cli客户端，该客户端为每个新域自动配置。 使用用户名登录时无需其他客户端配置。 如果要为客户端注册CLI使用单独的客户端配置，请创建新客户端（例如，reg-cli）。 切换Standard Flow Enabled将其设置为Off。 通过将客户端Access Type配置为Confidential并选择Credentials > ClientId and Secret来加强安全性。 您可以在Credentials选项卡下配置Client Id and Secret或Signed JWT。 如果要使用与客户端关联的服务帐户，请通过在Admin Console的Clients部分中选择要编辑的客户端来启用服务帐户。 在Settings下，将Access Type更改为Confidential，将Service Accounts Enabled设置切换为On，然后单击Save。 单击Service Account Roles并选择所需角色以配置服务帐户的访问权限。 有关要选择的角色的详细信息，请参阅配置用于客户端注册CLI的新常规用户。 切换Direct Access Grants Enabled将其设置为On，如果您要使用常规用户帐户而不是服务帐户。 如果客户端配置为Confidential，则在使用--secret选项运行kcreg config credentials时提供已配置的机密。 在运行kcreg config credentials时指定要使用的clientId（例如，--client reg-cli）。 启用服务帐户后，您可以在运行kcreg config credentials时省略指定用户，并仅提供客户端密钥或密钥库信息。 6.3. 安装客户端注册CLI 客户端注册CLI打包在Keycloak Server发行版中。 您可以在bin目录中找到执行脚本。 Linux脚本称为kcreg.sh，Windows脚本称为kcreg.bat。 在设置客户端以便从文件系统上的任何位置使用时，将Keycloak服务器目录添加到PATH。 例如，在： Linux: $ export PATH=$PATH:$KEYCLOAK_HOME/bin $ kcreg.sh Windows: c:\\> set PATH=%PATH%;%KEYCLOAK_HOME%\\bin c:\\> kcreg KEYCLOAK_HOME指的是解压缩Keycloak Server分发的目录。 6.4. 使用客户端注册CLI 通过使用您的凭据登录来启动经过身份验证的会话。 在Client Registration REST端点上运行命令。 例如，在： Linux: $ kcreg.sh config credentials --server http://localhost:8080/auth --realm demo --user user --client reg-cli $ kcreg.sh create -s clientId=my_client -s 'redirectUris=[\"http://localhost:8980/myapp/*\"]' $ kcreg.sh get my_client Windows: c:\\> kcreg config credentials --server http://localhost:8080/auth --realm demo --user user --client reg-cli c:\\> kcreg create -s clientId=my_client -s \"redirectUris=[\\\"http://localhost:8980/myapp/*\\\"]\" c:\\> kcreg get my_client 在生产环境中，必须使用https:访问Keycloak，以避免将令牌暴露给网络嗅探器。 如果服务器的证书不是由Java的默认证书信任库中包含的受信任证书颁发机构（CA）之一颁发的，请准备truststore.jks文件并指示客户端注册CLI使用它。 例如，在： Linux: $ kcreg.sh config truststore --trustpass $PASSWORD ~/.keycloak/truststore.jks Windows: c:\\> kcreg config truststore --trustpass %PASSWORD% %HOMEPATH%\\.keycloak\\truststore.jks 6.4.1. 登录 使用客户端注册CLI登录时，请指定服务器端点URL和域。 指定用户名或客户端ID，这将导致使用特殊服务帐户。 使用用户名时，必须使用指定用户的密码。 使用客户端ID时，使用客户端密钥或Signed JWT而不是密码。 无论登录方法如何，登录的帐户都需要适当的权限才能执行客户端注册操作。 请记住，非主域中的任何帐户只能拥有管理同一域内的客户端的权限。 如果需要管理不同的域，可以在不同的域中配置多个用户，也可以在master域中创建单个用户，并添加角色以管理不同领域的客户端。 您无法使用客户端注册CLI配置用户。 使用管理控制台Web界面或Admin Client CLI配置用户。 有关详细信息，请参阅服务器管理指南。 当kcreg成功登录时，它会接收授权令牌并将其保存在私有配置文件中，因此令牌可用于后续调用。 有关配置文件的详细信息，请参阅使用备用配置 。 有关使用客户端注册CLI的详细信息，请参阅内置帮助。 例如，在： Linux: $ kcreg.sh help Windows: c:\\> kcreg help 有关启动经过身份验证的会话的详细信息，请参阅kcreg config credentials --help。 6.4.2. 使用其他配置 默认情况下，客户端注册CLI会自动将配置文件维护在用户主目录下的默认位置./.keycloak/kcreg.config中。 您可以使用--config选项指向不同的文件或位置，以并行保存多个经过身份验证的会话。 这是从单个线程执行绑定到单个配置文件的操作的最安全的方法。 不要使配置文件对系统上的其他用户可见。 配置文件包含应保密的访问令牌和秘密。 您可能希望通过在所有命令中使用--no-config选项来避免在配置文件中存储机密，即使它不太方便并且需要更多令牌请求。 使用每个kcreg调用指定所有身份验证信息。 6.4.3. 初始访问和注册访问令牌 没有在他们想要使用的Keycloak服务器上配置帐户的开发人员可以使用客户端注册CLI。 仅当领域管理员向开发人员发出初始访问令牌时，才可能这样做。 由领域管理员决定如何以及何时发布和分发这些令牌。 领域管理员可以限制初始访问令牌的最长期限以及可以使用它创建的客户端总数。 一旦开发人员拥有初始访问令牌，开发人员就可以使用它来创建新客户端，而无需使用kcreg config credentials进行身份验证。 初始访问令牌可以存储在配置文件中，也可以作为kcreg create命令的一部分指定。 例如，在： Linux: $ kcreg.sh config initial-token $TOKEN $ kcreg.sh create -s clientId=myclient 或者 $ kcreg.sh create -s clientId=myclient -t $TOKEN Windows: c:\\> kcreg config initial-token %TOKEN% c:\\> kcreg create -s clientId=myclient 或者 c:\\> kcreg create -s clientId=myclient -t %TOKEN% 使用初始访问令牌时，服务器响应包括新发布的注册访问令牌。 该客户端的任何后续操作都需要通过使用该令牌进行身份验证来执行，该令牌仅对该客户端有效。 客户端注册CLI自动使用其专用配置文件来保存此标记并将其与其关联的客户端一起使用。 只要将相同的配置文件用于所有客户端操作，开发人员就无需进行身份验证即可读取，更新或删除以这种方式创建的客户端。 有关初始访问和注册访问令牌的详细信息，请参阅客户端注册。 运行kcreg config initial-token --help和kcreg config registration-token --help命令，以获取有关如何使用客户端注册CLI配置令牌的更多信息。 6.4.4. 创建客户端配置 使用凭据进行身份验证或配置初始访问令牌后的第一个任务通常是创建新客户端。 通常，您可能希望使用准备好的JSON文件作为模板，并设置或覆盖某些属性。 以下示例显示如何读取JSON文件，覆盖它可能包含的任何客户端ID，设置任何其他属性，以及在成功创建后将配置打印到标准输出。 Linux: $ kcreg.sh create -f client-template.json -s clientId=myclient -s baseUrl=/myclient -s 'redirectUris=[\"/myclient/*\"]' -o Windows: C:\\> kcreg create -f client-template.json -s clientId=myclient -s baseUrl=/myclient -s \"redirectUris=[\\\"/myclient/*\\\"]\" -o 有关kcreg create命令的更多信息，请运行kcreg create --help。 您可以使用kcreg attrs列出可用属性。 请记住，未检查许多配置属性的有效性或一致性。 您可以指定正确的值。 请记住，模板中不应包含任何id字段，也不应将它们指定为kcreg create命令的参数。 6.4.5. 检索客户端配置 您可以使用kcreg get命令检索现有客户端。 例如，在： Linux: $ kcreg.sh get myclient Windows: C:\\> kcreg get myclient 您还可以将客户端配置检索为适配器配置文件，您可以将其与Web应用程序打包在一起。 例如，在： Linux: $ kcreg.sh get myclient -e install > keycloak.json Windows: C:\\> kcreg get myclient -e install > keycloak.json 有关kcreg get命令的更多信息，请运行kcreg get --help命令。 6.4.6. 修改客户端配置 有两种更新客户端配置的方法。 一种方法是在获取当前配置，将其保存到文件，编辑它并将其发回服务器后，向服务器提交一个完整的新状态。 例如，在： Linux: $ kcreg.sh get myclient > myclient.json $ vi myclient.json $ kcreg.sh update myclient -f myclient.json Windows: C:\\> kcreg get myclient > myclient.json C:\\> notepad myclient.json C:\\> kcreg update myclient -f myclient.json 第二种方法获取当前客户端，设置或删除其上的字段，并在一个步骤中将其发回。 例如，在： Linux: $ kcreg.sh update myclient -s enabled=false -d redirectUris Windows: C:\\> kcreg update myclient -s enabled=false -d redirectUris 您还可以使用仅包含要应用的更改的文件，这样您就不必将太多值指定为参数。 在这种情况下，指定--merge告诉客户端注册CLI，而不是将JSON文件视为完整的新配置，它应将其视为要在现有配置上应用的一组属性。 例如，在： Linux: $ kcreg.sh update myclient --merge -d redirectUris -f mychanges.json Windows: C:\\> kcreg update myclient --merge -d redirectUris -f mychanges.json 有关kcreg update命令的更多信息，请运行kcreg update --help命令。 6.4.7. 删除客户端配置 使用以下示例删除客户端。 Linux: $ kcreg.sh delete myclient Windows: C:\\> kcreg delete myclient 有关kcreg delete命令的更多信息，请运行kcreg delete --help命令。 6.4.8. 刷新无效的注册访问令牌 使用--no-config模式执行创建，读取，更新和删除（CRUD）操作时，客户端注册CLI无法为您处理注册访问令牌。 在这种情况下，可能会丢失对客户端最近发布的注册访问令牌的跟踪，这使得无法在没有使用具有manage-clients权限的帐户进行身份验证的情况下在该客户端上执行任何进一步的CRUD操作。 如果您具有权限，则可以为客户端发出新的注册访问令牌，并将其打印到标准输出或保存到您选择的配置文件中。 否则，您必须要求领域管理员为您的客户发出新的注册访问令牌并将其发送给您。 然后，您可以通过--token选项将其传递给任何CRUD命令。 您还可以使用kcreg config registration-token命令将新令牌保存在配置文件中，并让客户端注册CLI从那时起自动为您处理。 有关kcreg update-token命令的更多信息，请运行kcreg update-token --help命令。 6.5. 故障排除 Q: 登录时，出现错误： *Parameter client_assertion_type is missing [invalid_client]. A: 此错误意味着您的客户端配置了Signed JWT(签名JWT)令牌凭据，这意味着您必须在登录时使用--keystore参数。 7. 令牌交换 令牌交换是技术预览，并不完全支持。 默认情况下禁用此功能。要启用-Dkeycloak.profile=preview 或 -Dkeycloak.profile.feature.token_exchange=enabled启动服务器。 有关详细信息，请参阅Profiles。 在Keycloak中，令牌交换是使用一组凭据或令牌来获取完全不同的令牌的过程。 客户端可能希望在不太受信任的应用程序上调用，因此它可能希望降级它具有的当前令牌。 客户端可能想要为存储用于链接的社交提供者帐户的令牌交换Keycloak令牌。 您可能希望信任由其他Keycloak领域或外国国内流离失所者铸造的外部令牌。 客户可能需要冒充用户。 以下是Keycloak围绕令牌交换的当前功能的简短摘要。 客户端可以交换为特定客户端创建的现有Keycloak令牌，以获取针对不同客户端的新令牌 客户端可以将现有的Keycloak令牌交换为外部令牌，即链接的Facebook帐户 客户端可以为Keycloak令牌交换外部令牌。 客户端可以冒充用户 Keycloak中的令牌交换是IETF中OAuth令牌交换规范的非常松散的实现。 我们已经扩展了一点，忽略了一些，并松散地解释了规范的其他部分。 它是领域的OpenID Connect令牌端点上的简单授权类型调用。 /auth/realms/{realm}/protocol/openid-connect/token 它接受表单参数（application / x-www-form-urlencoded）作为输入，输出取决于您请求交换的令牌类型。 令牌交换是客户端端点，因此请求必须为调用客户端提供身份验证信息。 公共客户端将其客户端标识符指定为表单参数。 机密客户端还可以使用表单参数来传递其客户端ID和密码，Basic Auth，或者您的管理员已在您的领域中配置了客户端身份验证流。 这是表单参数列表 client_id REQUIRED MAYBE. 使用表单参数进行身份验证的客户端需要此参数。 如果您使用的是Basic Auth，客户端JWT令牌或客户端证书身份验证，则不要指定此参数。 client_secret REQUIRED MAYBE. 对于使用表单参数进行身份验证并使用客户端机密作为凭据的客户端，此参数是必需的。 如果您的领域中的客户端调用通过其他方式进行身份验证，请不要指定此参数。 grant_type REQUIRED. 参数的值必须是urn:ietf:params:oauth:grant-type:token-exchange。 subject_token OPTIONAL. 代表正在进行请求的一方的身份的安全令牌。 如果您要为新的令牌交换现有令牌，则需要它。 subject_issuer OPTIONAL. 标识subject_token的发行者。 如果令牌来自当前领域，或者如果可以从subject_token_type确定发行者，则可以将其留空。 否则需要指定。 有效值是为您的领域配置的“身份提供者”的别名。 或者由特定Identity Provider配置的发行者声明标识符。 subject_token_type OPTIONAL. 此参数是使用subject_token参数传递的标记的类型。 如果subject_token来自领域并且是访问令牌，则默认为urn:ietf:params:oauth:token-type:access_token。 如果它是外部令牌，则可以根据subject_issuer的要求指定或不指定此参数。 requested_token_type OPTIONAL. 此参数表示客户端要交换的令牌类型。 目前仅支持oauth和OpenID Connect令牌类型。 这个的默认值取决于是urn:ietf:params:oauth:token-type:refresh_token在这种情况下，您将在响应中返回访问令牌和刷新令牌。 其他合适的值是urn:ietf:params:oauth:token-type:access_token 和 urn:ietf:params:oauth:token-type:id_token audience OPTIONAL. 此参数指定要为其生成新令牌的目标客户端。 requested_issuer OPTIONAL. 此参数指定客户端需要由外部提供者生成的令牌。它必须是在域中配置的Identity Provider的别名。 requested_subject OPTIONAL. 如果您的客户想要模仿其他用户，则指定用户名或用户ID。 scope NOT IMPLEMENTED. 此参数表示客户机请求的OAuth和OpenID连接范围的目标集。目前还没有实现，但是一旦Keycloak对范围有了更好的支持，它就会实现。 我们目前仅支持OpenID Connect和OAuth交换。 根据用户需求，将来可能会添加对基于SAML的客户端和身份提供商的支持。 来自交换调用的成功响应将返回HTTP 200响应代码，其内容类型取决于客户端要求的requested-token-type和requested_issuer。 OAuth请求的令牌类型将返回[OAuth令牌交换]（(https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16) 规范中所述的JSON文档。 { \"access_token\" : \".....\", \"refresh_token\" : \".....\", \"expires_in\" : \"....\" } 请求刷新令牌的客户端将在响应中返回访问和刷新令牌。 仅请求访问令牌类型的客户端将仅在响应中获取访问令牌。 对于通过requested_issuer参数请求外部发行者的客户，可以包括或不包括到期信息。 错误响应通常属于400 HTTP响应代码类别，但可能会返回其他错误状态代码，具体取决于错误的严重性。 错误响应可能包括取决于requested_issuer的内容。 基于OAuth的交换可能会返回JSON文档，如下所示： { \"error\" : \"....\" \"error_description\" : \"....\" } 可能会返回其他错误声明，具体取决于交换类型。 例如，如果用户没有指向身份提供者的链接，OAuth身份提供者可能会包含额外的account-link-url声明。 此链接可用于客户端发起的链接请求。 令牌交换设置需要了解细粒度管理员权限（有关详细信息，请参阅服务器管理指南）。 您需要授予客户交换的权限。 这将在本章后面讨论。 本章的其余部分讨论了设置要求，并提供了不同交换方案的示例。 为简单起见，让我们将当前领域铸造的令牌称为internal令牌，并将外部域或身份提供者铸造的令牌称为external令牌。 7.1. 内部令牌到内部令牌交换 通过令牌交换的内部令牌，您可以将现有令牌添加到特定客户端，并且您希望将此令牌交换为为不同目标客户端创建的新令牌。 你为什么想做这个？ 这通常发生在客户端为自己创建一个令牌时，并且需要向访问令牌中需要不同声明和权限的其他应用程序发出其他请求。 可能需要此类交换的其他原因是，如果您需要执行“permission downgrade(权限降级)”，您的应用需要在不太受信任的应用上调用，并且您不希望传播当前的访问令牌。 7.1.1. 授予Exchange权限 想要为不同客户端交换令牌的客户端需要在管理控制台中进行授权才能这样做。 您需要在要获得权限交换的目标客户端中定义token-exchange细粒度权限。 目标客户端权限 将Permissions Enabled开关切换为ON。 目标客户端权限 您应该在页面上看到token-exchange链接。 单击该开始定义权限。 它会带你到这个页面。 目标客户端Exchange权限设置 您必须为此权限定义策略。 单击Authorization链接，转到Policies选项卡并创建Client策略。 客户端策略创建 在此处输入起始客户端，即请求令牌交换的经过身份验证的客户端。 创建此策略后，返回目标客户端的token-exchange权限并添加刚刚定义的客户端策略。 应用客户端策略 您的客户现在有权调用。 如果您没有正确执行此操作，如果您尝试进行交换，则会收到403 Forbidden响应。 7.1.2. 提出请求 当您的客户端为指向另一个客户端的令牌交换现有令牌时，您必须使用audience参数。 此参数必须是您在管理控制台中配置的目标客户端的客户端标识符。 curl -X POST \\ -d \"client_id=starting-client\" \\ -d \"client_secret=geheim\" \\ --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\ -d \"subject_token=....\" \\ --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:refresh_token\" \\ -d \"audience=target-client\" \\ http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token subject_token参数必须是目标领域的访问令牌。 如果您的requested_token_type参数是刷新令牌类型，则响应将包含访问令牌，刷新令牌和到期。 这是您从此调用中获得的示例JSON响应。 { \"access_token\" : \"....\", \"refresh_token\" : \"....\", \"expires_in\" : 3600 } 7.2. 外部令牌交换的内部令牌 您可以为外部身份提供者创建的外部令牌交换领域令牌。 必须在管理控制台的“身份提供程序”部分中配置此外部身份提供程序。 目前仅支持基于OAuth/OpenID Connect的外部身份提供商，这包括所有社交提供商。 Keycloak不会向外部提供商执行反向信道交换。 因此，如果帐户未链接，您将无法获得外部令牌。 为了能够获得外部令牌，必须满足以下条件之一： 用户必须至少使用外部身份提供商登录一次 用户必须通过用户帐户服务与外部身份提供商链接 用户帐户使用客户端启动的帐户链接API通过外部身份提供商进行链接。 最后，外部身份提供程序必须已配置为存储令牌，或者，必须使用与要交换的内部令牌相同的用户会话执行上述操作之一。 如果帐户未链接，则交换响应将包含可用于建立帐户的链接。 这将在发出请求部分中进行更多讨论。 7.2.1. 授予Exchange权限 在您授予呼叫客户端与外部身份提供商交换令牌的权限之前，将拒绝内部到外部令牌交换请求的403禁止响应。 要向客户端授予权限，您必须转到身份提供程序的配置页面中的Permissions选项卡。 身份提供商许可 将Permissions Enabled切换为true。 身份提供商许可 您应该在页面上看到token-exchange链接。 单击该开始定义权限。 它会带你到这个页面。 身份提供商Exchange权限设置 您必须为此权限定义策略。 单击Authorization链接，转到Policies选项卡并创建Client策略。 客户端策略创建 在此处输入起始客户端，即请求令牌交换的经过身份验证的客户端。 创建此策略后，返回到身份提供者的token-exchange权限并添加您刚定义的客户端策略。 应用客户端策略 您的客户现在有权调用。 如果您没有正确执行此操作，如果您尝试进行交换，则会收到403 Forbidden响应。 7.2.2. 提出请求 当您的客户端将现有内部令牌交换到外部令牌时，您必须提供requested_issuer参数。 该参数必须是已配置的标识提供程序的别名。 curl -X POST \\ -d \"client_id=starting-client\" \\ -d \"client_secret=geheim\" \\ --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\ -d \"subject_token=....\" \\ --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:access_token\" \\ -d \"requested_issuer=google\" \\ http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token subject_token参数必须是目标领域的访问令牌。 requested_token_type参数必须是urn:ietf:params:oauth:token-type:access_token或留空。 目前不支持其他请求的令牌类型。 以下是您从此调用中获得的成功JSON响应示例。 { \"access_token\" : \"....\", \"expires_in\" : 3600 \"account-link-url\" : \"https://....\" } 如果外部身份提供程序由于某种原因未链接，您将获得带有此JSON文档的HTTP 400响应代码： { \"error\" : \"....\", \"error_description\" : \"...\" \"account-link-url\" : \"https://....\" } error声明将是token_expired或not_linked。 提供了account-link-url声明，以便客户端可以执行客户端发起的帐户链接。 大多数（所有？）提供商都需要通过浏览器OAuth协议进行链接。 使用account-link-url只需向其添加redirect_uri查询参数，您就可以转发浏览器来执行链接。 7.3. 外部令牌到内部令牌交换 您可以信任并交换外部身份提供商为内部令牌创建的外部令牌。 这可用于在领域之间架起桥梁，或仅用于信任来自社交提供商的令牌。 它与身份提供程序浏览器登录的工作方式类似，如果新用户不存在，则会将新用户导入您的领域。 外部令牌交换的当前限制是，如果外部令牌映射到现有用户，则不允许交换，除非现有用户已经具有到外部身份提供者的帐户链接。 交换完成后，将在领域内创建用户会话，您将根据requested_token_type参数值接收访问和/或刷新令牌。 您应该注意，此新用户会话将保持活动状态，直到它超时或直到您调用域的注销端点传递此新访问令牌为止。 这些类型的更改需要在管理控制台中配置身份提供程序。 目前不支持SAML身份提供商。 Twitter令牌也无法交换。 7.3.1. 授予Exchange权限 在进行外部令牌交换之前，您必须为调用客户端授予进行交换的权限。 此权限的授予方式与授予外部权限的内部相同。 如果还提供了一个audience参数，其值指向不同于客户端的客户端，则还必须授予调用客户端与audience参数中特定目标客户端交换的权限。 如何做到这一点在前面已经讨论过。 7.3.2. 提出请求 subject_token_type必须是urn:ietf:params:oauth:token-type:access_token 或 urn:ietf:params:oauth:token-type:jwt。 如果类型是urn:ietf:params:oauth:token-type:access_token，则必须指定subject_issuer参数，它必须是已配置的身份提供者的别名。 如果类型是 urn:ietf:params:oauth:token-type:jwt，则提供者将通过JWT中的issuer声明进行匹配，该声明必须是提供者的别名，或者提供者配置中的注册发布方。 对于验证，如果令牌是访问令牌，则将调用提供者的用户信息服务以验证令牌。 成功通话意味着访问令牌有效。 如果主题令牌是JWT并且如果提供者启用了签名验证，则将尝试进行，否则，它将默认也调用用户信息服务来验证令牌。 默认情况下，内部令牌铸造将使用调用客户端使用为调用客户端定义的协议映射器来确定令牌中的内容。 或者，您可以使用audience参数指定其他目标客户端。 curl -X POST \\ -d \"client_id=starting-client\" \\ -d \"client_secret=geheim\" \\ --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\ -d \"subject_token=....\" \\ -d \"subject_issuer=myOidcProvider\" \\ --data-urlencode \"subject_token_type=urn:ietf:params:oauth:token-type:access_token\" \\ -d \"audience=target-client\" \\ http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token 如果您的requested_token_type参数是刷新令牌类型，则响应将包含访问令牌，刷新令牌和到期。 这是您从此调用中获得的示例JSON响应。 { \"access_token\" : \"....\", \"refresh_token\" : \"....\", \"expires_in\" : 3600 } 7.4. 模拟 对于内部和外部令牌交换，客户端可以代表用户请求冒充不同的用户。 例如，您可能有一个需要模拟用户的管理应用程序，以便支持工程师可以调试问题。 7.4.1. 授予Exchange权限 主题令牌所代表的用户必须具有模仿其他用户的权限。 有关如何启用此权限，请参阅服务器管理指南。 它可以通过角色或细粒度管理员权限来完成。 7.4.2. 提出请求 除了另外指定request_subject参数之外，按照其他章节中的描述发出请求。 此参数的值必须是用户名或用户ID。 curl -X POST \\ -d \"client_id=starting-client\" \\ -d \"client_secret=geheim\" \\ --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\ -d \"subject_token=....\" \\ --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:access_token\" \\ -d \"audience=target-client\" \\ -d \"requested_subject=wburke\" \\ http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token 7.5. 直接赤裸裸的模拟 您可以在不提供subject_token的情况下发出内部令牌交换请求。这称为直接裸模拟，因为它非常信任客户机，因为客户机可以模拟域中的任何用户。在无法获得要交换的主题令牌的应用程序中，您可能需要使用此桥接。例如，您可能正在集成一个直接使用LDAP执行登录的遗留应用程序。在这种情况下，遗留应用程序能够对用户进行身份验证，但无法获得令牌。 为客户端启用直接裸模拟是非常危险的。如果客户机的凭据被盗，则该客户机可以模拟系统中的任何用户。 7.5.1. 授予Exchange权限 如果提供了audience参数，则调用客户端必须具有与客户端交换的权限。 本章前面将讨论如何进行此设置。 此外，必须授予调用客户端模拟用户的权限。 在管理控制台中，转到Users屏幕，然后单击Permissions选项卡。 用户权限 将Permissions Enabled切换为true。 身份提供商许可 您应该在页面上看到impersonation链接。 单击该开始定义权限。 它会带你到这个页面。 用户模拟权限设置 您必须为此权限定义策略。 单击Authorization链接，转到Policies选项卡并创建Client策略。 客户端策略创建 在此处输入起始客户端，即请求令牌交换的经过身份验证的客户端。 创建此策略后，请返回用户的impersonation权限并添加刚刚定义的客户端策略。 应用客户端策略 您的客户机现在具有模仿用户的权限。如果您没有正确地执行此操作，如果您尝试进行这种类型的交换，您将得到403禁止响应。 公共客户端不允许直接进行裸模拟。 7.5.2. 提出请求 要发出请求，只需指定requested_subject参数即可。 这必须是有效用户的用户名或用户ID。 如果您愿意，也可以指定audience参数。 curl -X POST \\ -d \"client_id=starting-client\" \\ -d \"client_secret=geheim\" \\ --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\ -d \"requested_subject=wburke\" \\ http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token 7.6. 使用服务帐户展开权限模型 授予客户端交换权限时，您不必为每个客户端手动启用这些权限。 如果客户端具有与之关联的服务帐户，则可以使用角色将权限组合在一起，并通过将角色分配给客户端的服务帐户来分配交换权限。 例如，您可以定义一个naked-exchange角色，任何具有该角色的服务帐户都可以进行裸交换。 7.7. 交换漏洞 当你开始允许令牌交换时，你需要注意和注意各种各样的事情。 首先是公共客户。 公共客户端没有或需要客户端凭证才能执行交换。 任何拥有有效令牌的人都可以impersonate公共客户端并执行允许公共客户端执行的交换。 如果有任何由您的域管理的不值得信任的客户端，公共客户端可能会在您的权限模型中打开漏洞。 这就是为什么直接裸交换不允许公共客户端，并且如果主叫客户端是公共的，将中止错误。 可以交换由Facebook，Google等提供的社交令牌作为领域令牌。 请小心并警惕交换令牌可以做什么，因为在这些社交网站上创建虚假账户并不困难。 使用默认角色，组和身份提供程序映射器来控制为外部社交用户分配的属性和角色。 直接的裸交换非常危险。 您对调用客户端非常信任它永远不会泄露其客户端凭据。 如果这些凭据被泄露，那么小偷可以冒充你系统中的任何人。 这与具有现有令牌的机密客户形成鲜明对比。 您有两个身份验证因素，访问令牌和客户端凭据，而您只处理一个用户。 因此，请谨慎使用直接裸交换。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-01-04 20:08:11 "},"04_Server Administration Guide.html":{"url":"04_Server Administration Guide.html","title":"服务器管理指南","keywords":"","body":"Server Administration Guide(服务器管理指南)1. 概述1.1. 特征1.2. 安全是如何工作的?1.3. 核心概念和术语2. 服务器初始化3. 管理控制台3.1. Master 领域3.2. 创造一个新领域3.3. SSL模式3.4. 清除服务器缓存3.5. 电子邮件设置3.6. 主题与国际化4. 用户管理4.1. 搜索用户4.2. 创建新用户4.3. 删除用户4.4. 用户属性4.5. 用户凭据4.6. 必需操作4.7. 模拟4.8. 用户注册5. 登录页面设置5.1. 忘记密码5.2. 记住账号6. 认证6.1. 密码策略6.2. OTP 策略6.3. 身份验证流程6.4. 执行6.5. Kerberos6.6. X.509客户端证书用户身份验证7. SSO协议7.1. OpenID 连接7.2. SAML7.3. OpenID Connect 与 SAML7.4. Docker Registry v2身份验证8. 管理客户端8.1. OIDC 客户端8.2. SAML 客户端8.3. 客户端链接8.4. OIDC令牌和SAML断言映射8.5. 生成客户端适配器配置8.6. 客户端作用域9. 角色9.1. 领域角色9.2. 客户端 角色9.3. 复合 角色9.4. 用户角色映射9.5. 角色范围映射10. 组10.1. 群组与角色10.2. 默认组11. 管理控制台访问控制和权限11.1. Master Realm访问控制11.2. 专用领域管理控制台11.3. 细粒度管理员权限11.4. 领域密钥12. 身份代理12.1. 经纪概述12.2. 默认身份提供者12.3. 一般配置12.4. 社交身份提供者12.5. OpenID Connect v1.0 身份提供商12.6. SAML v2.0 身份提供商12.7. 客户建议身份提供商12.8. 映射声明和断言12.9. 可用的用户会话数据12.10. 首次登录流程12.11. 检索外部IDP令牌12.12. 身份代理注销13. 用户会话管理13.1. 管理会话13.2. 撤销策略13.3. 会话和令牌超时13.4. 离线访问14. 用户存储联合14.1. 添加提供商14.2. 处理提供商失败14.3. LDAP和Active Directory14.4. SSSD和FreeIPA身份管理集成14.5. 配置联合SSSD存储14.6. 定制供应商15. 审计和事件15.1. 登录活动15.2. 管理事件16. 导出和导入16.1. 管理控制台导出/导入17. 用户帐户服务17.1. 主题化18. 威胁模型缓解18.1. 主机名18.2. 管理员端点和控制台18.3. 密码猜测：暴力攻击18.4. 点击劫持18.5. SSL/HTTPS要求18.6. CSRF 攻击18.7. 非特定的重定向URI18.8. 受损的访问和刷新令牌18.9. 受损的授权码18.10. 打开重定向器18.11. 密码数据库受损18.12. 限制范围18.13. 限制令牌受众18.14. SQL注入攻击19. 管理员 命令行19.1. 安装Admin CLI19.2. 使用Admin CLI19.3. 认证19.4. 使用其他配置19.5. Basic operations and resource URIs19.6. Realm operations19.7. Role operations19.8. Client operations19.9. User operations19.10. Group operations19.11. Identity provider operations19.12. Storage provider operations19.13. Adding mappers19.14. Authentication operationsServer Administration Guide(服务器管理指南) 1. 概述 Keycloak是针对Web应用程序和RESTful Web服务的单点登录解决方案。 Keycloak的目标是使安全性变得简单，以便应用程序开发人员可以轻松保护他们在组织中部署的应用程序和服务。开发人员通常必须为自己编写的安全功能是开箱即用的，并且可以根据组织的个性化需求轻松定制。 Keycloak为登录，注册，管理和帐户管理提供可定制的用户界面。您还可以使用Keycloak作为集成平台将其挂钩到现有的LDAP和Active Directory服务器中。您还可以将身份验证委派给第三方身份提供商，如Facebook和Google+。 1.1. 特征 用于浏览器应用程序的单点登录和单点登录。 OpenID Connect支持。 OAuth 2.0 支持. SAML 支持. 身份代理 - 使用外部OpenID Connect或SAML身份提供商进行身份验证。 社交登录 - 允许使用Google，GitHub，Facebook，Twitter和其他社交网络登录。 用户联合 - 从LDAP和Active Directory服务器同步用户。 Kerberos桥 - 自动验证登录到Kerberos服务器的用户。 管理控制台，用于集中管理用户，角色，角色映射，客户端和配置。 帐户管理控制台，允许用户集中管理其帐户。 主题支持 - 自定义所有面向用户的页面以与您的应用程序和品牌集成。 双因素身份验证 - 通过Google身份验证器或FreeOTP支持TOTP / HOTP。 登录流程 - 可选用户自行注册，恢复密码，验证电子邮件，需要密码更新等。 会话管理 - 管理员和用户自己可以查看和管理用户会话。 令牌映射器 - 将用户属性，角色等映射到令牌和语句中。 每个领域，应用程序和用户之前的撤销策略。 CORS支持 - 客户端适配器具有对CORS的内置支持。 服务提供者接口（SPI） - 许多SPI，可以自定义服务器的各个方面。身份验证流程，用户联合提供程序，协议映射器等等。 适用于JavaScript应用程序，WildFly，JBoss EAP，Fuse，Tomcat，Jetty，Spring等的客户端适配器 支持具有OpenID Connect资源提供程序库或SAML 2.0服务提供程序库的任何平台/语言。 1.2. 安全是如何工作的? Keycloak是您在网络上管理的独立服务器。应用程序配置为指向此服务器并受其保护。 Keycloak使用开放协议标准，如OpenID Connect 或 SAML 2.0来保护您的应用程序。浏览器应用程序将用户的浏览器从应用程序重定向到Keycloak身份验证服务器，并在其中输入凭据。这很重要，因为用户与应用程序完全隔离，应用程序永远不会看到用户的凭据。相反，应用程序会获得一个加密签名的身份令牌或断言。这些令牌可以包含用户名，地址，电子邮件和其他个人资料数据等身份信息。他们还可以保存权限数据，以便应用程序可以做出授权决策。这些令牌还可用于对基于REST的服务进行安全调用。 1.3. 核心概念和术语 在尝试使用Keycloak保护Web应用程序和REST服务之前，您应该了解一些关键概念和术语。 users 用户是能够登录系统的实体。他们可以拥有与自己相关的属性，如电子邮件，用户名，地址，电话号码和出生日。可以为他们分配组成员身份并为其分配特定角色。 authentication 识别和验证用户的过程。 authorization 授予用户访问权限的过程。 credentials 凭据是Keycloak用于验证用户身份的数据。一些示例是密码，一次性密码，数字证书甚至指纹。 roles 角色标识用户的类型或类别。 Admin，user，manager和employee都是组织中可能存在的典型角色。应用程序通常为特定角色而不是单个用户分配访问权限和权限，因为与用户打交道可能过于细粒度且难以管理。 user role mapping 用户角色映射定义角色和用户之间的映射。用户可以与零个或多个角色相关联。可以将此角色映射信息封装到令牌和断言中，以便应用程序可以决定对其管理的各种资源的访问权限。 composite roles 复合角色是可以与其他角色关联的角色。例如，superuser复合角色可以与sales-admin和order-entry-admin角色相关联。如果用户被映射到“超级用户”角色，他们也会继承sales-admin和order-entry-admin角色。 groups 组管理用户组。可以为组定义属性。您也可以将角色映射到组。成为组成员的用户将继承组定义的属性和角色映射。 realms 领域管理一组用户，凭据，角色和组。用户属于并登录领域。领域彼此隔离，只能管理和验证他们控制的用户。 clients 客户端是可以请求Keycloak对用户进行身份验证的实体。大多数情况下，客户端是希望使用Keycloak保护自己并提供单点登录解决方案的应用程序和服务。客户端也可以是只想要请求身份信息或访问令牌的实体，以便他们可以安全地调用网络上由Keycloak保护的其他服务。 client adapters 客户端适配器是您安装到应用程序环境中的插件，可以通过Keycloak进行通信和保护。 Keycloak有许多适用于不同平台的适配器，您可以下载。对于我们未涵盖的环境，您还可以获得第三方适配器。 consent 同意是指您作为管理员希望用户在客户端参与身份验证过程之前向客户端授予权限。在用户提供其凭证之后，Keycloak将弹出一个屏幕，标识请求登录的客户端以及请求用户的身份信息。用户可以决定是否授予请求。 client scopes 注册客户端时，必须为该客户端定义协议映射器和角色范围映射。存储客户端范围通常很有用，通过共享一些常用设置可以更轻松地创建新客户端。这对于根据scope参数的值有条件地请求某些声明或角色也很有用。 Keycloak为此提供了客户端范围的概念。 client role 客户端可以定义特定于它们的角色。这基本上是专用于客户端的角色命名空间。 identity token 提供有关用户身份信息的令牌。 OpenID Connect规范的一部分。 access token 可以作为HTTP请求的一部分提供的令牌，用于授予对正在调用的服务的访问权限。这是OpenID Connect和OAuth 2.0规范的一部分。 assertion 有关用户的信息。这通常适用于SAML身份验证响应中包含的XML blob，该响应提供有关经过身份验证的用户的身份元数据。 service account 每个客户端都有一个内置的服务帐户，允许它获取访问令牌。 direct grant 客户端通过REST调用代表用户获取访问令牌的方法。 protocol mappers 对于每个客户端，您可以定制在OIDC令牌或SAML断言中存储的声明和断言。您可以通过创建和配置协议映射器为每个客户端执行此操作 session 用户登录时，会创建会话以管理登录会话。会话包含的信息，例如用户登录时以及在该会话期间单点登录的参与者。管理员和用户都可以查看会话信息。 user federation provider Keycloak可以存储和管理用户。通常，公司已经拥有存储用户和凭据信息的LDAP或Active Directory服务。您可以指向Keycloak来验证来自这些外部存储的凭据并提取身份信息。 identity provider 身份提供者（IDP）是可以对用户进行身份验证的服务。 Keycloak是一名IDP。 identity provider federation Keycloak可以配置为将身份验证委派给一个或多个IDP。通过Facebook或Google+进行社交登录是身份提供商联盟的一个示例。您还可以挂钩Keycloak将身份验证委派给任何其他OpenID Connect或SAML 2.0 IDP。 identity provider mappers 在执行IDP联合时，您可以将传入令牌和断言映射到用户和会话属性。这有助于您将身份信息从外部IDP传播到请求身份验证的客户端。 required actions 必需操作是用户在身份验证过程中必须执行的操作。在完成这些操作之前，用户将无法完成身份验证过程。例如，管理员可以安排用户每月重置其密码。将为所有这些用户设置“更新密码”所需的操作。 authentication flows 认证流程是用户在与系统的某些方面交互时必须执行的工作流程。登录流程可以定义所需的凭证类型。注册流程定义了用户必须输入的配置文件信息以及是否必须使用reCAPTCHA来过滤机器人。凭据重置流定义用户在重置密码之前必须执行的操作。 events 事件是管理员可以查看和挂钩的审计流。 themes Keycloak提供的每个屏幕都有一个主题支持。主题定义HTML模板和样式表，您可以根据需要覆盖它们。 2. 服务器初始化 执行服务器安装和配置指南中定义的所有安装和配置任务后，您需要创建一个初始管理员帐户。 Keycloak没有开箱即用的任何已配置的管理员帐户。此帐户将允许您创建一个可以登录master realm管理控制台的管理员，以便您可以开始创建领域，用户并注册要由Keycloak保护的应用程序。 如果您的服务器可以从localhost访问，则可以通过转到http://localhost:8080/authURL来启动它并创建此管理员用户。 欢迎页面 只需为此初始管理员指定所需的用户名和密码即可。 如果您无法通过localhost地址访问服务器，或者只想从命令行配置Keycloak，则可以使用... /bin/add-user-keycloak脚本执行此操作。 add-user-keycloak 脚本 根据您是使用独立操作模式还是域操作模式，参数稍有不同。对于独立模式，以下是使用脚本的方式。 Linux/Unix $ .../bin/add-user-keycloak.sh -r master -u -p Windows > ...\\bin\\add-user-keycloak.bat -r master -u -p 对于域模式，您必须使用-sc开关将脚本指向其中一个服务器主机。 Linux/Unix $ .../bin/add-user-keycloak.sh --sc domain/servers/server-one/configuration -r master -u -p Windows > ...\\bin\\add-user-keycloak.bat --sc domain/servers/server-one/configuration -r master -u -p 3. 管理控制台 您的大部分管理任务将通过Keycloak管理控制台完成。 您可以直接转到http://localhost:8080/auth/admin/的控制台URL 登录页面 输入您在欢迎页面上创建的用户名和密码，或者在bin目录中输入add-user-keycloak脚本。 这将带您进入Keycloak管理控制台。 管理控制台 左下拉菜单允许您选择要管理的领域或创建新领域。 右下拉菜单允许您查看用户帐户或注销。 如果您对管理控制台中的某个功能，按钮或字段感到好奇，只需将鼠标悬停在任何问号？图标上。 这将弹出工具提示文本以描述您感兴趣的控制台区域。上图显示了工具提示的实际操作。 3.1. Master 领域 当你第一次启动Keycloak时，Keycloak会为你创建一个预先定义的领域。 这个初始领域是master领域。 它是领域等级中的最高级别。 此领域中的管理员帐户具有查看和管理在服务器实例上创建的任何其他领域的权限。 定义初始管理员帐户时，可以在master域中创建帐户。 您最初登录管理控制台也将通过master领域。 我们建议您不要使用 master 领域来管理组织中的用户和应用程序。 保留使用masterrealm 给 super admins来创建和管理系统中的领域。 遵循此安全模型有助于防止意外更改，并遵循允许用户帐户仅访问成功完成其当前任务所需的权限和权限的传统。 可以禁用master领域，并在您创建的每个新领域中定义管理员帐户。 每个领域都有自己的专用管理控制台，您可以使用本地帐户登录。 本指南在Dedicated Realm Admin Consoles章节中详细介绍了这一点。 3.2. 创造一个新领域 创建一个新领域非常简单。 将鼠标悬停在标题为Master的左上角下拉菜单中。 如果您已登录主域，则此下拉菜单会列出所有已创建的域。 此下拉菜单的最后一个条目始终是Add Realm。 单击此按钮可添加领域。 添加领域菜单 此菜单选项将带您进入Add Realm 页面。 指定要定义的域名，然后单击Create按钮。 或者，您可以导入定义新领域的JSON文档。 我们将在导出和导入章节中详细介绍这一点。 创建领域 创建领域后，您将返回主管理控制台页面。 现在的领域现在将设置为您刚刚创建的领域。 您可以通过在左上角的下拉菜单中执行鼠标操作来切换管理不同领域。 3.3. SSL模式 每个领域都有一个与之关联的SSL模式。 SSL模式定义了与域进行交互的SSL/HTTPS要求。 与领域交互的浏览器和应用程序必须遵守SSL模式定义的SSL/HTTPS要求，否则将不允许它们与服务器交互。 Keycloak在第一次运行时生成自签名证书。 请注意，自签名证书不安全，只能用于测试目的。 强烈建议您在Keycloak服务器本身或Keycloak服务器前面的反向代理上安装CA签名证书。 请参阅服务器安装和配置指南。 要配置领域的SSL模式，您需要单击Realm Settings左侧菜单项并转到Login选项卡。 登录选项卡 Require SSL 选项允许您选择所需的SSL模式。 以下是每种模式的说明： external requests 用户可以在没有SSL的情况下与Keycloak进行交互，只要他们坚持使用localhost，127.0.0.1，10.0.x.x，192.168.x.x和172.16.x.x等私有IP地址即可。 如果您尝试从非私有IP地址访问没有SSL的Keycloak，您将收到错误。 none Keycloak不需要SSL。 实际上，这只应该在开发时使用，而不想在服务器上配置SSL。 all requests Keycloak要求所有IP地址都使用SSL。 3.4. 清除服务器缓存 Keycloak将在JVM的限制范围内和/或为其配置的限制内容缓存内存中的所有内容。 如果Keycloak数据库被服务器的REST API或管理控制台范围之外的第三方（即DBA）修改，则内存缓存的某些部分可能是陈旧的。 您可以通过转到Realm Settings左侧菜单项，从管理控制台清除外部公钥（外部客户端或身份提供者的公钥，Keycloak通常用于验证特定外部实体的签名）的域缓存，用户缓存或缓存 菜单项和Cache选项卡。 缓存选项卡 只需单击要清除的缓存上的clear按钮即可。 3.5. 电子邮件设置 Keycloak向用户发送电子邮件以验证他们的电子邮件地址，忘记密码时，或者管理员需要接收有关服务器事件的通知。 要启用Keycloak发送电子邮件，您需要向Keycloak提供SMTP服务器设置。 这是根据领域配置的。 转到Realm Settings左侧菜单项，然后单击Email选项卡。 电子邮件选项卡 Host Host表示用于发送电子邮件的SMTP服务器主机名。 Port Port表示SMTP服务器端口。 From From表示用于发送电子邮件的From SMTP-Header的地址。 From Display Name From Display Name允许配置用户友好的电子邮件地址别名（可选）。 如果没有设置，普通的From电子邮件地址将显示在电子邮件客户端中。 Reply To Reply To表示用于发送邮件的Reply-ToSMTP-Header的地址（可选）。 如果没有设置，将使用普通的From电子邮件地址。 Reply To Display Name Reply To Display Name允许配置用户友好的电子邮件地址别名（可选）。 如果没有设置，将显示普通的Reply To电子邮件地址。 Envelope From Envelope From表示Bounce Address ，用于发送邮件的Return-PathSMTP-Header（可选）。 由于电子邮件用于恢复用户名和密码，因此建议使用SSL或TLS，尤其是在SMTP服务器位于外部网络上时。 要启用SSL，请单击Enable SSL或启用TLS，单击Enable TLS。 您很可能还需要更改Port（SSL/TLS的默认端口是465）。 如果您的SMTP服务器需要身份验证，请单击 Enable Authentication并插入Username和Password。 3.6. 主题与国际化 主题允许您更改Keycloak中任何UI的外观。 每个领域都配置了主题。 要更改主题，请转到Realm Settings左侧菜单项，然后单击Themes选项卡。 Themes 选项卡 为每个UI类别选择所需的主题，然后单击Save。 Login Theme 用户名密码输入，OTP输入，新用户注册以及与登录相关的其他类似屏幕。 Account Theme 每个用户都有一个用户帐户管理UI。 Admin Console Theme Keycloak管理控制台的外观。 Email Theme 每当Keycloak发送电子邮件时，它都会使用此主题中定义的模板来制作电子邮件。 服务器开发人员指南 介绍了如何创建新主题或修改现有主题。 3.6.1. 国际化 每个UI屏幕都在Keycloak中国际化。 默认语言是英语，但是如果打开Theme选项卡上的Internationalization开关，您可以选择要支持的语言环境以及默认语言环境。 用户下次登录时，他们将能够在登录页面上选择一种语言，用于登录屏幕，用户帐户管理UI和管理控制台。 服务器开发人员指南介绍了如何提供其他语言。 4. 用户管理 本节介绍管理用户的管理功能。 4.1. 搜索用户 如果您需要管理特定用户，请单击左侧菜单栏中的Users。 Users 此菜单选项将您带到用户列表页面。 在搜索框中，您可以在用户数据库中键入要搜索的全名，姓氏或电子邮件地址。 该查询将显示符合您条件的所有用户。 View all users按钮将列出系统中的每个用户。 这将仅搜索本地Keycloak数据库而不搜索联合数据库（即LDAP），因为某些后端（如LDAP）无法通过用户进行分页。 因此，如果您希望联合后端的用户同步到Keycloak数据库，您需要： 调整搜索条件。 这将只将符合条件的后端用户同步到Keycloak数据库中。 转到User Federation选项卡，然后单击页面中的Sync all users或Sync changed users与联合提供程序。 有关详细信息，请参阅用户联合。 4.2. 创建新用户 要创建用户，请单击左侧菜单栏中的Users。 Users 此菜单选项将您带到用户列表页面。 在空用户列表的右侧，您应该看到Add User按钮。 单击该按钮开始创建新用户。 Add User 唯一必填字段是Username。 点击保存。 这将带您进入新用户的管理页面。 4.3. 删除用户 要删除用户，请单击左侧菜单栏中的Users。 Users 此菜单选项将您带到用户列表页面。 单击View all users或搜索以查找要删除的用户。 Add User 在用户列表中，单击要删除的用户旁边的Delete。 系统将要求您确认是否要删除此用户。 单击确认框中的Delete进行确认。 4.4. 用户属性 除了名称和电子邮件等基本用户元数据之外，您还可以存储任意用户属性。 选择要管理的用户，然后单击Attributes选项卡。 Users 在空字段中输入属性名称和值，然后单击旁边的Add按钮以添加新字段。 请注意，在您点击Save按钮之前，您在此页面上所做的任何编辑都不会被存储。 4.5. 用户凭据 当您查看用户时，如果您转到Credentials选项卡，则可以管理用户的凭据。 Credential Management 4.5.1. 更改密码 要更改用户密码，请键入新密码。 在您输入所有内容后，将显示Reset Password按钮。如果Temporary开关打开，则此新密码只能使用一次，并且用户将被要求更改密码 登录。 或者，如果您设置了email，则可以向用户发送电子邮件，要求他们重置密码。 从Reset Actions列表框中选择Update Password，然后单击Send Email。 您可以选择设置电子邮件链接的有效性，该链接默认为领域设置中Tokens选项卡中预设的一个。 发送的电子邮件包含一个链接，用于将用户带到更新密码屏幕。 4.5.2. 修改 OTPs 您无法在管理控制台中为特定用户配置一次性密码。 这是用户的责任。 如果用户丢失了他们的OTP生成器，你可以在Credentials选项卡上为它们禁用OTP。 如果您的领域中的OTP是可选的，则用户必须转到用户帐户管理服务以重新配置新的OTP生成器。 如果需要OTP，则会要求用户在登录时重新配置新的OTP生成器。 与密码一样，您也可以向用户发送电子邮件，要求他们重置OTP生成器。 在Reset Actions列表框中选择Configure OTP，然后单击Send Email按钮。 发送的电子邮件包含一个链接，用于将用户带到OTP设置屏幕。 4.6. 必需操作 必需操作是用户在允许登录之前必须完成的任务。用户必须在执行所需操作之前提供其凭据。 完成所需操作后，用户将不必再次执行操作。 以下是一些内置必需操作类型的说明： Update Password 设置后，用户必须更改其密码。 Configure OTP 设置后，用户必须使用Free OTP或Google Authenticator应用程序在其移动设备上配置一次性密码生成器。 Verify Email 设置后，用户必须验证他们是否拥有有效的电子邮件帐户。 将向用户发送一封电子邮件，其中包含他们必须单击的链接。 成功完成此工作流后，将允许他们登录。 Update Profile 该要求的动作要求用户更新他们的简档信息，即他们的姓名，地址，电子邮件和/或电话号码。 管理员可以在管理控制台的用户Details选项卡中为每个用户添加所需的操作。 Setting Required Action 在Required User Actions列表框中，选择要添加到帐户的所有操作。 如果要删除一个，请单击操作名称旁边的X。 还要记得在确定要添加的操作后单击Save按钮。 4.6.1. 默认必需操作 您还可以指定在创建新用户时将添加到帐户的必需操作，即通过用户列表屏幕的Add User按钮，或通过用户注册 登录页面上的链接。 要指定默认的必需操作，请转到Authentication左侧菜单项，然后单击Required Actions选项卡。 Default Required Actions 只需单击全新用户登录时要执行的所需操作的Default Action列中的复选框即可。 4.6.2. 条款和条件 许多组织都要求当新用户第一次登录时，他们需要同意网站的条款和条件。 Keycloak将此功能实现为必需的操作，但它需要一些配置。 首先，您必须转到前面描述的Required Actions选项卡并启用Terms and Conditions操作。 您还必须编辑base login主题中的terms.ftl文件。 有关扩展和创建主题的更多信息，请参阅服务器开发人员指南 。 4.7. 模拟 管理员冒充用户通常很有用。 例如，用户可能在您的某个应用程序中遇到错误，并且管理员可能想要冒充用户以查看他们是否可以复制问题。 具有适当权限的管理员可以模拟用户。 管理员可以通过两个位置发起模拟。 第一个是在Users列表选项卡上。 Users 您可以在此处看到管理员已搜索john。 在John的帐户旁边，您可以看到一个模拟按钮。 单击该按钮以模拟用户。 此外，您可以从用户Details选项卡模拟用户。 User Details 在页面底部附近，您可以看到Impersonate按钮。 单击该按钮以模拟用户。 模拟时，如果管理员和用户处于同一领域，则管理员将被注销并在用户被模拟时自动登录。 如果管理员和用户不在同一领域，管理员将保持登录状态，但另外以该用户领域中的用户身份登录。 在这两种情况下，浏览器都将重定向到模拟用户的“用户帐户管理”页面。 具有领域impersonation角色的任何用户都可以模拟用户。 有关分配管理权限的更多详细信息，请参阅管理控制台访问控制一章。 4.8. 用户注册 您可以启用Keycloak以允许用户自行注册。 启用后，登录页面会有一个注册链接，用户可以单击该链接以创建新帐户。 启用用户自注册后，可以使用注册表单来检测有效的用户名和电子邮件。 也可以启用reCAPTCHA支持。 启用注册非常简单。 转到Realm Settings左侧菜单并单击它。 然后转到Login选项卡。 此选项卡上有一个User Registration开关。 打开它，然后单击Save按钮。 Login Tab 启用此设置后，Register链接应显示在登录页面上。 Registration Link 单击此链接将使用户进入注册页面，他们必须在其中输入一些用户配置文件信息和新密码。 Registration Form 您可以更改注册表单的外观，以及删除或添加必须输入的其他字段。 有关详细信息，请参阅Server Developer Guide。 4.8.1. reCAPTCHA 支持 为了防止机器人注册，Keycloak与Google reCAPTCHA集成。 要启用此功能，您需要先访问Google Recaptcha网站并创建API密钥，以便获取reCAPTCHA网站密钥和密钥。 （仅供参考，localhost默认工作，因此您不必指定域）。 接下来，您需要在Keycloak管理控制台中执行几个步骤。 单击Authentication左侧菜单项，然后转到Flows选项卡。 从此页面的下拉列表中选择Registration流程。 Registration Flow 单击相应的单选按钮，将reCAPTCHA要求设置为Required。 这将在屏幕上启用reCAPTCHA。 接下来，您必须输入您在Google reCAPTCHA网站上生成的reCAPTCHA网站密钥和密码。 单击reCAPTCHA流条目右侧的Actions按钮，然后单击“Config”链接，并在此配置页面上输入reCAPTCHA站点密钥和秘密。 Recaptcha Config Page 您需要做的最后一步是更改Keycloak设置的一些默认HTTP响应标头。 Keycloak将阻止网站在iframe中包含任何登录页面。 这是为了防止点击劫持攻击。 您需要授权Google在iframe中使用注册页面。 转到Realm Settings左侧菜单项，然后转到Security Defenses选项卡。 您需要将https://www.google.com添加到X-Frame-Options和Content-Security-Policy标头的值中。 Authorizing Iframes 完成此操作后，reCAPTCHA应显示在您的注册页面上。 您可能希望在登录主题中编辑register.ftl，以便使用reCAPTCHA按钮的放置和样式进行清理。 有关扩展和创建主题的更多信息，请参阅服务器开发人员指南。 5. 登录页面设置 如果您需要这些功能，可以启用几个很好的内置登录页面功能。 5.1. 忘记密码 如果您启用它，用户可以在忘记密码或丢失OTP生成器时重置其凭据。 转到Realm Settings左侧菜单项，然后单击Login选项卡。 打开Forgot Password开关。 Login Tab forgot password链接现在将显示在您的登录页面上。 Forgot Password Link 点击此链接会将用户带到一个页面，用户可以在其中输入用户名或电子邮件，并收到一封电子邮件，其中包含重置其凭据的链接。 Forgot Password Page 电子邮件中发送的文本是完全可配置的。 您只需要扩展或编辑与之关联的主题。 有关详细信息，请参阅Server Developer Guide。 当用户点击电子邮件链接时，系统会要求他们更新密码，如果他们设置了OTP生成器，他们也会被要求重新配置。 根据组织的安全要求，您可能不希望用户能够通过电子邮件重置其OTP生成器。 您可以通过转到Authentication左侧菜单项，单击Flows选项卡，然后选择Reset Credentials流来改变这种行为： Reset Credentials Flow 如果你不想重置OTP，那么只需选择Reset OTP右侧的disabled单选按钮。 5.2. 记住账号 如果登录用户关闭了他们的浏览器，他们的会话将被销毁，他们将不得不再次登录。 您可以进行设置，以便在用户选中remember me复选框时，即使浏览器已关闭，它们仍将保持登录状态。 这基本上将登录cookie从仅会话cookie转换为持久性cookie。 要启用此功能，请转到Realm Settings左侧菜单项，然后单击Login选项卡并打开Remember Meswitch`: Login Tab 保存此设置后，将在领域的登录页面上显示remember me复选框。 Remember Me 6. 认证 在为领域配置身份验证时，您应该注意一些功能。 许多组织都有严格的密码和OTP策略，您可以通过管理控制台中的设置强制执行这些策略。 您可能希望也可能不希望要求不同的凭据类型进行身份验证。 您可能希望为用户提供通过Kerberos登录或禁用或启用各种内置凭据类型的选项。 本章涵盖所有这些主题。 6.1. 密码策略 创建的每个新领域都没有与之关联的密码策略。 用户可以根据需要拥有尽可能短，复杂，不安全的密码。 简单的设置适用于开发或学习Keycloak，但在生产环境中是不可接受的。 Keycloak拥有一组丰富的密码策略，您可以通过管理控制台启用这些策略。 单击Authentication左侧菜单项，然后转到Password Policy选项卡。 在右侧下拉列表框中选择要添加的策略。 这将在屏幕上的表中添加策略。 选择策略的参数。 点击Save按钮存储您的更改。 Password Policy 保存策略后，用户注册和“需要更新密码”操作将强制执行新策略。 用户未通过策略检查的示例： Failed Password Policy 如果更新了密码策略，则必须为每个用户设置“更新密码”操作。 自动触发器被安排为未来的增强功能。 6.1.1. 密码策略类型 以下是每种策略类型的说明： HashAlgorithm 密码不会以明文形式存储。 相反，它们在存储或验证之前使用标准哈希算法进行哈希处理。 唯一可用的内置和默认算法是PBKDF2。 有关如何插入自己的算法，请参阅服务器开发人员指南。 请注意，如果您确实更改了算法，则密码哈希值在用户登录时才会在存储中更改。 Hashing Iterations 此值指定在存储或验证密码之前对密码进行哈希处理的次数。 默认值为20,000。 这种散列是在黑客获取密码数据库的极少数情况下完成的。 一旦他们可以访问数据库，他们就可以对用户密码进行反向工程。 随着CPU功率的提高，该参数的行业推荐值每年都在变化。 较高的散列迭代值需要更多的CPU功率进行散列，并且可能会影响性能。 您必须权衡对您更重要的事情：性能或保护您的密码存储。 可能有更具成本效益的方法来保护您的密码存储。 Digits 密码字符串中需要的位数。 Lowercase Characters 密码字符串中需要的小写字母数。 Uppercase Characters 密码字符串中需要大写字母的数量。 Special Characters 需要在密码字符串中包含?!#%$等特殊字符的数量。 Not Username 设置后，密码不允许与用户名相同。 Regular Expression 定义一个或多个密码必须匹配的Perl正则表达式模式。 Expire Password 密码有效的天数。 在天数过期后，用户需要更改其密码。 Not Recently Used 此策略保存以前密码的历史记录。 存储的旧密码数量是可配置的。 当用户更改其密码时，他们无法使用任何存储的旧密码。 Password Blacklist 此策略检查给定密码是否包含在黑名单文件中，该文件可能是一个非常大的文件。 密码黑名单是带有Unix行结尾的UTF-8纯文本文件，其中每行代表一个列入黑名单的密码。 必须提供黑名单文件的文件名作为密码策略值，例如10_million_password_list_top_1000000.txt。 黑名单文件默认解析为${jboss.server.data.dir}/password-blacklists/。 可以通过keycloak.password.blacklists.path系统属性或passwordBlacklist策略SPI配置的blacklistsPath属性来定制此路径。 6.2. OTP 策略 Keycloak有许多政策可以为FreeOTP或Google身份验证器一次性密码生成器设置。 单击Authentication左侧菜单项，然后转到OTP Policy选项卡。 OTP Policy 您在此处设置的任何策略都将用于验证一次性密码。 配置OTP时，FreeOTP和Google Authenticator可以扫描在Keycloak所具有的OTP设置页面上生成的QR码。 条形码也是从OTP Policy选项卡上配置的信息生成的。 6.2.1. TOTP vs. HOTP 您的OTP生成器有两种不同的算法可供选择。 基于时间（TOTP）和基于计数器（HOTP）。 对于TOTP，您的令牌生成器将散列当前时间和共享密钥。 服务器通过将特定时间窗口内的所有哈希值与提交的值进行比较来验证OTP。 因此，TOTP仅在短时间内（通常为30秒）有效。 对于HOTP，使用共享计数器而不是当前时间。 服务器会在每次成功的OTP登录时递增计数器。 因此，有效的OTP仅在成功登录后才会更改。 TOTP被认为更安全，因为匹配的OTP仅在短时间内有效，而HOTP的OTP可以在不确定的时间内有效。 HOTP更加用户友好，因为用户在时间间隔结束之前不必急于进入他们的OTP。 随着Keycloak实施TOTP的方式，这种区别变得更加模糊。 每次服务器想要递增计数器时，HOTP都需要更新数据库。 当负载很重时，这可能会导致身份验证服务器的性能下降。 因此，为了提供更有效的替代方案，TOTP不记得使用的密码。 这绕过了进行任何数据库更新的需要，但缺点是TOTP可以在有效时间间隔内重复使用。 对于Keycloak的未来版本，计划您能够配置TOTP是否在时间间隔内检查较旧的OTP。 6.2.2. TOTP配置选项 OTP Hash Algorithm 默认值为SHA1，更安全的选项是SHA256和SHA512。 Number of Digits OTP有多少个字符？ Short表示用户更友好，因为用户输入的内容较少。 更多意味着更多安全。 Look Ahead Window 服务器尝试匹配哈希的前方间隔数是多少？ 这样做只是为了防止TOTP生成器或认证服务器的时钟不同步。 默认值1通常足够好。 例如，如果新令牌的时间间隔是每30秒，则默认值1表示它只接受该30秒窗口中的有效令牌。 此配置值的每次递增都会使有效窗口增加30秒。 OTP令牌时间段 服务器匹配哈希的时间间隔（以秒为单位）。 每次间隔通过时，令牌生成器将生成新的TOTP。 6.2.3. HOTP配置选项 OTP Hash Algorithm 默认值为SHA1，更安全的选项是SHA256和SHA512。 Number of Digits OTP有多少个字符？ Short表示用户更友好，因为用户输入的内容较少。 更多意味着更多安全。 Look Ahead Window 如果服务器尝试匹配哈希，前面有多少个计数器？ 默认值为1.这是为了涵盖用户计数器超前于服务器的情况。 这通常会发生，因为用户经常意外地手动递增计数器太多次。 这个值确实应该增加到10左右。 Initial Counter 初始计数器的价值是多少？ 6.3. 身份验证流程 身份验证流程是用于登录，注册和其他Keycloak工作流程期间必须执行的所有身份验证，屏幕和操作的容器。 如果您转到管理控制台Authentication左侧菜单项并转到Flows选项卡，您可以查看系统中所有已定义的流以及每个流所需的操作和检查。 本节将介绍浏览器登录流程。 在左侧下拉列表中选择browser进入如下界面： Browser Flow 如果将鼠标悬停在流选择列表右侧的工具提示（小问号）上，则会描述流程的作用和作用。 Auth Type列是要执行的身份验证或操作的名称。 如果验证是缩进的，则意味着它在子流中，并且可能会也可能不会执行，具体取决于其父级的行为。 Requirement列是一组单选按钮，用于定义操作是否执行。 让我们描述每个单选按钮的含义： Required 此身份验证执行必须成功执行。 如果用户未配置该类型的身份验证机制，并且存在与该身份验证类型关联的必需操作，则会将所需操作附加到该帐户。 例如，如果将OTP Form切换为Required，则会要求未配置OTP生成器的用户执行此操作。 Optional 如果用户配置了身份验证类型，则会执行该身份验证。 否则，它将被忽略。 Disabled 如果禁用，则不执行身份验证类型。 Alternative 这意味着至少有一种备用身份验证类型必须在该流级别成功执行。 这在一个例子中有更好的描述。 让我们来看看browser认证流程。 第一种身份验证类型是Cookie。 当用户第一次成功登录时，会设置会话cookie。 如果已设置此cookie，则此身份验证类型成功。 由于cookie提供程序返回成功，并且此流级别的每次执行都是alternative，因此不会执行其他执行，这会导致成功登录。 接下来，该流程将查看Kerberos执行情况。 默认情况下禁用此身份验证器，将跳过此身份验证器。 下一个执行是一个名为Forms的子流。 由于此子流标记为alternative，如果传递了Cookie身份验证类型，则不会执行该子流。 此子流包含需要执行的其他身份验证类型。 加载此子流的执行并发生相同的处理逻辑 Forms子流中的第一个执行是用户名密码表单。 此身份验证类型呈现用户名和密码页面。 它标记为required，因此用户必须输入有效的用户名和密码。 下一次执行是OTP表格。 这标记为optional。 如果用户已设置OTP，则此身份验证类型必须运行并成功。 如果用户未设置OTP，则忽略此身份验证类型。 6.4. 执行 可以使用执行 脚本身份验证器 script(脚本)认证器允许通过JavaScript定义自定义的认证逻辑。自定义的身份验证器。为了使用这个功能，它必须显式启用: bin/standalone.sh|bat -Dkeycloak.profile.feature.scripts=enabled 有关详细信息，请参阅配置文件部分。 身份验证脚本必须至少提供以下功能之一:authenticate(..)调用自Authenticator#authenticate(AuthenticationFlowContext) action(..) ，这是从Authenticator#action(AuthenticationFlowContext)调用的。 自定义Authenticator至少应该提供authenticate(..)函数。 以下脚本javax.script.Bindings可以在脚本代码中方便地使用。 script 用于访问脚本元数据的ScriptModel realm the RealmModel user 当前的UserModel session 活跃的KeycloakSession authenticationSession 当前的AuthenticationSessionModel httpRequest 当前的 org.jboss.resteasy.spi.HttpRequest LOG 一个org.jboss.logging.Logger作用于ScriptBasedAuthenticator 请注意，可以从传递给authenticate(context) action(context)函数的context参数中提取其他上下文信息。 AuthenticationFlowError = Java.type(\"org.keycloak.authentication.AuthenticationFlowError\"); function authenticate(context) { LOG.info(script.name + \" --> trace auth for: \" + user.username); if ( user.username === \"tester\" && user.getAttribute(\"someAttribute\") && user.getAttribute(\"someAttribute\").contains(\"someValue\")) { context.failure(AuthenticationFlowError.INVALID_USER); return; } context.success(); } 6.5. Kerberos Keycloak支持通过SPNEGO协议使用Kerberos票证登录。 SPNEGO（简单和受保护的GSSAPI协商机制）用于在登录其会话后对用户进行身份验证后通过Web浏览器进行透明身份验证。 对于非Web案例或在登录期间无法使用票证时，Keycloak还支持使用Kerberos用户名/密码登录。 Web身份验证的典型用例如下： 用户登录到他的桌面（例如Active Directory域中的Windows计算机或启用了Kerberos集成的Linux计算机）。 然后，用户使用他的浏览器(IE / Firefox / Chrome)访问由Keycloak保护的Web应用程序。 应用程序重定向到Keycloak登录。 Keycloak将HTML登录屏幕与状态401和HTTP标题WWW-Authenticate: Negotiate一起呈现 如果浏览器具有来自桌面登录的Kerberos票证，它会将桌面登录信息传输到标题Authorization: Negotiate 'spnego-token'中的Keycloak。 否则它只显示登录屏幕。 Keycloak验证来自浏览器的令牌并验证用户身份。 它从LDAP中提供用户数据（如果LDAPFederationProvider具有Kerberos身份验证支持），或者让用户更新其配置文件和预填充数据（如果是KerberosFederationProvider）。 Keycloak返回应用程序。 Keycloak和应用程序之间的通信通过OpenID Connect或SAML消息进行。 Keycloak通过Kerberos进行身份验证的事实对应用程序是隐藏的。 所以Keycloak充当Kerberos / SPNEGO登录的经纪人。 设置有3个主要部分： Kerberos服务器（KDC）的设置和配置 Keycloak服务器的设置和配置 客户端计算机的设置和配置 6.5.1. Kerberos服务器的设置 这取决于平台。 确切的步骤取决于您将要使用的操作系统和Kerberos供应商。 有关如何设置和配置Kerberos服务器的详细信息，请参阅Windows Active Directory，MIT Kerberos和操作系统文档。 至少你需要： 将一些用户主体添加到Kerberos数据库。 您还可以将Kerberos与LDAP集成，这意味着将从LDAP服务器配置用户帐户。 添加“HTTP”服务的服务主体。 例如，如果您的Keycloak服务器将在www.mydomain.org上运行，您可能需要添加主体HTTP/www.mydomain.org@MYDOMAIN.ORG，假设MYDOMAIN.ORG将成为您的Kerberos领域。 例如，在MIT Kerberos上，您可以运行“kadmin”会话。 如果您在MIT Kerberos所在的同一台机器上，您只需使用以下命令： sudo kadmin.local 然后添加HTTP主体并将其密钥导出到keytab文件，其命令如下： addprinc -randkey HTTP/www.mydomain.org@MYDOMAIN.ORG ktadd -k /tmp/http.keytab HTTP/www.mydomain.org@MYDOMAIN.ORG 需要在运行Keycloak服务器的主机上访问Keytab文件/tmp/http.keytab。 6.5.2. Keycloak服务器的设置和配置 您需要在计算机上安装kerberos客户端。 这也取决于平台。 如果您使用的是Fedora，Ubuntu或RHEL，则可以安装包含Kerberos客户端和其他几个实用程序的freeipa-client软件包。 配置kerberos客户端（在Linux上，它在文件/etc/krb5.conf中）。 您需要放置Kerberos领域，并至少配置您的服务器将运行的HTTP域。 对于示例领域MYDOMAIN.ORG，您可以像这样配置domain_realm部分： [domain_realm] .mydomain.org = MYDOMAIN.ORG mydomain.org = MYDOMAIN.ORG 接下来，您需要使用HTTP主体导出keytab文件，并确保该文件可供运行Keycloak服务器的进程访问。 对于生产来说，如果它只是通过这个过程而不是其他人可读，那么它是理想的。 对于上面的MIT Kerberos示例，我们已经将keytab导出到/tmp/http.keytab。 如果您的KDC和Keycloak在同一主机上运行，则您已经可以使用该文件。 启用SPNEGO处理 Keycloak默认情况下没有打开SPNEGO协议支持。 因此，您必须转到浏览器流程 并启用Kerberos。 Browser Flow 将Kerberos要求从disabled切换到alternative或required。 Alternative 基本上意味着Kerberos是可选的。 如果用户的浏览器尚未配置为使用SPNEGO/Kerberos，则Keycloak将回退到常规登录屏幕。 如果将需求设置为required，则所有用户必须为其浏览器启用Kerberos。 配置Kerberos用户存储联合提供程序 现在，在身份验证服务器上打开了SPNEGO协议，您需要配置Keycloak如何解释Kerberos票证。 这是通过用户存储联合完成的。 我们有2个不同的联合提供程序，支持Kerberos身份验证。 如果要使用LDAP服务器支持的Kerberos进行身份验证，则必须先配置LDAP Federation Provider。 如果查看LDAP提供程序的配置页面，您将看到Kerberos Integration部分。 LDAP Kerberos Integration 打开Allow Kerberos authentication开关将使Keycloak使用Kerberos主体查找有关用户的信息，以便将其导入Keycloak环境。 如果LDAP服务器不支持您的Kerberos解决方案，则必须使用Kerberos用户存储联合提供程序。 转到User Federation左侧菜单项，然后从Add provider选择框中选择Kerberos。 Kerberos User Storage Provider 此提供程序解析Kerberos票证以获取简单的主体信息，并对本地Keycloak数据库进行少量导入。 不提供姓名、姓氏和电子邮件等用户概要信息。 6.5.3. 客户端计算机的设置和配置 客户端需要安装kerberos客户端并如上所述设置krb5.conf。 此外，他们还需要在浏览器中启用SPNEGO登录支持。 如果您使用的是该浏览器，请参阅为Kerberos配置Firefox。 必须在network.negotiate-auth.trusted-uris配置选项中允许URI.mydomain.org。 在Windows域中，客户端通常不需要配置任何特殊内容，因为IE已经能够参与Windows域的SPNEGO身份验证。 6.5.4. 示例设置 为了便于使用Kerberos进行测试，我们提供了一些示例设置进行测试。 Keycloak and FreeIPA docker 镜像 安装docker后，可以运行装有FreeIPA服务器的docker镜像。 FreeIPA提供集成的安全解决方案，包括MIT Kerberos和389 LDAP服务器等。 该镜像还提供了使用LDAP联合提供程序配置的Keycloak服务器，并针对FreeIPA服务器启用了SPNEGO/Kerberos身份验证。 详见此处。 ApacheDS测试Kerberos服务器 对于快速测试和单元测试，我们使用非常简单的ApacheDS Kerberos服务器。 您需要从源代码构建Keycloak，然后使用我们的测试套件中的maven-exec-plugin运行Kerberos服务器。 详见此处 。 6.5.5. 凭证授权 Kerberos 5支持凭证委派的概念。 在这种情况下，您的应用程序可能希望访问Kerberos票证，以便它们可以重新使用它与Kerberos保护的其他服务进行交互。 由于SPNEGO协议是在Keycloak服务器中处理的，因此您必须在OpenID Connect令牌声明或从Keycloak服务器传输到您的应用程序的SAML断言属性中将GSS凭据传播到您的应用程序。 要将此声明插入到令牌或断言中，每个应用程序都需要启用名为gss delegation credential的内置协议映射器。 这在应用程序客户端页面的Mappers选项卡中启用。 有关详细信息，请参阅协议映射器一章。 应用程序需要对从Keycloak收到的声明进行反序列化，然后才能使用它对其他服务进行GSS调用。 将凭证从访问令牌反序列化到GSSCredential对象后，需要创建GSSContext，并将此凭据传递给方法GSSManager.createContext，例如： // Obtain accessToken in your application. KeycloakPrincipal keycloakPrincipal = (KeycloakPrincipal) servletReq.getUserPrincipal(); AccessToken accessToken = keycloakPrincipal.getKeycloakSecurityContext().getToken(); // Retrieve kerberos credential from accessToken and deserialize it String serializedGssCredential = (String) accessToken.getOtherClaims(). get(org.keycloak.common.constants.KerberosConstants.GSS_DELEGATION_CREDENTIAL); GSSCredential deserializedGssCredential = org.keycloak.common.util.KerberosSerializationUtils. deserializeCredential(serializedGssCredential); // Create GSSContext to call other kerberos-secured services GSSContext context = gssManager.createContext(serviceName, krb5Oid, deserializedGssCredential, GSSContext.DEFAULT_LIFETIME); 我们有一个例子，详细说明了这一点。 它位于Keycloak示例分发或演示分发下载中的examples/kerberos中。 您也可以直接这里查看示例源。 请注意，您还需要在krb5.conf文件中配置forwardablekerberos票证，并在您的浏览器中添加对委派凭据的支持。 凭据授权具有一些安全隐患，因此只有在您真正需要时才使用它。 强烈建议将它与HTTPS一起使用。 有关详细信息，请参阅本文。 6.5.6. 跨领域的信任 在Kerberos V5协议中，realm是Kerberos数据库（通常是LDAP服务器）中定义的一组Kerberos主体。 Kerberos协议具有跨领域信任的概念。 例如，如果有2个kerberos域A和B，则跨域信任将允许来自域A的用户访问域B的资源（服务）。这意味着域B信任域A. Kerberos cross-realm trust Keycloak服务器支持跨领域信任。 要实现这一目标，有几件事情需要做： 为跨领域信任配置Kerberos服务器。 此步骤取决于所使用的具体Kerberos服务器实现。 通常，需要将Kerberos主体krbtgt/B@A添加到域A和B的Kerberos数据库中。需要此主体在两个Kerberos域上具有相同的键。 这通常在主体具有相同密码，密钥版本号并且在两个领域中使用相同密码时实现。 建议查阅Kerberos服务器文档以获取更多详细信息。 默认情况下，跨领域信任是单向的。 如果您希望双向信任使域A也信任域B，则还必须将主体krbtgt/A@B添加到两个Kerberos数据库。 但是，默认情况下，信任是可传递的。 如果领域B信任领域A并且领域C信任领域B，那么领域C自动信任领域A而不需要具有可用的主要krbtgt/C@A。 在Kerberos客户端上可能需要一些其他配置（例如capaths），以便客户端能够找到信任路径。 有关更多详细信息，请参阅Kerberos文档。 配置Keycloak服务器 如果您使用具有Kerberos支持的LDAP存储提供程序，则需要为域B配置服务器主体，如下例所示：HTTP/mydomain.com@B。 如果您希望领域A中的用户成功通过Keycloak进行身份验证，则LDAP服务器必须能够从领域A中查找用户，因为Keycloak服务器必须能够执行SPNEGO流，然后才能找到用户。 例如，kerberos主要用户john @ A必须作为LDAP中的用户在LDAP DN下可用，例如uid=john,ou=People,dc=example,dc=com。 如果您希望领域A和B中的用户都进行身份验证，则需要确保LDAP能够从域A和B中查找用户。我们希望在将来的版本中改进此限制，以便您可以创建更多单独的LDAP提供程序 对于单独的领域并确保SPNEGO适用于它们。 如果使用Kerberos用户存储提供程序（通常是没有LDAP集成的Kerberos），则需要将服务器主体配置为HTTP/mydomain.com@B，并且来自Kerberos域A和B的用户都应该能够进行身份验证。 对于Kerberos用户存储提供程序，建议在kerberos领域中没有冲突用户。 如果存在冲突用户，则它们将映射到相同的Keycloak用户。 这也是我们希望在未来版本中改进的东西，并提供从Kerberos主体到Keycloak用户名的一些更灵活的映射。 6.5.7. 故障排除 如果您遇到问题，我们建议您启用其他日志记录来调试问题： 在管理控制台中为Kerberos或LDAP联合提供程序启用Debug标志 在standalone/configuration/standalone.xml的日志记录部分中为类别org.keycloak启用TRACE日志记录，以获得更多信息standalone/log/server.log 添加系统属性-Dsun.security.krb5.debug=true 和 -Dsun.security.spnego.debug=true 6.6. X.509客户端证书用户身份验证 如果服务器配置为进行相互SSL身份验证，Keycloak支持使用X.509客户端证书登录。 典型的工作流程如下： 客户端通过SSL/TLS通道发送身份验证请求 在SSL/TLS握手期间，服务器和客户端交换其x.509/v3 证书 容器(WildFly)验证证书PKIX路径和证书过期 x.509客户端证书身份验证器验证客户端证书，如下所示： （可选）使用CRL和/或CRL分发点检查证书吊销状态 （可选）使用OCSP（在线证书状态协议）检查证书吊销状态 （可选）验证证书中的密钥用法是否与预期的密钥用法匹配 （可选）验证证书中的扩展密钥用法是否与预期的扩展密钥用法匹配 如果上述任何检查失败，则x.509身份验证将失败 否则，验证者提取证书身份并将其映射到现有用户 证书映射到现有用户后，行为会根据身份验证流程而有所不同： 在浏览器流程中，服务器会提示用户确认身份或忽略身份，而是使用用户名/密码登录 在直接授权流程的情况下，服务器登录用户 6.6.1. 特征 支持的证书标识源 使用正则表达式匹配SubjectDNX500主题的电子邮件属性X500来自主题备用名称扩展名的主题电子邮件（RFC822Name通用名称）X500主题备用名称扩展名的主题另一个名称。 这通常是UPN（用户主体名称）X500主题的公共名称attributeMatch IssuerDN使用正则表达式X500颁发者的电子邮件属性X500颁发者的公共名称attributeCertificate序列号 Regular Expressions 可以使用正则表达式作为过滤器从主题DN或颁发者DN中提取证书身份。 例如，下面的正则表达式将匹配电子邮件属性： emailAddress=(.*?)(?:,|$) 正则表达式过滤仅在Identity Source设置为Match SubjectDN using regular expression或Match IssuerDN using regular expression时适用。 将证书身份映射到现有用户 证书身份映射可以配置为将提取的用户身份映射到现有用户的用户名或电子邮件，或映射到与证书身份匹配的自定义属性。 例如，将Identity source设置为 Subject’s e-mail 和 User mapping method设置为 Username or email 将使X.509客户端证书验证者使用证书的主题DN中的电子邮件属性作为 搜索条件，通过用户名或电子邮件查找现有用户。 请注意，如果我们在领域设置中禁用Login with email，则相同的规则将应用于证书身份验证。 换句话说，用户将无法使用电子邮件属性登录。 其他功能：扩展证书验证 使用 CRL/Distribution 进行CRLRevocation状态检查的撤销状态检查使用 OCSP/Responder 进行分发PointRevocation状态检查URICertificate KeyUsage validationCertificate ExtendedKeyUsage验证 6.6.2. 启用X.509客户端证书用户身份验证 以下部分介绍如何配置WildFly/Undertow和Keycloak Server以启用X.509客户端证书身份验证。 在WildFly中启用相互SSL 请参阅 启用SSL 和 SSL 有关如何在WildFly中启用SSL的说明。打开KEYCLOAK_HOME/standalone/configuration/standalone.xml并添加新域： ssl/keystore ssl元素包含keystore元素，该元素定义如何从JKS密钥库加载服务器公钥对 ssl/keystore/path JKS密钥库的路径 ssl/keystore/relative-to 定义密钥库路径相对于的路径 ssl/keystore/keystore-password 用于打开密钥库的密码 ssl/keystore/alias (可选) 密钥库中条目的别名。 如果密钥库包含多个条目，请设置它 ssl/keystore/key-password (可选) 私钥密码，如果与密钥库密码不同。 authentication/truststore 定义如何加载信任存储以验证入站/出站连接的远程端提供的证书。 通常，信任库包含一组可信CA证书。 authentication/truststore/path 包含受信任CA证书（证书颁发机构）的JKS密钥库的路径 authentication/truststore/relative-to 定义信任库路径相对于的路径 authentication/truststore/keystore-password 用于打开信任库的密码 Enable https listener 有关如何在WildFly中启用HTTPS的说明，请参阅HTTPS侦听器。添加元素，如图所示 下面： .... https-listener/security-realm 该值必须与上一节中的域名相匹配 https-listener/verify-client 如果设置为REQUESTED，服务器将可选择请求客户端证书。 如果没有提供客户端证书，则将该属性设置为REQUIRED将使服务器拒绝入站连接。 6.6.3. 将X.509客户端证书身份验证添加到浏览器流 选择一个领域，单击Authentication链接，选择“Browser”流程 制作内置“Browser”流程的副本。 您可能希望为新流程指定一个独特的名称，即“X.509 Browser” 使用下拉列表，选择复制的流程，然后单击“Add execution” 使用下拉菜单选择“X509/Validate User Form”，然后单击“Save” 使用向上/向下箭头，通过在“Browser Forms”执行上方移动“X509/Validate Username Form”的顺序来更改它，并将需求设置为“ALTERNATIVE” 选择“Bindings”选项卡，找到“Browser Flow”的下拉列表。 从下拉列表中选择新创建的X509浏览器流，然后单击“Save”。 配置X.509客户端证书身份验证 User Identity Source 定义如何从客户端证书中提取用户身份。 A regular expression (可选) 定义正则表达式以用作过滤器以提取证书标识。 正则表达式必须包含单个组。 User Mapping Method 定义如何将证书标识与现有用户匹配。 Username or e-mail将通过用户名或电子邮件搜索现有用户。 Custom Attribute Mapper将搜索具有与证书标识匹配的自定义属性的现有用户。 自定义属性的名称是可配置的。 A name of user attribute (可选) 一个自定义属性，该值将与证书标识匹配。 CRL Checking Enabled (可选) 定义是否使用证书吊销列表检查证书的吊销状态。 Enable CRL Distribution Point to check certificate revocation status (可选) 定义是否使用CDP检查证书吊销状态。 大多数PKI机构都在其证书中包含CDP。 CRL file path (可选) 定义包含CRL列表的文件的路径。 如果启用了CRL Checking Enabled选项，则该值必须是有效文件的路径。 OCSP Checking Enabled(可选) 定义是否使用在线证书状态协议检查证书吊销状态。 OCSP Responder URI (可选) 允许覆盖证书中OCSP响应者URI的值。 Validate Key Usage (可选) 验证是否设置了证书的KeyUsage扩展位。 例如，“digitalSignature,KeyEncipherment”将验证KeyUsage扩展中的位0和2是否被断言。 将参数保留为空以禁用密钥用法验证。 参见RFC5280, Section-4.2.1.3。 仅当颁发CA标记为关键时，服务器才会引发错误，并且密钥使用扩展名不匹配。 Validate Extended Key Usage (可选) 验证扩展密钥用法扩展中定义的一个或多个目的。 参见 RFC5280, Section-4.2.1.12。 将参数保留为空以禁用扩展密钥用法验证。 仅当颁发CA标记为关键时，服务器才会引发错误，并且密钥使用扩展名不匹配。 Bypass identity confirmation 如果设置，X.509客户端证书身份验证将不会提示用户确认证书身份，并将在成功身份验证后自动登录用户。 6.6.4. 将X.509客户端证书身份验证添加到直接授权流程 使用Keycloak管理控制台，单击“Authentication”并选择“Direct Grant”流程， 制作内置“Direct Grant”流程的副本。 您可能想给新流程一个独特的名称，即“X509 Direct Grant”， 删除“Username Validation”和“Password”验证者， 单击“Add execution”并添加“X509/Validate Username”并单击“Save”以将执行步骤添加到父流程。 将Requirement更改为REQUIRED。 按照前面x.509浏览器流程部分中描述的步骤设置x509身份验证配置。 选择“Bindings”选项卡，找到“Direct Grant Flow”的下拉列表。 从下拉列表中选择新创建的X509直接授权流程，然后单击“Save”。 6.6.5. 客户端证书查找 当HTTP请求直接发送到Keycloak服务器时，WildFly undertow 子系统将建立SSL握手并提取客户端证书。 然后，客户端证书将保存到HTTP请求的属性javax.servlet.request.X509Certificate中，如servlet规范中所指定。 然后，Keycloak X509身份验证器将能够从此属性中查找证书。 但是，当Keycloak服务器侦听负载均衡器或反向代理后面的HTTP请求时，它可能是代理服务器，它提取客户端证书并建立相互SSL连接。 反向代理通常将经过身份验证的客户端证书放入基础请求的HTTP标头中，并将其转发到后端Keycloak服务器。 在这种情况下，Keycloak必须能够从HTTP标头而不是HTTP请求的属性中查找X.509证书链，就像Undertow所做的那样。 如果Keycloak位于反向代理之后，通常需要在KEYCLOAK_HOME/standalone/configuration/standalone.xml中配置x509cert-lookup SPI的备用提供程序。 除了从HTTP头查找证书的default提供程序外，我们还有两个额外的内置提供程序：haproxy和apache，下面将对其进行描述。 HAProxy证书查找提供程序 当Keycloak服务器位于HAProxy反向代理后面时，您可以使用此提供程序。 像这样配置服务器： haproxy 在此示例配置中，将从HTTP标头SSL_CLIENT_CERT中查找客户端证书，并从HTTP标头中查找其链中的其他证书，如CERT_CHAIN_0，CERT_CHAIN_1，...，CERT_CHAIN_9。 属性certificateChainLength是链的最大长度，因此最后一个尝试的属性将是CERT_CHAIN_9。 有关如何配置客户端证书和客户端证书链的HTTP标头及其专有名称的详细信息，请参阅HAProxy文档。 Apache证书查找提供程序 当Keycloak服务器位于Apache反向代理后面时，您可以使用此提供程序。 像这样配置服务器： apache 配置与haproxy提供程序相同。 请参阅mod_ssl和mod_headers上的有关如何配置客户端证书和客户端证书链的HTTP标头及其专有名称的详细信息。 Nginx证书查找提供程序 当Keycloak服务器位于Nginx反向代理后面时，您可以使用此提供程序。 像这样配置服务器： nginx NGINX SSL/TLS module不公开客户端证书链，因此Keycloak NGINX证书查找提供程序正在使用Keycloak truststore重建它。 请使用keytool CLI填充Keycloak信任库，其中包含重建客户端证书链所需的所有根CA和中间CA. 有关如何配置客户端证书的HTTP标头的详细信息，请参阅NGINX文档。 NGINX配置文件示例： ... server { ... ssl_client_certificate trusted-ca-list-for-client-auth.pem; ssl_verify_client optional_no_ca; ssl_verify_depth 2; ... location / { ... proxy_set_header ssl-client-cert $ssl_client_escaped_cert; ... } ... } 必须将trusted-ca-list-for-client-auth.pem中的所有证书添加到 Keycloak truststore。 其他反向代理实现 我们没有内置支持其他反向代理实现。 但是，可以使其他反向代理以与apache或haproxy类似的方式运行，并且可以使用其中一些提供程序。 如果这些都不起作用，您可能需要创建自己的org.keycloak.services.x509.X509ClientCertificateLookupFactory和org.keycloak.services.x509.X509ClientCertificateLookup提供程序的实现。 有关如何添加自己的提供程序的详细信息，请参阅服务器开发人员指南。 6.6.6. Troubleshooting 转储HTTP标头 如果要查看反向代理发送给Keycloak的内容，只需激活RequestDumpingHandler并查阅server.log文件。 在日志记录子系统下启用TRACE日志记录 ... ... WARNING: Don't use RequestDumpingHandler or TRACE logging in production. 使用X.509直接授予身份验证 以下模板可用于使用资源所有者密码凭据授权请求令牌： $ curl https://[host][:port]/auth/realms/master/protocol/openid-connect/token \\ --insecure \\ --data \"grant_type=password&scope=openid profile&username=&password=&client_id=CLIENT_ID&client_secret=CLIENT_SECRET\" \\ -E /path/to/client_cert.crt \\ --key /path/to/client_cert.key [host][:port] 已配置为允许用户使用Direct Grant Flow对x.509客户端证书进行身份验证的远程Keycloak服务器的主机和端口号。 CLIENT_ID 客户端ID。 CLIENT_SECRET 对于机密客户，客户机密; 否则，留空。 client_cert.crt 公钥证书，用于在相互SSL身份验证中验证客户端的身份。 证书应采用PEM格式。 client_cert.key 公钥对中的私钥。 也期望以PEM格式。 7. SSO协议 本章简要概述了身份验证协议以及Keycloak身份验证服务器及其保护的应用程序如何与这些协议进行交互。 7.1. OpenID 连接 OpenID Connect (OIDC)是一种身份验证协议，是 OAuth 2.0的扩展。 虽然OAuth 2.0只是构建授权协议的框架，但主要是不完整的，OIDC是一种成熟的身份验证和授权协议。 OIDC还大量使用 Json Web Token (JWT) 标准集。 这些标准定义了身份令牌JSON格式以及以紧凑和Web友好的方式对数据进行数字签名和加密的方法。 使用OIDC时，实际上有两种用例。 第一个是要求Keycloak服务器为用户验证用户的应用程序。 成功登录后，应用程序将收到 identity token 和 access token。 identity token包含有关用户的信息，例如用户名，电子邮件和其他个人资料信息。 access token由领域进行数字签名，并包含访问信息（如用户角色映射），应用程序可以使用该信息来确定允许用户在应用程序上访问哪些资源。 第二种用例是希望获得远程服务访问权限的客户端。 在这种情况下，客户端要求Keycloak获取access token，它可以代表用户在其他远程服务上调用。 Keycloak对用户进行身份验证，然后要求用户同意授予访问请求它的客户端的权限。 然后客户端接收access token。 此access token由领域进行数字签名。 客户端可以使用此access token在远程服务上进行REST调用。 REST服务提取access token，验证令牌的签名，然后根据令牌内的访问信息决定是否处理请求。 7.1.1. OIDC Auth Flows OIDC有不同的方式让客户端或应用程序对用户进行身份验证并接收identity和access令牌。 您使用的路径在很大程度上取决于请求访问的应用程序或客户端的类型。 所有这些流程都在OIDC和OAuth 2.0规范中进行了描述，因此这里仅提供简要概述。 授权代码流程 这是一个基于浏览器的协议，我们建议您使用它来验证和授权基于浏览器的应用程序。 它大量使用浏览器重定向来获取identity和access令牌。 这是一个简短的总结： 浏览器访问应用, 应用程序注意到用户未登录，因此它将浏览器重定向到Keycloak进行身份验证。 应用程序传递回调URL（重定向URL）作为此浏览器重定向中的查询参数，Keycloak将在完成身份验证时使用该重定向。 Keycloak对用户进行身份验证，并创建一次性的，非常短暂的临时代码。 Keycloak使用前面提供的回调URL重定向回应用程序，另外还将临时代码作为查询参数添加到回调URL中。 应用程序提取临时代码并将带外REST调用的后台调用到Keycloak，以交换identity，access和refresh token的代码。 一旦使用此临时代码一次获取令牌，就永远不能再使用它。 这可以防止潜在的重播攻击。 重要的是要注意access令牌通常是短暂的，并且经常在几分钟后过期。 登录协议传输的附加refresh令牌允许应用程序在到期后获取新的访问令牌。 此刷新协议在受损系统的情况下非常重要。 如果访问令牌是短暂的，则整个系统仅在访问令牌的生命周期中容易受到被盗令牌的攻击。 如果管理员已撤销访问权限，则未来的刷新令牌请求将失败。 这使事情更安全，更具可扩展性。 此流程的另一个重要方面是public 与 confidential客户端的概念。 Confidential客户在交换令牌的临时代码时需要提供客户机密。 Public客户不需要提供此客户机密钥。只要严格执行HTTPS并且您对为客户端注册的重定向URI非常严格，Public客户端就完全没问题。 HTML5/JavaScript客户端必须始终是public客户端，因为无法以安全的方式将客户端密钥传输给它们。 再次，只要您使用HTTPS并严格执行重定向URI注册，这就没问题。 本指南在管理客户端章节中详细介绍了这一点。 Keycloak还支持可选的代码交换证明密钥规范。 隐式流 这是一种基于浏览器的协议，类似于授权代码流，除了涉及的请求较少且没有刷新令牌。 我们不建议使用此流程，因为由于重定向URI（见下文）传递令牌，因此在浏览器历史记录中可能会泄漏access令牌。 此外，由于此流程不向客户端提供刷新令牌，因此访问令牌必须是长期存在的，或者用户在过期时必须重新进行身份验证。 支持此流程，因为它符合OIDC和OAuth 2.0规范。 以下是协议的简短摘要： 浏览器访问应用 应用程序注意到用户未登录，因此它将浏览器重定向到Keycloak进行身份验证。 应用程序传递回调URL（重定向URL）作为此浏览器重定向中的查询参数，Keycloak将在完成身份验证时使用该重定向。 Keycloak对用户进行身份验证并创建identity和access令牌。 Keycloak使用前面提供的回调URL重定向回应用程序，并在回调URL中另外添加identity和access tokens作为查询参数。 应用程序从回调URL中提取identity和access标记。 资源所有者密码凭据授予 (直接访问授予) 这在管理控制台中称为Direct Access Grants。 这是由希望代表用户获取令牌的REST客户端使用的。 它是一个HTTP POST请求，包含用户的凭据以及客户端的ID和客户端的秘密（如果它是机密客户端）。 用户的凭据在表单参数内发送。 HTTP响应包含identity，access和refresh tokens。 客户凭证授权 REST客户端也使用它，但不是获取代表外部用户工作的令牌，而是根据与客户端关联的服务帐户的元数据和权限创建令牌。 更多信息和示例在服务帐户章节中。 7.1.2. Keycloak Server OIDC URI端点 这是Keycloak发布的OIDC端点列表。 如果您使用非Keycloak客户端适配器与OIDC与auth服务器通信，这些URL非常有用。 这些都是相对URL，URL的根是HTTP(S)协议，主机名，通常以/auth为前缀的路径：即https://localhost:8080/auth /realms/{realm-name}/protocol/openid-connect/token 这是用于在授权代码流中获取临时代码或通过隐式流，直接授权或客户端授权获取令牌的URL端点。 /realms/{realm-name}/protocol/openid-connect/auth 这是授权代码流将临时代码转换为令牌的URL端点。 /realms/{realm-name}/protocol/openid-connect/logout 这是执行注销的URL端点。 /realms/{realm-name}/protocol/openid-connect/userinfo 这是OIDC规范中描述的用户信息服务的URL端点。 在所有这些中，将{realm-name}替换为领域的名称。 7.2. SAML SAML 2.0 是与OIDC类似的规范，但是更老，更成熟。 它的根源在于SOAP和过多的WS-*规范，所以它往往比OIDC更冗长。 SAML 2.0主要是一种身份验证协议，通过在身份验证服务器和应用程序之间交换XML文档来工作。 XML签名和加密用于验证请求和响应。 使用SAML时，实际上有两种用例。 第一个是要求Keycloak服务器为用户验证用户的应用程序。 成功登录后，应用程序将收到一个XML文档，其中包含称为SAML断言的内容，该断言指定了有关用户的各种属性。 此XML文档由领域进行数字签名，并包含访问信息（如用户角色映射），应用程序可以使用该信息来确定允许用户在应用程序上访问哪些资源。 第二种用例是希望获得远程服务访问权限的客户端。 在这种情况下，客户端要求Keycloak获取一个SAML断言，它可以代表用户在其他远程服务上调用它。 7.2.1.SAML绑定 SAML定义了在执行身份验证协议时交换XML文档的几种不同方法。 Redirect和Post绑定涵盖基于浏览器的应用程序。 ECP绑定涵盖REST调用。 还有其他绑定类型，但Keycloak只支持这三种。 重定向绑定 Redirect 绑定 使用一系列浏览器重定向URI来交换信息。 这是它如何工作的粗略概述。 用户访问应用程序，应用程序发现用户未经过身份验证。 它生成XML身份验证请求文档，并将其编码为URI中的查询参数，该URI用于重定向到Keycloak服务器。 根据您的设置，应用程序还可以对此XML文档进行数字签名，并将此签名作为查询参数填充到Keycloak的重定向URI中。 此签名用于验证发送此请求的客户端。 浏览器被重定向到Keycloak。 服务器提取XML身份验证请求文档，并在需要时验证数字签名。 然后，用户必须输入他们的凭证才能进行身份验证。 身份验证后，服务器生成XML身份验证响应文档。 本文档包含一个SAML断言，其中包含有关用户的元数据，如名称，地址，电子邮件以及用户可能拥有的任何角色映射。 该文档几乎总是使用XML签名进行数字签名，也可以加密。 然后将XML身份验证响应文档编码为重定向URI中的查询参数，该重定向URI将浏览器带回应用程序。 数字签名也包括在查询参数中。 应用程序接收重定向URI并提取XML文档并验证领域的签名以确保它正在接收有效的身份验证响应。 然后，SAML断言内的信息用于制定访问决策或显示用户数据。 POST 绑定 SAML POST绑定的工作方式几乎与Redirect绑定完全相同，但不是GET请求，而是通过POST请求交换XML文档。 POST Binding使用JavaScript来欺骗浏览器在交换文档时向Keycloak服务器或应用程序发出POST请求。 基本上，HTTP响应包含一个HTML文档，其中包含带有嵌入式JavaScript的HTML表单。 加载页面时，JavaScript会自动调用表单。 你真的不需要知道这些东西，但这是一个非常聪明的技巧。 由于安全性和大小限制，通常建议使用POST绑定。 使用REDIRECT时，SAML响应是URL的一部分（它是之前解释过的查询参数），因此可以在日志中捕获它，并且它被认为不太安全。 关于大小，如果断言包含很多或大的属性，则在HTTP有效负载内发送文档总是比在更有限的URL中更好。 ECP ECP代表“Enhanced Client or Proxy(增强客户端或代理)”，SAML v.2.0配置文件，允许在Web浏览器的上下文之外交换SAML属性。 这通常用于REST或基于SOAP的客户端。 7.2.2. Keycloak Server SAML URI端点 Keycloak实际上只有一个端点用于所有SAML请求。 http(s)://authserver.host/auth/realms/{realm-name}/protocol/saml 所有绑定都使用此端点。 7.3. OpenID Connect 与 SAML 在OpenID Connect和SAML之间进行选择不仅仅是使用更新的协议（OIDC）而不是旧的更成熟的协议（SAML）。 在大多数情况下，Keycloak建议使用OIDC。 SAML往往比OIDC更冗长。 除了交换数据的详细程度之外，如果您比较规范，您会发现OIDC旨在与Web一起工作，同时SAML被改装为在Web上运行。 例如，OIDC也更适合HTML5/JavaScript应用程序，因为它比SAML更容易在客户端实现。 由于令牌采用JSON格式，因此JavaScript更易于使用。 您还将找到一些很好的功能，可以更轻松地在Web应用程序中实现安全性。 例如，查看规范用于轻松确定用户是否仍在登录的iframe技巧。 SAML虽然有它的用途。 正如您所看到的，OIDC规范的发展，您会发现它们实现了SAML多年来所拥有的越来越多的功能。 我们经常看到人们选择SAML而不是OIDC，因为人们认为它更成熟，也因为他们已经有了现有的应用程序。 7.4. Docker Registry v2身份验证 默认情况下禁用Docker身份验证。 要启用，请参阅 Profiles。 Docker Registry V2身份验证是一种OIDC-Like协议，用于根据Docker注册表对用户进行身份验证。 Keycloak对此协议的实现允许Docker客户端使用Keycloak身份验证服务器对注册表进行身份验证。 虽然该协议使用相当标准的令牌和签名机制，但它有一些缺点，使其不能被视为真正的OIDC实现。 最大的偏差包括用于请求和响应的非常特定的JSON格式，以及了解如何将存储库名称和权限映射到OAuth范围机制的能力。 7.4.1. Docker 验证 流程 Docker API文档 最好地描述和说明了这个过程，但是下面将从Keycloak认证服务器的角度给出一个简短的总结。 此流假定已执行docker login命令 当Docker客户端从Docker注册表请求资源时，流程开始。 如果资源受到保护且请求中不存在身份验证令牌，则Docker注册服务器将使用401 +响应客户端，获取有关所需权限的信息以及在何处查找授权服务器。 Docker客户端将根据Docker注册表中的401响应构造一个身份验证请求。 然后，客户端将使用本地缓存的凭据（来自以前运行的docker login命令）作为HTTP基本身份验证对Keycloak身份验证服务器的请求的一部分。 Keycloak身份验证服务器将尝试对用户进行身份验证，并返回包含OAuth样式的Bearer令牌的JSON正文。 Docker客户端将从JSON响应中获取承载令牌，并在Authorization标头中使用它来请求受保护资源。 当Docker注册表使用来自Keycloak服务器的令牌接收受保护资源的新请求时，注册表将验证令牌并授予对所请求资源的访问权限（如果适用）。 7.4.2. Keycloak Docker Registry v2身份验证服务器URI端点 Keycloak实际上只有一个端点用于所有Docker auth v2请求。 http(s)://authserver.host/auth/realms/{realm-name}/protocol/docker-v2 8. 管理客户端 客户端是可以请求用户身份验证的实体。 客户有两种形式。 第一种类型的客户端是想要参与单点登录的应用程序。 这些客户只希望Keycloak为他们提供安全保障。 另一种类型的客户端是请求访问令牌的客户端，以便它可以代表经过身份验证的用户调用其他服务。 本节讨论有关配置客户端的各个方面以及执行此操作的各种方法。 8.1. OIDC 客户端 OpenID Connect是保护应用程序的首选协议。 它的设计从一开始就是Web友好的，并且最适合HTML5/JavaScript应用程序。 要创建OIDC客户端，请转到Clients左侧菜单项。 在此页面上，您将看到右侧的Create按钮。 Clients 这将带您进入Add Client页面。 Add Client 输入客户端的Client ID。 这应该是一个简单的字母数字字符串，将在请求和Keycloak数据库中用于标识客户端。 接下来在Client Protocol下拉框中选择openid-connect。 最后在Root URL字段中输入应用程序的基本URL，然后单击Save。 这将创建客户端并将您带到客户端Settings选项卡。 Client Settings 让我们来看看这个页面上的每个配置项。 Client ID 这指定了一个字母数字字符串，该字符串将用作OIDC请求的客户端标识符。 Name 这是客户端在Keycloak UI屏幕中显示时的显示名称。 您可以通过设置替换字符串值(即${myapp})来本地化此字段的值。 有关详细信息，请参阅Server Developer Guide。 Description 这指定了客户端的描述。 这也可以是本地化的。 Enabled 如果关闭此选项，则不允许客户端请求身份验证。 Consent Required 如果启用此选项，则用户将获得一个同意页面，询问用户是否授予对该应用程序的访问权限。 它还将显示客户端感兴趣的元数据，以便用户确切地知道客户端可以访问哪些信息。 如果您曾经对Google进行过社交登录，那么您通常会看到类似的页面。 Keycloak提供相同的功能。 Access Type 这定义了OIDC客户端的类型。 confidential 机密访问类型适用于需要执行浏览器登录并在将访问代码转换为访问令牌时需要客户端密钥的服务器端客户端（请参阅访问令牌请求 有关详细信息，请参阅OAuth 2.0规范）。 此类型应用于服务器端应用程序。 public 公共访问类型适用于需要执行浏览器登录的客户端客户端。 使用客户端应用程序无法保密。 相反，通过为客户端配置正确的重定向URI来限制访问非常重要。 bearer-only 仅承载访问类型意味着应用程序仅允许承载令牌请求。 如果启用此选项，则此应用程序无法参与浏览器登录。 Root URL 如果Keycloak使用任何已配置的相对URL，则会为其添加此值。 Valid Redirect URIs 这是一个必填字段。 输入网址格式，然后点击要添加的+号。 点击要删除的网址旁边的-符号。 请记住，您仍然需要单击Save按钮！ 通配符(*)仅允许在URI的末尾，例如: http://host.com/* 注册有效的重定向URI模式时，应采取额外的预防措施。 如果你使它们过于笼统，你很容易受到攻击。 有关详细信息，请参阅威胁模型缓解 一章。 Base URL 如果Keycloak需要链接到客户端，则使用此URL。 Standard Flow Enabled 如果启用此选项，则允许客户端使用OIDC 授权代码流程。 Implicit Flow Enabled 如果启用此选项，则允许客户端使用OIDC 隐式流程。 Direct Grants Enabled 如果启用此选项，则允许客户使用OIDC Direct Grants。 Admin URL 对于Keycloak特定的客户端适配器，这是客户端的回调端点。 Keycloak服务器将使用此URI进行回调，例如推送撤销策略，执行反向通道注销以及其他管理操作。 对于Keycloak servlet适配器，这可以是servlet应用程序的根URL。 有关详细信息，请参阅保护应用程序和服务指南。 Web Origins 该选项以CORS为中心，代表跨源资源共享。 如果浏览器JavaScript尝试向其域与JavaScript代码所来的域不同的服务器发出AJAX HTTP请求，则该请求必须使用CORS。 服务器必须以特殊方式处理CORS请求，否则浏览器将不会显示或允许处理请求。 此协议用于防止XSS，CSRF和其他基于JavaScript的攻击。 Keycloak支持经过验证的CORS请求。 它的工作方式是客户端的Web Origins设置中列出的域嵌入发送到客户端应用程序的访问令牌中。 然后，客户端应用程序可以使用此信息来决定是否允许在其上调用CORS请求。 这是OIDC协议的扩展，因此只有Keycloak客户端适配器支持此功能。 有关详细信息，请参阅保护应用程序和服务指南。 要填写Web Origins数据，请输入基本URL并单击要添加的+号。 点击要删除的网址旁边的- 符号。 请记住，您仍然需要单击Save按钮！ 8.1.1. 高级设置 OAuth 2.0 Mutual TLS客户端证书绑定访问令牌 Mutual TLS使用在TLS握手期间交换的客户端证书绑定访问令牌和刷新令牌。 这可以防止找到窃取这些令牌的方法的攻击者行使令牌。 这种类型的令牌称为持有者令牌。 与承载令牌不同，持有者令牌的接收者可以验证令牌的发送者是否合法。 如果令牌请求满足以下条件，Keycloak将使用客户端证书绑定访问令牌和刷新令牌，并将其作为持有者令牌发布。 如果不满足所有条件，Keycloak将拒绝令牌请求。 该功能已打开 令牌请求在授权代码流或混合流中发送到令牌端点 在TLS握手时，Keycloak请求客户端证书，客户端发送其客户端证书 在TLS握手时，Keycloak成功验证了客户端证书 要在Keycloak中启用相互TLS，请参阅在WildFly中启用相互SSL。 在以下情况下，Keycloak将验证客户端发送访问令牌或刷新令牌; 如果验证失败，Keycloak拒绝令牌。 使用持有者刷新令牌将令牌刷新请求发送到令牌端点 UserInfo请求通过持有者密钥访问令牌发送到UserInfo端点 使用持有者刷新令牌将注销请求发送到Logout端点 请参阅OAuth 2.0 Mutual TLS客户端身份验证和证书绑定访问中的Mutual TLS客户端证书绑定访问令牌 令牌更多细节。 警告：目前没有任何keycloak客户端适配器支持持有者令牌验证。 相反，keycloak适配器当前将访问和刷新令牌视为承载令牌。 8.1.2. 机密客户端凭据 如果您已在客户端的Settings选项卡中将客户端的访问类型设置为confidential，则为新的 Credentials选项卡将显示出来。 作为处理此类客户端的一部分，您必须配置客户端的凭据。 Credentials Tab Client Authenticator列表框指定您将用于机密客户端的凭据类型。 它默认为客户端ID和秘密。 秘密会自动为您生成，Regenerate Secret按钮允许您根据需要或需要重新创建此秘密。 Alternatively, you can opt to use a signed Json Web Token (JWT) or x509 certificate validation (also called Mutual TLS) instead of a secret. Signed JWT 选择此凭据类型时，您还必须为客户端生成私钥和证书。 私钥将用于签署JWT，而服务器使用证书来验证签名。 单击Generate new keys and certificate按钮以启动此过程。 Generate Keys 当您生成这些密钥时，Keycloak将存储证书，您需要下载私钥和证书供您的客户使用。 选择所需的存档格式，并指定私钥和存储的密码。 您也可以选择通过外部工具生成这些内容，然后只导入客户端证书。 Import Certificate 您可以导入多种格式，只需选择存储证书的存档格式，选择文件，然后单击Import按钮。 最后请注意，如果选择Use JWKS URL，则甚至不需要导入证书。 在这种情况下，您可以在JWK格式中提供客户端发布公钥的URL。 这很灵活，因为当客户更改密钥时，Keycloak会自动下载它们，而无需在Keycloak端重新导入任何内容。 如果您使用由Keycloak适配器保护的客户端，您可以配置JWKS URL，如，假设是客户端应用程序的根URL。 有关其他详细信息，请参阅Server Developer Guide。 出于性能目的，Keycloak缓存OIDC客户端的公钥。 如果您认为客户端的私钥被泄露，那么更新密钥显然很好，但清除密钥缓存也很好。 有关详细信息，请参阅清除缓存部分。 Signed JWT with Client Secret 如果在Client Authenticator列表框中选择此选项，则可以使用由客户端密钥签名的JWT而不是私钥。 此客户端密钥将用于由客户端签署JWT。 X509 Certificate 通过启用此选项，Keycloak将验证客户端是否在TLS握手期间使用正确的X509证书。 此选项需要Keycloak中的相互TLS，请参阅在WildFly中启用相互SSL。 Import Certificate 验证器还使用配置的regexp验证表达式检查证书的Subject DN字段。 对于某些用例，接受所有证书就足够了。 在这种情况下，您可以使用 (.*?)(?:$) 表达式。 Keycloak有两种方法从请求中获取客户端ID。 第一个选项是查询中的client_id参数（在[OAuth 2.0规范]的第2.2节(https://tools.ietf.org/html/rfc6749)中描述）。 第二个选项是提供client_id作为查询参数。 8.1.3. 服务帐户 每个OIDC客户端都有一个内置的service account，允许它获取访问令牌。 这在[客户端凭据授权]（(https://www.keycloak.org/docs/latest/server_admin/index.html#_client_credentials_grant)下的OAuth 2.0规范中介绍。 要使用此功能，您必须将客户端的访问类型设置为confidential。 执行此操作时，将显示Service Accounts Enabled开关。 您需要打开此开关。 还要确保已配置客户端凭据。 要使用它，您必须注册一个有效的confidential客户端，并且您需要在Keycloak管理控制台中检查此客户端的Service Accounts Enabled。 在Service Account Roles选项卡中，您可以配置代表此客户端检索的服务帐户可用的角色。 请记住，除非您具有Full Scope Allowed，否则您必须具有此客户端的角色范围映射（选项卡Scope）中可用的角色。 与正常登录一样，访问令牌中的角色是以下内容的交集： 特定客户端的角色范围映射与从链接的客户端范围继承的角色范围映射相结合 服务帐户角色 要调用的REST URL是/auth/realms/{realm-name}/protocol/openid-connect/token。 调用此URL是POST请求，并要求您发布客户端凭据。 默认情况下，客户端凭据由Authorization: Basic标头中的客户端的clientId和clientSecret表示，但您也可以使用签名的JWT断言或任何其他自定义机制对客户端进行身份验证来验证客户端。 您还需要根据OAuth2规范使用参数grant_type=client_credentials。 例如，用于检索服务帐户的POST调用可能如下所示： POST /auth/realms/demo/protocol/openid-connect/token Authorization: Basic cHJvZHVjdC1zYS1jbGllbnQ6cGFzc3dvcmQ= Content-Type: application/x-www-form-urlencoded grant_type=client_credentials 响应将来自OAuth 2.0规范中的[标准JSON文档]（(https://tools.ietf.org/html/rfc6749#section-4.4.3)。 HTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\", \"token_type\":\"bearer\", \"expires_in\":60, \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\", \"refresh_expires_in\":600, \"id_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\", \"not-before-policy\":0, \"session_state\":\"234234-234234-234234\" } 可以通过越界请求刷新或注销检索到的访问令牌。 8.1.4. 受众支持 部署Keycloak的典型环境通常包括一组confidential或public客户端应用程序（前端客户端应用程序），它们使用Keycloak进行身份验证。 还有services（在OAuth 2规范中称为Resource Servers），它服务于来自前端客户端应用程序的请求并提供资源。 这些服务通常需要向其发送Access token（Bearer token(承载令牌)）以针对特定请求进行身份验证。 此令牌以前是由前端应用程序尝试登录Keycloak时获得的。 在服务之间的信任度较低的环境中，您可能会遇到以下情况： 名为my-app的前端客户端需要针对Keycloak进行身份验证。 用户在Keycloak中进行了身份验证。 Keycloak随后向my-app应用程序发出了令牌。 应用程序my-app使用令牌来调用服务evil-service。 应用程序需要调用evil-service，因为服务能够提供一些非常有用的数据。 evil-service应用程序将响应返回给my-app。 但是，与此同时，它保留了先前发送给它的令牌。 然后，evil-service应用程序使用先前保存的令牌调用另一个名为good-service的服务。 调用成功，good-service返回数据。 这导致安全性被破坏，因为evil-service使用令牌来代表客户端my-app访问其他服务。 在服务之间具有高度信任的许多环境中，该流程可能不是问题。 然而，在服务之间的信任度较低的其他环境中，这可能是有问题的。 在某些环境中，此示例工作流可能甚至是请求的行为，因为evil-service可能需要从good-service检索其他数据，以便能够将请求的数据正确地返回给原始调用者（my-app客户端））。 您可能会注意到Kerberos凭据委派的相似之处。 与Kerberos凭证委派一样，无限受众是一种喜忧参半的祝福，因为它仅在服务之间存在高度信任时才有用。 否则，建议限制观众，如下所述。 你可以限制观众，同时允许evil-service从good-service中检索所需的数据。 在这种情况下，您需要确保将evil-service和good-service添加为令牌的受众。 为防止滥用访问令牌，如上例所示，建议限制令牌上的Audience并配置您的服务以验证令牌上的受众。 如果这样做，上面的流程将会改变，如下所示： 名为my-app的前端客户端需要针对Keycloak进行身份验证。 用户在Keycloak中进行了身份验证。 Keycloak随后向my-app应用程序发出了令牌。 客户端应用程序已经知道它将需要调用服务evil-service，因此它在发送给Keycloak服务器的身份验证请求中使用了scope=evil-service。 有关scope参数的更多详细信息，请参见Client Scopes部分。 发给my-app客户端的令牌包含受众，如\"audience\"：[\"evil-service\"]，它声明客户端想要使用此访问令牌来仅调用服务evil-service。 evil-service应用程序向my-app提供了请求。 同时，它保留了先前发送给它的令牌。 然后，evil-service应用程序使用先前保存的令牌调用good-service。 调用没有成功，因为good-service检查了令牌上的受众，并且它看到受众只是evil-service。 这是预期的行为，安全性没有被打破。 如果客户端想要稍后调用good-service，则需要通过使用scope=good-service发出SSO登录来获取另一个令牌。 然后，返回的令牌将包含good-service作为受众： \"audience\": [ \"good-service\" ] 并可用于调用good-service。 设置 要正确设置受众群体检查： 确保通过在适配器配置中添加标志verify-token-audience，将服务配置为检查发送给它们的访问令牌的受众。 有关详细信息，请参阅适配器配置。 确保当Keycloak发出访问令牌时，它包含所有请求的受众，并且不包含任何不需要的受众。 可以根据下一节中描述的客户端角色自动添加受众，也可以按照描述进行硬编码下文。 自动添加受众群体 在默认客户端范围roles中，定义了Audience Resolve协议映射器。 此协议映射器将检查当前令牌至少具有一个可用客户端角色的所有客户端。 然后，每个客户端的客户端ID将自动添加为受众。 如果您的服务（通常仅限于承载）客户端依赖客户端角色，则此功能尤其有用。 举个例子，让我们假设您有一个仅限持有客户端good-service和机密客户端my-app，您要对其进行身份验证，然后使用为my-app发出的访问令牌来 调用good-service REST服务。 如果以下情况属实： good-service客户端有自己定义的任何客户角色 目标用户至少分配了一个客户端角色 客户端my-app具有指定角色的角色范围映射 那么good-service将自动作为观众添加到为my-app发布的访问令牌中。 如果要确保不自动添加受众，请不要直接在my-app客户端上配置角色作用域映射，而是创建一个专用的客户端作用域，例如名为good-service，它将包含角色good-service客户端的客户端角色的范围映射。 假设此客户端作用域将作为可选的客户端作用域添加到my-app客户端，则只有在scope=good-service参数明确请求时，才会将客户端角色和受众添加到令牌中。 前端客户端本身不会自动添加到访问令牌受众。 这允许容易区分访问令牌和ID令牌，因为访问令牌将不包含作为受众发布令牌的客户端。 因此，在上面的示例中，my-app不会作为受众添加。 如果您需要客户本身作为受众，请参阅硬编码的受众 选项。 但是，不建议使用相同的客户端作为前端和REST服务。 硬编码的受众 对于您的服务依赖于领域角色或根本不依赖于令牌中的角色的情况，使用硬编码的受众可能很有用。 这是一个协议映射器，它将指定服务客户端的客户端ID作为标记的受众添加。 如果您需要不同于客户端ID的受众，您甚至可以使用任何自定义值，例如某些URL。 您可以将协议映射器直接添加到前端客户端，但始终会添加受众。 如果您想要更精细的控制，可以在专用的客户端范围上创建协议映射器，例如good-service。 受众协议映射器 从good-service客户端的安装选项卡 ，您可以生成适配器配置，您可以确认verify-token-audience选项将设置为true。 这表示如果使用此生成的配置，适配器将需要验证受众。 最后，您需要确保my-app前端客户端能够在其令牌中请求good-service作为受众。 在my-app客户端上，单击Client Scopes选项卡。 然后将good-service指定为可选（或默认）客户端范围。 有关详细信息，请参阅客户端范围链接部分。 您可以选择评估客户端范围并生成示例访问令牌。 如果这样做，请注意，只有在您将其指定为可选客户端范围的情况下，scope参数中包含good-service时，才会将good-service添加到生成的访问令牌的受众中。 在你的my-app应用程序中，当你想发出用于访问good-service的令牌时，你必须确保scope参数与值'good-service`一起使用。 如果您的应用程序使用servlet适配器，请参阅参数转发部分，或javascript adapter section，如果您的应用程序使用javascript适配器。 如果您不确定令牌中的正确受众和角色是什么，那么评估客户端范围总是一个好主意,在管理控制台中并围绕它进行一些测试。 Audience 和 Audience Resolve协议映射器默认情况下仅将访客添加到访问令牌。 ID令牌通常仅包含单个受众，即为其颁发令牌的客户端的客户端ID。 这是OpenID Connect规范的要求。 另一方面，访问令牌不一定具有客户端的客户端ID，该客户端ID是为其颁发的令牌，除非任何观众映射器添加了它。 8.2. SAML 客户端 Keycloak支持SAML 2.0用于已注册的应用程序。 POST和Redirect绑定都受支持。 您可以选择要求客户端签名验证，也可以让服务器签名和/或加密响应。 要创建SAML客户端，请转到Clients左侧菜单项。 在此页面上，您将看到右侧的Create按钮。 Clients 这将带您进入Add Client页面。 Add Client 输入客户端的Client ID。 这通常是一个URL，并且是应用程序发送的SAML请求中预期的issuer值。 接下来在Client Protocol下拉框中选择saml。 最后输入Client SAML Endpoint URL。 输入您希望Keycloak服务器向其发送SAML请求和响应的URL。 通常，应用程序只有一个用于处理SAML请求的URL。 如果您的应用程序的绑定具有不同的URL，请不要担心，您可以在客户端的Settings选项卡中修复此问题。 点击Save。 这将创建客户端并将您带到客户端Settings选项卡。 Client Settings Client ID 此值必须与AuthNRequests发送的颁发者值相匹配。 Keycloak将从Authn SAML请求中提取发行者，并通过此值将其与客户端匹配。 Name 这是客户端在Keycloak UI屏幕中显示时的显示名称。 您可以通过设置替换字符串值（即${myapp}）来本地化此字段的值。 有关详细信息，请参阅Server Developer Guide。 Description 这指定了客户端的描述。 这也可以是本地化的。 Enabled 如果关闭此选项，则不允许客户端请求身份验证。 Consent Required 如果启用此选项，则用户将获得一个同意页面，询问用户是否授予对该应用程序的访问权限。 它还将显示客户端感兴趣的元数据，以便用户确切地知道客户端可以访问哪些信息。 如果您曾经对Google进行过社交登录，那么您通常会看到类似的页面。 Keycloak提供相同的功能。 Include AuthnStatement SAML登录响应可以指定使用的身份验证方法（密码等）以及登录的时间戳。 将此设置为on将在响应文档中包含该语句。 Sign Documents 打开时，Keycloak将使用领域的私钥对文档进行签名。 Optimize REDIRECT signing key lookup 打开时，SAML协议消息将包含Keycloak本机扩展，其中包含带有签名密钥ID的提示。 当SP理解此扩展时，它可以将其用于签名验证，而不是尝试使用所有已知密钥验证签名。 此选项仅适用于REDIRECT绑定，其中签名在查询参数中传输，其中签名信息中没有此信息的位置（与文档签名中始终包含密钥ID的POST绑定消息相反）。 目前，这与Keycloak服务器和适配器提供IDP和SP的情况相关。 此选项仅在Sign Documents打开时有效。 Sign Assertions Sign Documents开关标志整个文件。 通过此设置，断言也会被签名并嵌入到SAML XML Auth响应中。 Signature Algorithm 选择用于签署SAML文档的各种算法。 SAML Signature Key Name 通过POST绑定发送的签名SAML文档包含KeyName元素中的签名密钥的标识。 默认情况下，此项包含Keycloak密钥ID。 然而，各种供应商可能期望具有不同的密钥名称或根本没有密钥名称。 此开关控制KeyName是否包含密钥ID（选项KEY_ID），来自对应于领域密钥的证书（选项CERT_SUBJECT - 例如Microsoft Active Directory联合服务预期），或者密钥名称提示是完全的 从SAML消息中省略（选项NONE）。 Canonicalization Method XML签名的规范化方法。 Encrypt Assertions 使用领域的私钥加密SAML文档中的断言。 AES算法的密钥大小为128位。 Client Signature Required 期望来自客户的文档已签名。 Keycloak将使用在SAML Keys选项卡中设置的客户端公钥或证书来验证此签名。 Force POST Binding 默认情况下，Keycloak将使用原始请求的初始SAML绑定进行响应。 通过打开此开关，即使原始请求是重定向绑定，您也将强制Keycloak始终使用SAML POST绑定进行响应。 Front Channel Logout 如果为true，则此应用程序需要浏览器重定向才能执行注销。 例如，应用程序可能需要重置cookie，这只能通过重定向完成。 如果此开关为false，则Keycloak将调用后台SAML请求以注销该应用程序。 Force Name ID Format 如果请求具有名称ID策略，请忽略它并使用名称ID格式下管理控制台中配置的值 Name ID Format 名称ID主题的格式。 如果请求中未指定名称ID策略，或者“强制名称ID格式”属性为true，则使用此值。 用于每种格式的属性定义如下。 Root URL 如果Keycloak使用任何已配置的相对URL，则会为其添加此值。 Valid Redirect URIs 这是个可选的选项。 输入网址格式，然后点击要添加的 + 号。 点击要删除的网址旁边的 - 符号。 请记住，您仍然需要单击Save按钮！ 通配符(*) 仅允许在URI的末尾，即http://host.com/*。 如果未注册确切的SAML端点且Keycloak正在从请求中提取断言使用者URL，则使用此字段。 Base URL 如果Keycloak需要链接到客户端，则将使用此URL。 Master SAML Processing URL 此URL将用于所有SAML请求，并且响应将定向到SP。 它将用作断言使用者服务URL和单一注销服务URL。 如果登录请求包含断言使用者服务URL，则该URL优先，但此URL必须由注册的有效重定向URI模式进行保护 Assertion Consumer Service POST Binding URL 断言使用者服务的POST绑定URL。 Assertion Consumer Service Redirect Binding URL 重定向断言使用者服务的绑定URL。 Logout Service POST Binding URL 注销服务的POST绑定URL。 Logout Service Redirect Binding URL 重定向注销服务的绑定URL。 8.2.1. IDP发起登录 IDP Initiated Login是一项功能，允许您在Keycloak服务器上设置端点，该端点将登录到特定的应用程序/客户端。 在客户端的Settings选项卡中，您需要指定IDP Initiated SSO URL Name。 这是一个简单的字符串，里面没有空格。 在此之后，您可以通过以下URL引用您的客户端：root/auth/realms/{realm}/protocol/saml/clients/{url-name} IDP发起的登录实现更喜欢POST 通过 REDIRECT 绑定（检查saml bindings以获取更多信息）。 因此，以下列方式选择最终绑定和SP URL： 如果定义了特定的Assertion Consumer Service POST Binding URL(断言消费者服务POST绑定URL)（在客户端设置的Fine Grain SAML Endpoint Configuration部分内），则通过该URL使用 POST绑定。 如果指定了通用的Master SAML Processing URL(主SAML处理URL)，则通过此常规URL再次使用POST绑定。 作为最后的手段，如果配置了Assertion Consumer Service Redirect Binding URL(断言消费者服务重定向绑定URL)（在Fine Grain SAML Endpoint Configuration(精细粒度SAML端点配置)中）REDIRECT绑定与此URL一起使用。 如果您的客户端需要特殊的中继状态，您也可以在IDP Initiated SSO Relay State(IDP启动的SSO中继状态)字段的Settings选项卡上进行配置。 或者，浏览器可以在RelayState查询参数中指定中继状态，即root/auth/realms/{realm}/protocol/saml/clients/{url-name}?RelayState=thestate。 使用identity brokering时，可以从外部IDP为客户端设置IDP启动登录。 如上所述，在代理IDP处为IDP启动登录设置实际客户端。 外部IDP必须为应用程序IDP启动登录设置客户端，该客户端将指向指向代理的特殊URL，并代表代理IDP上所选客户端的IDP启动登录端点。 这意味着在外部IDP的客户端设置中： IDP Initiated SSO URL Name设置为将作为IDP Initiated Login初始点发布的名称， Fine Grain SAML Endpoint Configuration部分中的Assertion Consumer Service POST Binding URL(断言消费者服务POST绑定URL)必须设置为以下URL：broker-root/auth/realms/{broker-realm}/broker/{idp-name}/endpoint/clients/{client-id}，其中： broker-root是基础代理URL broker-realm是声明外部IDP的代理域的域名 idp-name是经纪人的外部IDP的名称 client-id是代理处定义的SAML客户端的IDP Initiated SSO URL Name属性的值。 正是这个客户端，将从外部IDP用于IDP启动登录。 请注意，您可以将基本客户端设置从代理IDP导入外部IDP的客户端设置 - 只需使用SP描述符 可以从代理IDP中的身份提供者的设置中获得，并将clients/*client-id*添加到端点URL。 8.2.2. SAML实体描述符 您可以通过标准SAML实体描述符XML文件导入SAML 2.0客户端，而不是手动注册SAML 2.0客户端。 “添加客户端”页面上有一个Import选项。 添加客户端 单击Select File按钮并加载实体描述符文件。 您应该查看那里的所有信息，以确保所有设置都正确。 某些SAML客户端适配器（如mod-auth-mellon）需要IDP的XML实体描述符。 您可以通过转到此公共URL来获取此信息：root/auth/realms/{realm}/protocol/saml/descriptor 8.3. 客户端链接 对于想要从一个客户端链接到另一个客户端的场景，Keycloak提供了一个特殊的重定向端点：/realms/realm_name/clients/{client-id}/redirect。 如果客户端通过HTTP GET请求访问此端点，Keycloak将通过响应的Location头以HTTP 307（临时重定向）的形式返回所提供的Client和Realm的配置基本URL。 因此，客户端只需知道领域名称和客户端ID即可链接到它们。 此间接有助于避免硬编码客户端基本URL。 例如，给定领域master和client-id帐户`： http://host:port/auth/realms/master/clients/account/redirect 将临时重定向到：http://host:port/auth/realms/master/account 8.4. OIDC令牌和SAML断言映射 接收ID令牌，访问令牌或SAML断言的应用程序可能需要或想要不同的用户元数据和角色。 Keycloak允许您定义确切传输的内容。 您可以对角色，声明和自定义属性进行硬编码。 您可以将用户元数据拉入令牌或断言。 您可以重命名角色。 基本上你可以很好地控制究竟是什么回到客户端。 在管理控制台中，如果您转到已注册的应用程序，您将看到Mappers选项卡。 这是一个基于OIDC的客户端。 Mappers Tab 新客户端没有任何内置映射器，但它通常从客户端作用域继承一些映射器，如客户端作用域部分中所述。协议映射器将诸如电子邮件地址之类的内容映射到身份和访问令牌中的特定声明。 他们的功能应该从他们的名字中自我解释。 还有一些未附加到客户端的预配置映射器，您可以通过单击Add Builtin按钮添加这些映射器。 每个映射器都有常用设置以及其他设置，具体取决于您要添加的映射器类型。 单击列表中其中一个映射器旁边的Edit按钮进入配置屏幕。 Mapper Config 了解配置选项的最佳方法是将鼠标悬停在其工具提示上。 大多数OIDC映射器还允许您控制声明的放置位置。 您可以通过摆弄Add to ID token 和 Add to access token 开关来选择在id 和 access令牌中包含或排除声明。 最后，您还可以添加其他映射器类型。 如果您返回Mappers选项卡，请单击Create按钮。 Add Mapper 从列表框中选择Mapper Type。 如果将鼠标悬停在工具提示上，您将看到该映射器类型的描述。 将针对不同的映射器类型显示不同的配置参数。 8.4.1. 优先顺序 映射器实现具有priority order(优先级顺序)。 此优先级顺序不是映射器的配置属性; 相反，它是mapper具体实现的属性。 映射器在管理控制台中按照映射器列表中的顺序进行排序，并且将使用该顺序应用令牌或断言中的更改，并且首先应用最低值。 这意味着依赖于其他实现的实现按所需顺序处理。 例如，当我们首先想要计算将包含在令牌中的角色时，我们首先根据这些角色来解析受众。 然后，我们处理一个JavaScript脚本，该脚本使用令牌中已有的角色和受众。 8.4.2. OIDC用户会话记录映射器 用户会话详细信息是通过映射器，并取决于各种标准。 在客户端上使用或启用功能时，将自动包含用户会话详细信息。 您还可以单击Add builtin按钮以包含会话详细信息。 模拟的用户会话提供以下详细信息： IMPERSONATOR_ID: 模拟用户的ID IMPERSONATOR_USERNAME: 模拟用户的用户名 服务帐户会话提供以下详细信息： clientId: 服务帐户的客户端ID clientAddress: 服务帐户验证设备的远程主机IP clientHost: 服务帐户验证设备的远程主机名 8.5. 生成客户端适配器配置 Keycloak可以预先生成配置文件，您可以使用这些配置文件在应用程序的部署环境中安装客户端适配器。 OIDC和SAML都支持许多适配器类型。 转到要为其生成配置的客户端的Installation选项卡。 选择要为其生成配置的Format Option。 支持所有用于OIDC和SAML的Keycloak客户端适配器。 支持SAML的mod-auth-mellon Apache HTTPD适配器以及标准SAML实体描述符文件。 8.6. 客户端作用域 如果您需要在组织内保护和注册许多应用程序，为每个客户端配置协议映射器 和 角色范围映射 可能会变得很繁琐。 Keycloak允许您在名为client scope的实体中定义共享客户端配置。 客户端作用域还为OAuth 2的scope参数提供支持，该参数允许客户端应用程序根据应用程序需求在访问令牌中请求更多或更少的声明或角色。 要创建客户端作用域，请按照下列步骤操作： 转到Client Scopes左侧菜单项。 此初始屏幕显示当前定义的客户端作用域列表。 Client Scopes List 单击Create按钮。 命名客户端范围并保存。 A client scope(客户端作用域) 将具有与常规客户端类似的选项卡。 您可以定义协议映射器 和 角色范围映射，可以由其他客户端继承，并配置为从此客户端作用域继承。 8.6.1. 协议 在创建客户端作用域时，必须选择Protocol。 然后，只有使用相同协议的客户端才能与此客户端作用域链接。 创建新领域后，您可以看到菜单中有一个预定义（内置）客户端作用域列表。 对于SAML协议，有一个内置客户端作用域roles_list，其中包含一个协议映射器，用于显示SAML断言中的角色列表。 对于OpenID Connect协议，有客户端作用域profile，email，address，phone，offline_access，roles，web-originins和microprofile-jwt。 当客户端想要获取脱机令牌时，客户端作用域offline_access非常有用。 在离线访问部分 或 OpenID Connect规范 中了解离线令牌，其中scope参数定义为值offline_access。 客户端作用域 profile，email，address和phone也在OpenID Connect规范中定义。 这些客户端作用域没有定义任何角色作用域映射，但是它们定义了一些协议映射器，并且这些映射器对应于OpenID Connect规范中定义的声明。 例如，当您单击打开phone客户端范围并打开Mappers选项卡时，您将看到协议映射器，它对应于范围phone的规范中定义的声明。 Client Scope Mappers 当phone客户端作用域链接到客户端时，该客户端自动继承在phone客户端作用域中定义的所有协议映射器。 为该客户端发出的访问令牌将包含有关用户的电话号码信息，假设用户具有已定义的电话号码。 Builtin客户端作用域包含按照规范定义的协议映射器，但是您可以自由编辑客户端作用域并创建/更新/删除任何协议映射器（或角色作用域映射）。 客户端作用域roles未在OpenID Connect规范中定义，也不会自动添加到访问令牌中的scope声明中。 此客户端范围有一些映射器，用于将用户的角色添加到访问令牌，并可能为具有至少一个客户端角色的客户端添加一些受众，如受众节部分所述。 客户端范围web-originins也没有在OpenID Connect规范中定义，也没有添加到scope声明中。 这用于将允许的Web来源添加到访问令牌allowed-origins声明中。 创建客户端作用域microprofile-jwt以处理MicroProfile / JWT Auth Specification中定义的声明。 此客户端作用域为upn声明定义了一个用户属性映射器，并为groups声明定义了一个领域角色映射器。 可以根据需要更改这些映射器，以便可以使用不同的属性来创建MicroProfile/JWT特定声明。 8.6.2. 同意相关设置 客户端作用域包含与同意屏幕相关的选项。 仅当链接客户端配置为需要同意时（如果在客户端上启用了Consent Required(同意所需)开关），这些选项才有用。 在同意屏幕上显示 如果启用，并且如果将此客户端作用域添加到需要同意的客户端，则Consent Screen Text(同意屏幕文本)指定的文本将显示在同意屏幕上，一旦用户通过身份验证并且在重定向之前显示 给客户的Keycloak。 如果开关已关闭，则此同一客户端作用域将不会显示在同意屏幕上。 同意屏幕文字 当此客户端作用域被添加到需要同意的某个客户端时，同意屏幕上显示的文本默认为客户端范围的名称。 通过使用${var-name}字符串指定替换变量，可以对此文本的值进行本地化。 然后，在主题的属性文件中配置本地化值。 有关本地化的更多信息，请参阅服务器开发人员指南。 8.6.3. 将客户端作用域与客户端链接 客户端作用域和客户端之间的链接在特定客户端的Client Scopes选项卡中配置。 客户端作用域和客户端之间有两种链接方式。 Default Client Scopes 这适用于OpenID Connect和SAML客户端。 在为此客户端发出OpenID Connect令牌或SAML断言时，始终应用默认客户端作用域。 客户端将继承客户端作用域上定义的协议映射器和角色作用域映射。 对于OpenID Connect协议，无论在OpenID Connect授权请求中使用scope参数的值如何，始终应用Mappers和Role Scope Mappings。 Optional Client Scopes 这仅适用于OpenID Connect客户端。 在为此客户端发出令牌时应用可选的客户端作用域，但仅当它们由OpenID Connect授权请求中的scope参数请求时才应用。 例子 对于此示例，我们假设客户端将profile和email链接为默认客户端作用域，并且phone和address作为可选的客户端作用域链接。 在向OpenID Connect授权端点发送请求时，客户端将使用scope参数的值： scope=openid phone scope参数包含字符串，范围值除以空格（这也是客户端范围名称中不能包含空格字符的原因）。 值openid是用于所有OpenID Connect请求的元值，因此我们将在此示例中忽略它。 令牌将包含来自客户端作用域profile，email（默认作用域）和phone（作用域参数请求的可选客户端作用域）的映射器和角色作用域映射。 8.6.4. 评估客户端作用域 客户端的Mappers 和 Scope选项卡包含仅为此客户端声明的协议映射器和角色范围映射。 它们不包含从客户端作用域继承的映射器和作用域映射。 但是，查看有效协议映射器将是什么（在客户端本身定义的协议映射器以及从链接的客户端作用域继承）以及为特定客户端生成令牌时使用的有效角色作用域映射可能很有用。 当您单击客户端的Client Scopes选项卡，然后打开子选项卡Evaluate(评估)时，您可以看到所有这些。 从这里，您可以选择要应用的可选客户端范围。 这还将显示scope参数的值，该值需要从应用程序发送到Keycloak OpenID Connect授权端点。 Evaluating Client Scopes 如果您想了解如何从应用程序发送scope参数的自定义值，请参阅参数转发部分， 如果您的应用程序使用servlet适配器，或javascript适配器部分，如果您的应用程序使用javascript适配器。 生成示例令牌 要查看为特定用户生成并为特定客户端发出的具有指定值scope参数的实际访问令牌的示例，请从Evaluate屏幕中选择用户。 这将生成一个示例标记，其中包含所有使用的声明和角色映射。 8.6.5. 客户端作用域权限 为特定用户颁发令牌时，仅在允许用户使用客户端作用域时才应用客户端作用域。 如果客户端作用域没有自己定义的任何角色作用域映射，则会自动允许每个用户使用此客户端作用域。 但是，当客户端作用域具有自身定义的任何角色作用域映射时，用户必须至少是其中一个角色的成员。 换句话说，用户角色与客户端范围的角色之间必须存在交集。 评估此交集时会考虑复合角色。 如果不允许用户使用客户端作用域，则在生成令牌时将不使用协议映射器或角色作用域映射，并且客户端作用域不会出现在令牌中的scope值中。 8.6.6. 领域默认客户端作用域 Realm Default Client Scopes允许您定义一组客户端作用域，这些作用域将自动链接到新创建的客户端。 打开左侧菜单项Client Scopes，然后选择Default Client Scopes。 从此处，为新创建的客户端选择要添加为Default Client Scopes的客户端作用域，为新创建的客户端选择Optional Client Scopes。 Default Client Scopes 创建客户端后，您可以根据需要取消链接默认客户端作用域。 这与删除默认角色的方式类似。 8.6.7. 作用域解释 术语scope在Keycloak中用于少数几个地方。 各种作用域的出现彼此相关，但可能具有不同的上下文和含义。 为了澄清，这里我们解释Keycloak中使用的各种scopes。 Client scope 在本章中引用。 客户端作用域是Keycloak中的实体，它们在领域级别配置，并且可以链接到客户端。 当使用相应的scope参数值向Keycloak授权端点发送请求时，客户端作用域将通过其名称引用。 详细信息在关于客户端作用域链接的部分中进行了描述。 Role scope mapping 当您打开客户端或客户端范围的Scope选项卡时，可以看到这一点。 角色作用域映射允许您限制可以在访问令牌中使用的角色。 详细信息在Role Scope Mappings部分中描述。 Authorization scopes 这由授权功能使用。 Authorization Scope是可以在应用程序中完成的操作。 授权服务指南中的更多详细信息。 9. 角色 角色标识用户的类型或类别。 Admin，user，manager和employee都是组织中可能存在的典型角色。 应用程序通常为特定角色而不是单个用户分配访问权限和权限，因为与用户打交道可能过于细粒度且难以管理。 例如，管理控制台具有特定角色，这些角色授予用户访问管理控制台UI部分并执行某些操作的权限。 角色有一个全局命名空间，每个客户端也有自己的专用命名空间，可以定义角色。 9.1. 领域角色 领域级角色是定义角色的全局命名空间。 您可以通过单击Roles左侧菜单项来查看内置和创建的角色列表。 要创建角色，请单击此页面上的Add Role，输入角色的名称和描述，然后单击Save。 Add Role 通过使用${var-name}字符串指定替换变量，可以对description字段的值进行本地化。 然后，在主题的属性文件中配置本地化值。 有关本地化的更多信息，请参阅服务器开发人员指南。 9.2. 客户端 角色 客户端角色基本上是专用于客户端的命名空间。 每个客户端都有自己的命名空间 客户角色在每个客户端下的Roles选项卡下进行管理。 您与此UI的交互方式与您对领域级角色的交互方式相同。 9.3. 复合 角色 任何领域或客户级角色都可以转换为composite role(复合角色)。 一个 composite role是具有一个或多个与之关联的其他角色的角色。 将复合角色映射到用户时，用户还将获得与该复合关联的角色。 这种继承是递归的，因此任何复合合成也都会被继承。 要将常规角色转换为复合角色，请转到角色详细信息页面并打开Composite Role开关。 Composite Role 一旦您翻转此开关，角色选择UI将显示在页面的较低位置，您将能够将领域级别和客户端级别角色与您正在创建的组合关联。 在此示例中，employee领域级角色与developer复合角色相关联。 任何具有developer角色的用户现在也将继承employee角色。 创建令牌和SAML断言时，任何组合也将其相关角色添加到发送回客户端的身份验证响应的声明和断言中。 9.4. 用户角色映射 用户角色映射可以通过该单个用户的Role Mappings(角色映射)选项卡单独分配给每个用户。 Role Mappings 在上面的例子中，我们将分配在Composite Roles章节中创建的复合角色developer。 Effective Role Mappings 一旦分配了developer角色，您就会看到与developer合成相关联的employee角色出现在Effective Roles(有效角色)中。 Effective Roles是显式分配给用户的所有角色以及从复合体继承的任何角色。 9.4.1. 默认角色 默认角色允许您在通过Identity Brokering新创建或导入任何用户时自动分配用户角色映射。 要指定默认角色，请转到Roles左侧菜单项，然后单击Default Roles选项卡。 Default Roles 从屏幕截图中可以看出，默认情况下已经设置了许多default roles。 9.5. 角色范围映射 创建OIDC访问令牌或SAML断言时，默认情况下，用户的所有用户角色映射都会在令牌或断言中添加为声明。 应用程序使用此信息对该应用程序控制的资源进行访问决策。 在Keycloak中，访问令牌经过数字签名，实际上可以被应用程序重用，以调用其他远程安全的REST服务。 这意味着，如果某个应用程序受到攻击或者该域名中存在一个流氓客户端，则攻击者可以获得具有广泛权限的访问权限，并且您的整个网络都会受到攻击。 这就是role scope mappings(角色范围映射)变得重要的地方。 Role Scope Mappings是一种限制在访问令牌中声明的角色的方法。 当客户端请求对用户进行身份验证时，他们收到的访问令牌将仅包含您为客户端范围明确指定的角色映射。 这允许您限制每个单独的访问令牌具有的权限，而不是让客户端访问所有用户的权限。 默认情况下，每个客户端都会获取用户的所有角色映射。 您可以在每个客户端的Scope选项卡中查看此内容。 Full Scope 从图中可以看出，范围的有效角色是领域中每个声明的角色。 要更改此默认行为，您必须明确关闭Full Scope Allowed(允许的全范围)开关，并在每个单独的客户端中声明所需的特定角色。 或者，您也可以使用客户端作用域为整组客户端定义相同的角色作用域映射。 Partial Scope 10. 组 Keycloak中的组允许您为一组用户管理一组通用属性和角色映射。 用户可以是零个或多个组的成员。 用户继承分配给每个组的属性和角色映射。 要管理组，请转到Groups左侧菜单项。 Groups 组是分层的。 一个组可以有许多子组，但一个组只能有一个父组。 子组从父级继承属性和角色映射。 这也适用于用户。 因此，如果您有父组和子组以及仅属于子组的用户，则用户将继承父级和子级的属性和角色映射。 在这个例子中，我们有一个顶级的Sales组和一个子North America子组。 要添加组，请单击要添加新子项的父项，然后单击New按钮。 选择树中的Groups图标以创建顶级组。 在Create Group屏幕中输入组名并点击Save将进入单个组管理页面。 Group Attributes和Role Mappings选项卡的工作方式与用户下具有相似名称的选项卡完全相同。 您定义的任何属性和角色映射都将由作为该组成员的组和用户继承。 要将用户添加到组，您需要一直返回到用户详细信息页面，然后单击那里的Groups选项卡。 User Groups 从Available Groups树中选择一个组，然后单击join按钮将用户添加到组中。 反之亦然删除一个组。 在这里，我们将用户Jim添加到North America销售组。 如果您返回该组的详细信息页面并选择Membership选项卡，则Jim现在显示在那里。 Group Membership 10.1. 群组与角色 在IT世界中，组和角色的概念通常是模糊和可互换的。 在Keycloak中，组只是一组用户，您可以在一个位置应用角色和属性。 角色定义一种用户，应用程序为角色分配权限和访问控制 是不是复合角色也与群组相似？ 从逻辑上讲，它们提供了相同的功能，但区别在于概念。 应使用组合角色将权限模型应用于您的服务和应用程序集。 组应关注用户集合及其在组织中的角色。 使用组来管理用户。 使用复合角色来管理应用程序和服务。 10.2. 默认组 默认组允许您在通过Identity Brokering创建或导入任何新用户时自动分配组成员资格。 要指定默认组，请转到Groups左侧菜单项，然后单击Default Groups选项卡。 Default Groups 11. 管理控制台访问控制和权限 Keycloak上创建的每个领域都有一个专用的管理控制台，可以从中管理该领域。 master领域是一个特殊的领域，允许管理员管理系统上的多个领域。 您还可以定义对不同领域中的用户的细粒度访问以管理服务器。 本章将讨论所有场景。 11.1. Master Realm访问控制 Keycloak中的master领域是一个特殊的领域，与其他领域的处理方式不同。 可以授予Keycloakmaster域中的用户管理部署在Keycloak服务器上的零个或多个域的权限。 创建领域时，Keycloak会自动创建各种角色，授予细粒度权限以访问新领域。 可以通过将这些角色映射到master领域中的用户来控制对Admin Console和Admin REST端点的访问。 可以创建多个超级用户，以及只能管理特定领域的用户。 11.1.1. Global Roles 在master领域有两个领域级别的角色。 这些是： admin create-realm 具有admin角色的用户是超级用户，并且拥有管理服务器上任何领域的完全访问权限。 具有create-realm角色的用户可以创建新领域。 他们将被授予对他们创建的任何新领域的完全访问权限。 11.1.2. 领域特定角色 master领域内的管理员用户可以被授予系统中一个或多个其他领域的管理权限。 Keycloak中的每个领域都由master领域的客户端代表。 客户端的名称是-realm。 这些客户端每个都定义了客户端级角色，这些角色定义了管理单个领域的不同访问级别。 可用的角色是： view-realm view-users view-clients view-events manage-realm manage-users create-client manage-clients manage-events view-identity-providers manage-identity-providers impersonation 将您想要的角色分配给您的用户，他们只能使用管理控制台的特定部分。 具有manage-users角色的管理员只能为自己拥有的用户分配管理员角色。 因此，如果管理员具有manage-users角色但没有manage-realm角色，则他们将无法分配此角色。 11.2. 专用领域管理控制台 每个领域都有一个专用的管理控制台，可以通过访问url/auth/admin/{realm-name}/console来访问。 通过分配特定的用户角色映射，可以为该领域中的用户授予领域管理权限。 每个领域都有一个名为realm-management的内置客户端。 您可以通过转到领域的Clients左侧菜单项来查看此客户端。 此客户端定义客户端级角色，这些角色指定可以授予管理域的权限。 view-realm view-users view-clients view-events manage-realm manage-users create-client manage-clients manage-events view-identity-providers manage-identity-providers impersonation 将您想要的角色分配给您的用户，他们只能使用管理控制台的特定部分。 11.3. 细粒度管理员权限 Fine Grain管理员权限是技术预览，并不完全支持。 默认情况下禁用此功能。要启用-Dkeycloak.profile=preview或-Dkeycloak.profile.feature.admin_fine_grained_authz=enabled启动服务器。 有关详细信息，请参阅配置文件。 有时像manage-realm或manage-users这样的角色太粗糙，你想要创建具有更多细粒度权限的受限管理员帐户。 Keycloak允许您定义和分配用于管理领域的受限访问策略。 像： 管理一个特定的客户 管理属于特定组的用户 管理组的成员身份 有限的用户管理 细粒模仿控制 能够为用户分配特定的受限制角色集 能够将特定的受限制角色集分配给复合角色 能够将特定的受限制角色集分配给客户的范围 用于查看和管理用户，组，角色和客户端的新常规策略 有关细粒度管理员权限的一些重要事项需要注意： 细粒度管理员权限在授权服务之上实现。 强烈建议您在深入了解细粒度权限之前先阅读这些功能。 细粒度权限仅在专用管理控制台和在这些领域内定义的管理员中可用。 您无法定义跨领域细粒度权限。 细粒度权限用于授予其他权限。 您无法覆盖内置管理角色的默认行为。 11.3.1. 管理一个特定的客户 让我们首先看一下管理员只管理一个客户端和一个客户端。 在我们的例子中，我们有一个名为test的领域和一个名为sales-application的客户端。 在领域test中，我们将为该领域的用户授予仅管理该应用程序的权限。 你不能做cross realm细粒度权限。 master领域的管理员仅限于前面章节中定义的预定义管理员角色。 权限设置 我们必须做的第一件事是登录管理控制台，以便我们可以为该客户端设置权限。 我们导航到我们要为其定义细粒度权限的客户端的管理部分。 Client Management 您应该看到一个名为Permissions的标签菜单项。 单击该选项卡。 Client Permissions Tab 默认情况下，不启用每个客户端来执行细粒度权限。 因此，将Permissions Enabled开关设置为on以初始化权限。 如果您将Permissions Enabled开关设置为off，它将删除您为此客户端定义的所有权限。 Client Permissions Tab 当您启用Permissions Enabled时，它会使用授权服务在幕后初始化各种权限对象。 对于此示例，我们对客户端的manage权限感兴趣。 单击它会将您重定向到处理客户端manage权限的权限。 所有授权对象都包含在realm-management客户端的Authorization选项卡中。 Client Manage Permission 首次初始化时，manage权限没有任何与之关联的策略。 您需要转到策略选项卡创建一个。 要快速到达，请单击上图中显示的Authorization(授权)链接。 然后单击“策略”选项卡。 这个页面上有一个名为Create policy的下拉菜单。 您可以定义多种策略。 您可以定义与角色或组关联的策略，甚至可以在JavaScript中定义规则。 对于这个简单的例子，我们将创建一个User Policy。 User Policy 此策略将匹配用户数据库中的硬编码用户。 在这种情况下，它是sales-admin用户。 然后我们必须回到sales-application客户端的manage权限页面并将策略分配给权限对象。 Assign User Policy sales-admin用户现在可以拥有管理sales-application客户端的权限。 我们还有一件事要做。 转到Role Mappings选项卡并将query-clients角色分配给sales-admin。 Assign query-clients 你为什么要这样做？ 此角色告诉管理控制台当sales-admin访问管理控制台时要呈现的菜单项。 query-clients角色告诉管理控制台它应该为sales-adminuser呈现客户菜单。 重要: 如果您没有设置query-clients角色，那么受限制的管理员（例如sales-admin）在登录管理控制台时将看不到任何菜单选项 测试它 接下来，我们退出主域并重新登录到专用管理控制台，用于test域使用 sales-admin作为用户名。 它位于/auth/admin/test/console下。 Sales Admin Login 此管理员现在可以管理这个客户端。 11.3.2. 限制用户角色映射 您可能想要做的另一件事是限制集合允许管理员分配给用户的角色。 继续我们的最后一个示例，让我们扩展sales-admin用户的权限集，以便他还可以控制允许哪些用户访问此应用程序。 通过细粒度权限，我们可以启用它，以便sales-admin只能分配授予对sales-application的特定访问权限的角色。 我们还可以对其进行限制，以便管理员只能映射角色而不执行任何其他类型的用户管理。 sales-application定义了三种不同的客户角色。 销售应用程序角色 我们希望sales-admin用户能够将这些角色映射到系统中的任何用户。 执行此操作的第一步是允许管理员映射角色。 如果我们单击viewLeads角色，您将看到此角色有一个Permissions选项卡。 查看潜在客户角色权限选项卡 如果我们单击该选项卡并打开Permissions Enabled，您将看到我们可以应用策略执行多项操作。 查看潜在客户权限 我们感兴趣的是map-role。 单击此权限并添加在先前示例中创建的相同用户策略。 映射角色权限 我们所做的就是说sales-admin可以映射viewLeads角色。 我们尚未做的是指定管理员也可以映射此角色的用户。 为此，我们必须转到此领域的管理控制台的Users部分。 单击Users左侧菜单项将我们带到领域的用户界面。 你应该看到一个Permissions选项卡。 单击它并启用它。 用户权限 我们感兴趣的权限是map-roles。 这是一项限制性策略，因为它只允许管理员将角色映射到用户。 如果我们点击map-roles权限并再次添加我们为此创建的用户策略，我们的sales-admin将能够将角色映射到任何用户。 我们要做的最后一件事是将view-users角色添加到sales-admin。 这将允许管理员查看他想要添加sales-application角色的领域中的用户。 添加视图用户 测试它. 接下来，我们退出主域并重新登录到专用管理控制台，用于test域使用 sales-admin作为用户名。 它位于/auth/admin/test/console下。 您将看到sales-admin现在可以查看系统中的用户。 如果您选择其中一个用户，您将看到每个用户详细信息页面都是只读的，Role Mappings选项卡除外。 转到这些选项卡，您会发现管理员没有Available角色映射到用户，除非我们浏览sales-application角色。 Add viewLeads 我们只指定sales-admin可以映射viewLeads角色。 每个客户端 映射-角色 快捷方式 如果我们必须为sales-application发布的每个客户角色执行此操作，那将是单调乏味的。 为了简化操作，有一种方法可以指定管理员可以映射客户端定义的任何角色。 如果我们重新登录管理控制台到我们的主域管理员并返回到sales-application权限页面，您将看到map-roles权限。 客户端 映射-角色 权限 如果您授予管理员对此特定权限的访问权限，则该管理员将能够映射客户端定义的任何角色。 11.3.3. 完整的权限列表 除了管理特定客户端或客户端的特定角色之外，您还可以使用细粒度权限执行更多操作。 本章定义了可以为领域描述的权限类型的完整列表。 Role 当转到特定角色的Permissions选项卡时，您将看到列出的这些权限类型。 map-role 决定管理员是否可以将此角色映射到用户的策略。 这些策略仅指定角色可以映射到用户，而不是允许管理员执行用户角色映射任务。 管理员还必须具有管理或角色映射权限。 有关详细信息，请参阅用户权限。 map-role-composite 决定管理员是否可以将此角色作为复合映射到另一个角色的策略。 管理员可以为客户定义角色，如果他具有该客户的管理权限，但他将无法向这些角色添加复合，除非他对要添加为复合的角色具有map-role-composite权限。 map-role-client-scope 决定管理员是否可以将此角色应用于客户端范围的策略。 即使管理员可以管理客户端，他也无权为包含此角色的客户端创建令牌，除非授予此权限。 客户端 当转到特定客户端的Permissions选项卡时，您将看到列出的这些权限类型。 view 决定管理员是否可以查看客户端配置的策略。 manage 决定管理员是否可以查看和管理客户端配置的策略。 这有一些问题，特权可能会无意中泄露。 例如，管理员可以定义一个协议映射器，即使管理员没有将角色映射到客户端范围的权限，也会对该角色进行硬编码。 这是目前协议映射器的限制，因为它们没有办法像角色那样为它们分配单独的权限。 configure 减少了一组管理客户端的权利。 它类似于manage范围，但管理员不允许定义协议映射器，更改客户端模板或客户端范围。 map-roles 决定管理员是否可以将客户端定义的任何角色映射到用户的策略。 这是一种易于使用的快捷方式，可避免为客户定义的每个角色定义策略。 map-roles-composite 决定管理员是否可以将客户端定义的任何角色作为复合映射到另一个角色的策略。 这是一种易于使用的快捷方式，可避免为客户端定义的每个角色定义策略。 map-roles-client-scope 决定管理员是否可以将客户端定义的任何角色映射到另一个客户端范围的策略。 这是一种易于使用的快捷方式，可避免为客户端定义的每个角色定义策略。 用户 当进入所有用户的Permissions选项卡时，您将看到列出的这些权限类型。 view 决定管理员是否可以查看领域中所有用户的策略。 manage 决定管理员是否可以管理领域中所有用户的策略。 此权限授予管理员执行用户角色映射的权限，但不指定管理员允许映射的角色。 您需要为管理员能够映射的每个角色定义权限。 map-roles 这是manage范围授予的权限的子集。 在这种情况下，只允许管理员映射角色。 不允许管理员执行任何其他用户管理操作。 此外，与manage一样，如果处理客户端角色，则必须为每个角色或每组角色指定允许管理员应用的角色。 manage-group-membership 类似于map-roles，除了它与组成员资格相关：可以添加或删除用户的组。 这些策略仅授予管理员管理组成员资格的权限，而不授予管理员管理其成员资格的组。 您必须为每个组的manage-members权限指定策略。 impersonate 决定是否允许管理员模仿其他用户的策略。 这些策略应用于管理员的属性和角色映射。 user-impersonated 决定可以模拟哪些用户的策略。 这些策略将应用于被模拟的用户。 例如，您可能希望定义一个策略，禁止任何人冒充具有管理员权限的用户。 组 当转到特定组的Permissions选项卡时，您将看到列出的这些权限类型。 view 决定管理员是否可以查看有关该组的信息的策略。 manage 决定管理员是否可以管理组配置的策略。 view-members 决定管理员是否可以查看该组成员的用户详细信息的策略。 manage-members 决定管理员是否可以管理属于该组的用户的策略。 manage-membership 决定管理员是否可以更改组成员身份的策略。 在组中添加或删除成员。 11.4. 领域密钥 Keycloak使用的身份验证协议需要加密签名，有时还需要加密。 Keycloak使用非对称密钥对，私钥和公钥来实现这一目标。 Keycloak一次只有一个活动密钥对，但也可以有几个被动密钥。 活动密钥对用于创建新签名，而被动密钥对可用于验证以前的签名。 这使得可以定期旋转键而无需停机或中断用户。 创建领域时，会自动生成密钥对和自签名证书。 要查看领域的活动密钥，请在管理控制台中选择领域，单击Realm settings，然后单击Keys。 这将显示领域的当前活动密钥。 Keycloak目前仅支持RSA签名，因此只有一个活动密钥对。 将来随着更多签名算法的增加，将会有更多活跃的密钥对。 要查看所有可用键，请选择All。 这将显示所有活动，被动和禁用键。 密钥对可以具有Active状态，但仍未被选为该领域的当前活动密钥对。 基于按能够提供活动密钥对的优先级排序的第一密钥提供者来选择用于签名的所选活动对。 11.4.1. 轮流密钥 建议定期轮流密钥。 为此，您应该首先创建优先级高于现有活动密钥的新密钥。 或者创建具有相同优先级的新密钥并使之前的密钥处于被动状态。 一旦有新密钥可用，所有新令牌和cookie都将使用新密钥进行签名。 当用户对应用程序进行身份验证时，将使用新签名更新SSO cookie。 刷新OpenID Connect令牌时，将使用新密钥对新令牌进行签名。 这意味着随着时间的推移，所有cookie和令牌都将使用新密钥，过一会儿就可以删除旧密钥。 您等待删除旧密钥的时间是安全性之间的权衡，并确保更新所有cookie和令牌。 一般来说，几周后丢弃旧密钥应该是可以接受的。 在添加的新密钥和删除的旧密钥之间的时间段内未处于活动状态的用户必须重新进行身份验证。 这也适用于离线令牌。 为确保更新它们，应用程序需要在删除旧密钥之前刷新令牌。 作为指导，每3-6个月创建一个新密钥并在创建新密钥后1-2个月删除旧密钥可能是个好主意。 11.4.2. 添加生成的密钥对 要添加新生成的密钥对，请选择Providers并从下拉列表中选择rsa-generated。 您可以更改优先级以确保新密钥对成为活动密钥对。 如果需要更小或更大的键，也可以更改keysize（默认值为2048，支持的值为1024,2048和4096）。 单击Save以添加新密钥。 这将生成一个新的密钥对，包括自签名证书。 更改提供程序的优先级不会导致重新生成密钥，但如果要更改密钥大小，则可以编辑提供程序并生成新密钥。 11.4.3. 添加现有密钥对和证书 要添加在其他地方获得的密钥对和证书，请选择Providers并从下拉列表中选择rsa。 您可以更改优先级以确保新密钥对成为活动密钥对。 单击Select RSA Key的Select file以上传您的私钥。 该文件应以PEM格式编码。 您无需上传公钥，因为它是从私钥中自动提取的。 如果您有密钥的签名证书，请单击X509证书旁边的Select file。 如果您没有，则可以跳过此项，并生成自签名证书。 11.4.4. 从Java密钥库加载密钥 要在主机上添加存储在Java Keystore文件中的密钥对和证书，请选择Providers并从下拉列表中选择java-keystore。 您可以更改优先级以确保新密钥对成为活动密钥对。 填写Keystore，Keystore Password，Key Alias和Key Password的值，然后单击Save。 11.4.5. 使密钥消极 在Active或All中找到密钥对，然后单击Provider列中的提供程序。 这将带您进入密钥的密钥提供程序的配置屏幕。 点击Active将其变为OFF，然后点击Save。 密钥将不再处于活动状态，只能用于验证签名。 11.4.6. 禁用密钥 在Active或All中找到密钥对，然后单击Provider列中的提供程序。 这将带您进入密钥的密钥提供程序的配置屏幕。 单击Enabled将其设置为OFF，然后单击Save。 将不再启用密钥。 或者，您可以从Providers表中删除提供程序。 11.4.7. 泄露的密钥 Keycloak只在本地存储签名密钥，它们永远不会与客户端应用程序，用户或其他实体共享。 但是，如果您认为您的域签名密钥已被破坏，则应首先生成如上所述的新密钥对，然后立即删除受损密钥对。 然后，为了确保客户端应用程序不接受受攻击密钥签名的令牌，您应该更新并推送域的非先行策略，这可以从管理控制台执行。 推出新策略将确保客户端应用程序不会接受由受感染密钥签名的现有令牌，但客户端应用程序将被强制从Keycloak下载新密钥对，因此受攻击密钥签名的令牌将无效了。 请注意，您的REST和机密客户端必须设置Admin URL,以便Keycloak能够向他们发送有关推送的不在之前策略的请求。 12. 身份代理 Identity Broker是一种中间服务，它将多个服务提供者与不同的身份提供者连接起来。 作为中间服务，身份代理负责与外部身份提供者建立信任关系，以便使用其身份访问服务提供者公开的内部服务。 从用户的角度来看，身份代理提供了一种以用户为中心的集中方式来管理不同安全域或领域的身份。 现有帐户可以与来自不同身份提供者的一个或多个身份链接，或甚至基于从他们获得的身份信息创建。 身份提供者通常基于特定协议，该协议用于向其用户验证和传递身份验证和授权信息。 它可以是Facebook，Google或Twitter等社交提供商。 它可以是用户需要访问您的服务的业务合作伙伴。 或者它可以是您要与之集成的基于云的身份服务。 通常，身份提供者基于以下协议： SAML v2.0 OpenID Connect v1.0 OAuth v2.0 在下一节中，我们将了解如何配置和使用Keycloak作为身份代理，涵盖一些重要方面，例如： Social Authentication OpenID Connect v1.0 Brokering SAML v2.0 Brokering Identity Federation 12.1. 经纪概述 使用Keycloak作为身份代理时，不会强制用户提供其凭据以在特定领域中进行身份验证。 相反，它们会显示一个身份提供者列表，他们可以从中进行身份验证。 您还可以配置默认身份提供程序。 在这种情况下，将不会为用户提供选择，而是将其直接重定向到默认提供程序。 下图演示了使用Keycloak代理外部身份提供程序时涉及的步骤： 身份代理流程 用户未经过身份验证，并在客户端应用程序中请求受保护的资源。 客户端应用程序将用户重定向到Keycloak进行身份验证。 此时，向用户呈现登录页面，其中存在在领域中配置的身份提供者列表。 用户通过单击其相应的按钮或链接来选择一个身份提供者。 Keycloak向目标身份提供者发出身份验证请求，要求进行身份验证，并将用户重定向到身份提供者的登录页面。 身份提供程序的连接属性和其他配置选项先前由管理员在管理控制台中设置。 用户提供其凭据或同意，以便与身份提供商进行身份验证。 在身份提供商成功进行身份验证后，用户将通过身份验证响应重定向回Keycloak。 通常，此响应包含一个安全令牌，Keycloak将使用该令牌来信任身份提供程序执行的身份验证并检索有关该用户的信息。 现在，Keycloak将检查身份提供者的响应是否有效。 如果有效，它将导入并创建新用户，或者如果用户已存在则跳过该用户。 如果是新用户，Keycloak可能会向身份提供者询问有关用户的信息，如果该信息中尚不存在该信息。 这就是我们所说的identity federation。 如果用户已存在，Keycloak可能会要求他将身份提供商返回的身份与现有帐户相关联。 我们将此流程称为account linking。 具体做法是可配置的，可以通过首次登录流程的设置来指定。 在此步骤结束时，Keycloak对用户进行身份验证并发出自己的令牌，以便访问服务提供者中请求的资源。 一旦用户进行了本地身份验证，Keycloak就会通过发送先前在本地身份验证期间发出的令牌将用户重定向到服务提供者。 服务提供商从Keycloak接收令牌并允许访问受保护资源。 我们将在稍后讨论这种流程的一些变化。 例如，客户端应用程序可以请求特定的身份提供者，而不是呈现身份提供者列表。 或者，您可以告诉Keycloak强制用户在联合其身份之前提供其他信息。 不同协议可能需要不同的认证流程。 此时，Keycloak支持的所有身份提供者都使用如上所述的流程。 但是，无论使用何种协议，用户体验应该基本相同。 您可能会注意到，在身份验证过程结束时，Keycloak将始终向客户端应用程序发出自己的令牌。 这意味着客户端应用程序与外部身份提供程序完全分离。 他们不需要知道使用了哪种协议（例如：SAML，OpenID Connect，OAuth等）或如何验证用户的身份。 他们只需要了解Keycloak。 12.2. 默认身份提供者 可以自动重定向到身份提供者，而不是显示登录表单。 要启用此功能，请转到管理控制台中的Authentication页面，然后选择Browser流程。 然后单击Identity Provider Redirector身份验证器。 将Default Identity Provider设置为您要自动将用户重定向到的身份提供程序的别名。 如果未找到配置的默认身份提供程序，则将显示登录表单。 此验证器还负责处理kc_idp_hint查询参数。 有关详细信息，请参阅客户建议的身份提供商 部分。 12.3. 一般配置 身份代理配置全部基于身份提供者。 为每个领域创建身份提供程序，默认情况下，它们为每个应用程序启用。 这意味着来自领域的用户在登录应用程序时可以使用任何已注册的身份提供者。 要创建身份提供程序，请单击Identity Providers左侧菜单项。 身份提供者 在下拉列表框中，选择要添加的身份提供程序。 这将带您进入该身份提供程序类型的配置页面。 添加身份提供者 以上是配置Google社交登录提供程序的示例。 配置IDP后，它将作为选项显示在Keycloak登录页面上。 IDP登录页面 社交 社交提供程序允许您在您的领域中启用社交身份验证。 Keycloak使用户可以轻松地使用具有社交网络的现有帐户登录您的应用程序。 目前支持的提供商包括：Twitter，Facebook，谷歌，LinkedIn，Instagram，微软，PayPal，Openshift v3，GitHub，GitLab，Bitbucket和Stack Overflow。 Protocol-based 基于协议的提供程序是依赖于特定协议以对用户进行身份验证和授权的提供程序。 它们允许您连接到符合特定协议的任何身份提供者。 Keycloak支持SAML v2.0和OpenID Connect v1.0协议。 它可以根据这些开放标准轻松配置和代理任何身份提供商。 虽然每种类型的身份提供者都有自己的配置选项，但它们都共享一些非常常见的配置。 无论您创建哪个身份提供程序，您都会看到以下配置选项： 配置 描述 Alias 别名是身份提供者的唯一标识符。 它用于在内部引用身份提供者。 某些协议（如OpenID Connect）需要重定向URI或回调URL才能与身份提供者进行通信。 在这种情况下，别名用于构建重定向URI。 每个身份提供者都必须拥有别名。 例如facebook，google，idp.acme.com等。 Enabled 打开/关闭提供商。 Hide on Login Page 当此开关打开时，此提供程序将不会在登录页面上显示为登录选项。 客户端仍然可以通过在用于请求登录的URL中使用kc_idp_hint参数来请求使用此提供程序。 Account Linking Only 当此开关打开时，此提供程序不能用于登录用户，也不会在登录页面上显示为选项。 但是，现有帐户仍可与此提供商链接。 Store Tokens 是否存储从身份提供者收到的令牌。 Stored Tokens Readable 是否允许用户检索存储的身份提供者令牌。 这也适用于broker客户端级角色read token(读取令牌)。 Trust Email 如果身份提供商提供电子邮件地址，则此电子邮件地址将受信任。 如果领域需要电子邮件验证，则从此IDP登录的用户将不必通过电子邮件验证过程。 GUI Order 用于对登录页面上列出的可用IDP进行排序的订单号。 First Login Flow 这是第一次通过此IDP登录Keycloak的用户将触发的身份验证流程。 Post Login Flow 用户完成使用外部身份提供程序登录后触发的身份验证流。 12.4. 社交身份提供者 对于面向Internet的应用程序，用户必须在您的站点注册才能获得访问权限，这非常麻烦。 它要求他们记住另一个用户名和密码组合。 社交身份提供程序允许您将身份验证委派给用户可能已拥有帐户的半受信任和受尊重的实体。 Keycloak为最常见的社交网络提供内置支持，例如Google，Facebook，Twitter，GitHub，LinkedIn，Microsoft和Stack Overflow。 12.4.1. Bitbucket 您必须完成许多步骤才能启用Bitbucket登录。 首先，打开Identity Providers左侧菜单项，然后从Add provider下拉列表中选择Bitbucket。 这将带您进入Add identity provider页面。 添加身份提供者 在您单击Save之前，您必须从Bitbucket获取Client ID和Client Secret。 您将在稍后的步骤中使用此页面中的Redirect URI，当您在其中注册Keycloak作为客户端时，您将提供给Bitbucket。 添加新应用 要使用Bitbucket启用登录，您必须首先在关于Bitbucket Cloud的OAuth中注册一个应用程序项目。 Bitbucket经常改变应用程序注册的外观和感觉，所以你在Bitbucket网站上看到的可能会有所不同。 如有疑问，请参阅Bitbucket文档。 单击Add consumer按钮。 注册应用程序 从KeycloakAddd Identity Provider页面复制Redirect URI并将其输入Bitbucket Add OAuth Consumer页面上的Callback URL字段。 在同一页面上，在Account下标记Email和Read框，以允许您的应用程序读取用户电子邮件。 Bitbucket应用页面 完成注册后，单击Save。 这将打开Bitbucket中的应用程序管理页面。 从此页面中查找客户端ID和密码，以便您可以将其输入KeycloakAdd identity provider页面。 点击Save。 12.4.2. Facebook 您必须完成许多步骤才能启用Facebook登录。 首先，转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择Facebook。 这将带您进入Add identity provider页面。 添加身份提供者 您无法单击保存，因为您需要从Facebook获取Client ID和Client Secret。 您需要从此页面获得的一条数据是Redirect URI。 当您在其中注册Keycloak作为客户端时，您必须向Facebook提供该功能，因此请将此URI复制到剪贴板。 要启用Facebook登录，首先必须在Facebook Developer Console中创建项目和客户端。 Facebook经常改变Facebook Developer Console的外观和风格，因此这些指示可能并不总是最新的，配置步骤可能略有不同。 登录控制台后，屏幕右上角会出现一个下拉菜单，上面写着My Apps。 选择Add a New App菜单项。 添加新应用 选择Website图标。 单击Skip and Create App ID按钮。 创建一个新的应用程序ID 电子邮件地址和应用类别是必填字段。 完成后，您将被带到应用程序的仪表板。 单击Settings左侧菜单项。 创建一个新的应用程序ID 单击本页末尾的+ Add Platform按钮，然后选择Website图标。 将Redirect URI从KeycloakAdd identity provider页面复制并粘贴到FacebookWebsite设置块的Site URL中。 指定网站 在此之后，有必要公开Facebook应用程序。 单击App Review左侧菜单项，然后将按钮切换为Yes。 您还需要从此页面获取App ID和App Secret，以便将其输入KeycloakAdd identity provider页面。 要获得此单击Dashboard左侧菜单项并单击App Secret下的Show。 返回Keycloak并指定这些项目，最后保存您的Facebook身份提供商。 在Facebook的Add identity provider页面上注释的一个配置选项是Default Scopes字段。 此字段允许您手动指定用户在使用此提供程序进行身份验证时必须授权的范围。 有关范围的完整列表，请查看。 默认情况下，Keycloak使用以下范围：email。 12.4.3. GitHub 您必须完成许多步骤才能启用GitHub登录。 首先，转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择GitHub。 这将带您进入Add identity provider页面。 添加身份提供者 您无法单击Save，因为您需要从GitHub获取Client ID和Client Secret。 您需要从此页面获得的一条数据是Redirect URI。 当您在其中注册Keycloak作为客户端时，您必须将其提供给GitHub，因此请将此URI复制到剪贴板。 要使用GitHub启用登录，首先必须在GitHub Developer applications中注册一个应用程序项目。 GitHub经常更改应用程序注册的外观，因此这些指示可能并不总是最新的，配置步骤可能略有不同。 添加新应用 单击Register a new application按钮。 注册应用程序 您必须从KeycloakAddd Identity Provider页面复制Redirect URI并将其输入到GitHub上的Authorization callback URL 字段 Register a new OAuth application页面。 完成此页面后，您将进入应用程序的管理页面。 GitHub应用页面 您需要从此页面获取客户端ID和密码，以便将其输入KeycloakAdd identity provider页面。 返回Keycloak并指定这些项目。 12.4.4. GitLab 为了能够使用GitLab启用登录，您必须完成许多步骤。 首先，转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择GitLab。 这将带您进入Add identity provider页面。 添加身份提供者 在单击Save之前，您必须从GitLab获取Client ID和Client Secret。 您将在稍后的步骤中使用此页面中的 Redirect URI，当您在其中注册Keycloak作为客户端时，您将提供给GitLab。 要使用GitLab启用登录，首先必须在GitLab as OAuth2身份验证服务提供商中注册应用程序。 GitLab经常更改应用程序注册的外观，因此您在GitLab站点上看到的内容可能会有所不同。 如有疑问，请参阅GitLab文档。 添加新应用 从Keycloak Add Identity Provider页面复制Redirect URI，并将其输入到GitLab添加新应用程序页面的重定向URI字段中。 GitLab应用页面 完成注册后，单击Save application。 这将打开GitLab中的应用程序管理页面。 从此页面中查找客户端ID和密码，以便您可以将其输入Keycloak Add identity provider页面。 完成后，返回Keycloak并输入它们。 点击Save。 12.4.5. Google 您必须完成许多步骤才能启用Google登录。 首先，转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择Google。 这将带您进入 Add identity provider 页面。 添加身份提供者 您无法单击Save，因为您需要从Google获取Client ID 和 Client Secret。 您需要从此页面获得的一条数据是Redirect URI。 当您在其中注册Keycloak作为客户端时，您必须向Google提供该功能，因此请将此URI复制到剪贴板。 要启用Google登录，您首先必须在Google Developer Console中创建项目和客户。 然后，您需要将客户端ID和密钥复制到Keycloak管理控制台。 Google经常更改Google Developer Console的外观，因此这些说明可能并不总是最新的，配置步骤可能略有不同。 我们先来看看如何使用Google创建项目。 登录到Google Developer Console。 Google Developer Console 单击Create Project按钮。 使用所需的Project name和Project ID的任何值，然后单击Create按钮。 等待创建项目（这可能需要一段时间）。 创建后，您将被带到项目的仪表板。 仪表板 然后导航到Google Developer Console中的APIs & Services部分。 在该屏幕上，导航到Credentials管理。 当用户从Keycloak登录Google时，他们会看到Google的同意屏幕，该屏幕将询问用户是否允许Keycloak查看有关其用户个人资料的信息。 因此，在为其创建任何秘密之前，Google需要一些有关该产品的基本信息。 对于新项目，您首先要配置OAuth consent screen。 对于非常基本的设置，填写应用程序名称就足够了。 您还可以在此页面中设置其他详细信息，例如Google API的范围。 填写OAuth同意屏幕详细信息 下一步是创建OAuth客户端ID和客户端密钥。 回到Credentials管理，导航到Credentialstab并在Create credentials按钮下选择OAuth client ID。 创建凭据 然后，您将进入Create OAuth client ID页面。 选择Web application作为应用程序类型。 指定客户端所需的名称。 您还需要将Redirect URI从Keycloak Add Identity Provider页面复制并粘贴到 Authorized redirect URIs字段中。 完成后，单击Create按钮。 创建OAuth客户端ID 单击Create后，您将进入Credentials页面。 点击新的OAuth 2.0客户端ID可查看新Google客户端的设置。 Google客户端凭据 您需要从此页面获取客户端ID和密码，以便将其输入Keycloak Add identity provider页面。 返回Keycloak并指定这些项目。 在Google的Add identity provider页面上注明的一个配置选项是Default Scopes字段。 此字段允许您手动指定用户在使用此提供程序进行身份验证时必须授权的范围。 有关范围的完整列表，请查看。 默认情况下，Keycloak使用以下范围：openid profile email。 如果您的组织使用G Suite并且您希望仅限制对组织成员的访问，则必须将用于G Suite的域输入Hosted Domain字段以启用它。 12.4.6. LinkedIn 您必须完成许多步骤才能启用LinkedIn登录。 首先，转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择LinkedIn。 这将带您进入Add identity provider页面。 添加身份提供者 您无法单击Save，因为您需要从LinkedIn获取Client ID和Client Secret。 您需要从此页面获得的一条数据是Redirect URI。 当您在其中注册Keycloak作为客户端时，您必须向LinkedIn提供该功能，因此请将此URI复制到剪贴板。 要启用LinkedIn登录，首先必须在LinkedIn开发人员网络中创建应用程序。 LinkedIn可能会更改应用程序注册的外观，因此这些说明可能并不总是最新的。 开发者网络 单击Create Application按钮。 这将带您进入Create a New Application页面。 创建应用程序 使用适当的值填写表单，然后单击Submit按钮。 这将带您进入新应用程序的设置页面。 应用设置 在Default Application Permissions部分中选择r_basicprofile和r_emailaddress。 您必须从Keycloak Add Identity Provider页面复制Redirect URI并将其输入到LinkedIn应用程序设置页面上的OAuth 2.0 Authorized Redirect URLs字段中。 执行此操作后，请不要忘记单击Update按钮！ 然后，您需要从此页面获取客户端ID和密码，以便将其输入Keycloak Add identity provider页面。 返回Keycloak并指定这些项目。 12.4.7. Microsoft 您必须完成许多步骤才能启用Microsoft登录。 首先，转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择Microsoft。 这将带您进入Add identity provider页面。 添加身份提供者 您无法单击Save，因为您需要从Microsoft获取Client ID 和 Client Secret。 您需要从此页面获得的一条数据是Redirect URI。 当您在其中注册Keycloak作为客户端时，您必须向Microsoft提供此功能，因此请将此URI复制到剪贴板。 要启用使用Microsoft帐户登录，首先必须在Microsoft注册OAuth应用程序。 转到Microsoft应用程序注册URL。 Microsoft经常更改应用程序注册的外观，因此这些说明可能并不总是最新的，配置步骤可能略有不同。 注册应用程序 输入应用程序名称，然后单击Create application。 这将带您进入新应用程序的应用程序设置页面。 设置 您必须从KeycloakAddd Identity Provider页面复制Redirect URI并将其添加到Microsoft应用程序页面上的Redirect URIs字段中。 一定要点击Add Url按钮并Save您的更改。 最后，您需要从此页面获取应用程序ID和密码，以便您可以在Keycloak Add identity provider页面上输入它们。 返回Keycloak并指定这些项目。 从2018年11月起，Microsoft将取消对Live SDK API的支持，转而使用新的Microsoft Graph API。 Keycloak Microsoft身份提供程序已更新为使用新端点，因此请确保升级到Keycloak 4.6.0或更高版本才能使用此提供程序。 此外，在“Live SDK应用程序”下向Microsoft注册的客户端应用程序需要在Microsoft应用程序注册门户中重新注册才能获取应用程序ID 与Microsoft Graph API兼容。 12.4.8. OpenShift OpenShift Online目前处于开发者预览模式。 本文档基于本地安装和本地minishift开发环境。 您需要完成几个步骤才能启用OpenShift登录。 首先，转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择OpenShift。 这将带您进入Add identity provider页面。 添加身份提供者 注册OAuth客户端 您可以使用oc命令行工具注册您的客户端。 $ oc create -f 您的OAuth客户端的name。 在向**/oauth/authorize 和 **/oauth/token发出请求时，将其作为client_id请求参数传递。 secret用作client_secret请求参数。 在对**/oauth/authorize 和 **/oauth/token的请求中指定的redirect_uri参数必须等于（或以前缀为）redirectURIs中的一个URI。 grantMethod用于确定当此客户端请求令牌并且尚未被用户授予访问权时要采取的操作。 使用oc create命令定义的客户机ID和密码将它们输入Keycloak Addd identity provider 页面。 返回Keycloak并指定这些项目。 有关更多详细指南，请参阅官方OpenShift文档。 12.4.9. PayPal 您必须完成许多步骤才能启用PayPal登录。 首先，转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择PayPal。 这将带您进入Add identity provider页面。 添加身份提供者 您无法单击Save，因为您需要从PayPal获取Client ID和Client Secret。 您需要从此页面获得的一条数据是Redirect URI。 当您在其中注册Keycloak作为客户端时，您必须将其提供给PayPal，因此请将此URI复制到剪贴板。 要使用PayPal启用登录，首先必须在PayPal开发人员应用程序中注册应用程序项目。 添加新应用 单击 Create App 按钮。 注册应用程序 现在，您将进入应用程序设置页面。 进行以下更改 选择配置Sandbox或Live（如果尚未在Add identity provider 页面上启用Target Sandbox开关，请选择“Live (实时)”） 复制客户端ID和密码，以便将它们粘贴到Keycloak Add identity provider页面。 向下滚动到 App Settings 从Keycloak Addd Identity Provider页面复制 Redirect URI 并将其输入到 Return URL字段中。 选中 Log In with PayPal 复选框。 检查个人信息部分下的 Full name 复选框。 检查地址信息部分下的 Email address 复选框。 添加指向您域中相应页面的隐私和用户协议URL。 12.4.10. Stack Overflow 为了能够使用Stack Overflow启用登录，您必须完成许多步骤。 首先，转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择Stack Overflow。 这将带您进入Add identity provider页面。 添加身份提供者 要使用Stack Overflow启用登录，首先必须在StackApps上注册OAuth应用程序。 转到在Stack Apps上注册您的应用程序 URL并登录。 堆栈溢出通常会更改应用程序注册的外观，因此这些指示可能并不总是最新的，配置步骤可能略有不同。 注册应用程序 输入应用程序的应用程序名称和OAuth域名，然后单击Register your Application。 输入您想要的其他项目。 设置 最后，您需要从此页面获取客户端ID，密钥和密钥，以便您可以在Keycloak Add identity provider 页面上输入它们。 返回Keycloak并指定这些项目。 12.4.11. Twitter 您必须完成许多步骤才能启用Twitter登录。 首先，转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择Twitter。 这将带您进入 Add identity provider 页面。 添加身份提供者 您无法单击Save，因为您需要从Twitter获取 Client ID 和 Client Secret。 您需要从此页面获得的一条数据是Redirect URI。 当您在其中注册Keycloak作为客户端时，您必须将其提供给Twitter，因此请将此URI复制到剪贴板。 要使用Twtter启用登录，首先必须在Twitter应用程序管理中创建应用程序。 注册应用程序 单击 Create New App 按钮。 这将带您进入 Create an Application 页面。 注册应用程序 输入名称和描述。 网站可以是任何东西，但不能有localhost地址。 对于Callback URL，您必须从Keycloak Addd Identity Provider 页面复制Redirect URI。 你不能在Callback URL中使用localhost。 如果您尝试在笔记本电脑上试驾Twitter登录，请将其替换为127.0.0.1。 单击保存后，您将进入 Details 页面。 应用详情 接下来转到 Keys and Access Tokens 选项卡。 密钥和访问令牌 最后，您需要从此页面获取API密钥和密钥，并将它们复制回Keycloak Add identity provider 页面上的 Client ID 和 Client Secret字段。 12.5. OpenID Connect v1.0 身份提供商 Keycloak可以基于OpenID Connect协议来代理身份提供商。 这些IDP必须支持规范定义的授权代码流程，以便对用户进行身份验证并授权访问。 要开始配置OIDC提供程序，请转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择OpenID Connect v1.0。 这将带您进入Add identity provider页面。 添加身份提供者 此常规配置选项在常规IDP配置中介绍。 您还必须定义OpenID Connect配置选项。 它们基本上描述了您正在与之通信的OIDC IDP。 配置 描述 Authorization URL OIDC协议所需的授权URL端点。 Token URL OIDC协议所需的令牌URL端点。 Logout URL OIDC协议中定义的注销URL端点。 该值是可选的。 Backchannel Logout Backchannel注销是IDP的后台带外REST调用，用于注销用户。 一些IDP只能通过浏览器重定向执行注销，因为它们可能只能通过浏览器cookie识别会话。 User Info URL 用户信息由OIDC协议定义的URL端点。 这是可以从中下载用户配置文件信息的端点。 Client ID 该领域将充当外部IDP的OIDC客户端。 使用授权代码流与外部IDP交互时，您的领域将需要OIDC客户端ID。 Client Secret 在使用授权代码流时，此领域需要使用客户端密钥。 Issuer 国内流离失所者的回应可能包含发行人索赔。 此配置值是可选的。 如果指定，此声明将根据您提供的值进行验证。 Default Scopes 以空格分隔的OIDC范围列表，以便与身份验证请求一起发送。 默认为openid。 Prompt 另一个可选开关。 这是OIDC规范定义的提示参数。 通过它，您可以强制重新身份验证和其他选项。 有关详细信息，请参阅规范。 Validate Signatures 另一个可选开关。 这是为了指定Keycloak是否将验证由此身份提供者签名的外部ID令牌上的签名。 如果启用此选项，Keycloak将需要知道外部OIDC身份提供程序的公钥。 请参阅下文，了解如何进行设置。 警告：出于性能目的，Keycloak会缓存外部OIDC身份提供程序的公钥。 如果您认为您的身份提供商的私钥遭到破坏，那么更新密钥显然很好，但清除密钥缓存也很好。 有关详细信息，请参阅清除缓存 部分。 Use JWKS URL 如果启用 Validate Signatures，则适用。 如果开关打开，则将从给定的JWKS URL下载身份提供者公钥。 这允许极大的灵活性，因为当身份提供者生成新的密钥对时，将始终重新下载新密钥。 如果交换机关闭，则使用Keycloak DB中的公钥（或证书），因此每当身份提供程序密钥对更改时，您始终需要将新密钥导入Keycloak DB。 JWKS URL 存储身份提供程序JWK密钥的URL。 有关详细信息，请参阅JWK规范](https://self-issued.info/docs/draft-ietf-jose-json-web-key.html)。 如果您使用外部Keycloak作为身份提供者，那么您可以使用URL，如http://broker-keycloak:8180/auth/realms/test/protocol/openid-connect/certs，假设您的代理密钥泄露正在运行http://broker-keycloak:8180，它的领域是test。 Validating Public Key 如果 Use JWKS URL 已关闭，则适用。 以下是PEM格式的公钥，必须用于验证外部IDP签名。 Validating Public Key Id 如果 Use JWKS URL 已关闭，则适用。 该字段以PEM格式指定公钥的ID。 此配置值是可选的。 由于没有从密钥计算密钥ID的标准方法，因此各种外部身份提供商可能使用Keycloak中的不同算法。 如果未指定此字段的值，则无论外部IDP发送的密钥ID如何，上面指定的验证公钥都将用于所有请求。 设置时，此字段的值用作Keycloak用于验证来自此类提供程序的签名的密钥ID，并且必须与IDP指定的密钥ID匹配。 您还可以通过提供指向OpenID提供程序元数据的URL或文件来导入所有此配置数据（请参阅OIDC发现规范）。 如果要连接到Keycloak外部IDP，则可以从URL /auth/realms/{realm-name}/.well-known/openid-configuration 导入IDP设置。 此链接是一个JSON文档，描述有关IDP的元数据。 12.6. SAML v2.0 身份提供商 Keycloak可以基于SAML v2.0协议代理身份提供商。 要开始配置SAML v2.0提供程序，请转到Identity Providers左侧菜单项，然后从Add provider下拉列表中选择SAML v2.0。 这将带您进入Add identity provider页面。 添加身份提供者 此常规配置选项在常规IDP配置中介绍。 您还必须定义SAML配置选项。 它们基本上描述了您正在与之通信的SAML IDP。 配置 描述 Single Sign-On Service URL 这是必填字段，指定SAML端点以启动身份验证过程。 如果您的SAML IDP发布IDP实体描述符，则将在此处指定此字段的值。 Single Logout Service URL 这是一个可选字段，用于指定SAML注销端点。 如果您的SAML IDP发布IDP实体描述符，则将在此处指定此字段的值。 Backchannel Logout 如果您的SAML IDP支持反向信道注销，则启用。 NameID Policy Format 指定与名称标识符格式对应的URI引用。 默认为 urn:oasis:names:tc:SAML:2.0:nameid-format:persistent。 HTTP-POST Binding Response 当这个领域响应外部IDP发送的任何SAML请求时，应该使用哪个SAML绑定？ 如果设置为off，则将使用Redirect Binding。 HTTP-POST Binding for AuthnRequest 当此领域从外部SAML IDP请求身份验证时，应使用哪个SAML绑定？ 如果设置为off，则将使用Redirect Binding。 Want AuthnRequests Signed 如果为true，它将使用领域的密钥对来签署发送到外部SAML IDP的请求。 Signature Algorithm 如果启用了 Want AuthnRequests Signed ，那么您也可以选择要使用的签名算法。 SAML Signature Key Name 通过POST绑定发送的签名SAML文档包含KeyName元素中的签名密钥的标识。 默认情况下，此项包含Keycloak密钥ID。 但是，各种外部SAML IDP可能需要不同的密钥名称或根本没有密钥名称。 此开关控制KeyName是否包含密钥ID（选项KEY_ID），来自对应于领域密钥的证书（选项CERT_SUBJECT - 例如Microsoft Active Directory联合服务预期），或者密钥名称提示是完全的 从SAML消息中省略（选项NONE）。 Force Authentication 表示即使用户已经登录，也会强制用户在外部IDP上输入凭据。 Validate Signature 该域是否应该期望来自外部IDP的SAML请求和响应被数字签名。 强烈建议你打开它！ Validating X509 Certificate 将用于验证来自外部IDP的SAML请求和响应的签名的公共证书。 You can also import all this configuration data by providing a URL or file that points to the SAML IDP entity descriptor of the external IDP. If you are connecting to a Keycloak external IDP, you can import the IDP settings from the URL /auth/realms/{realm-name}/protocol/saml/descriptor. This link is an XML document describing metadata about the IDP. You can also import all this configuration data by providing a URL or XML file that points to the entity descriptor of the external SAML IDP you want to connect to. 12.6.1. SP描述符 创建SAML提供程序后，在查看该提供程序时会出现一个EXPORT按钮。 单击此按钮将导出SAML SP实体描述符，您可以使用该描述符导入外部SP。 此元数据也可通过转到URL公开获得。 http[s]://{host:port}/auth/realms/{realm-name}/broker/{broker-alias}/endpoint/descriptor 12.7. 客户建议身份提供商 OIDC应用程序可以通过指定他们想要使用哪个身份提供者的提示来绕过Keycloak登录页面。 这是通过在授权代码流授权端点中设置kc_idp_hint查询参数来完成的。 Keycloak OIDC客户端适配器还允许您在应用程序中访问受保护资源时指定此查询参数。 例如： GET /myapplication.com?kc_idp_hint=facebook HTTP/1.1 Host: localhost:8080 在这种情况下，预计您的领域有一个带有别名facebook的身份提供者。 如果此提供程序不存在，将显示登录表单。 如果您使用keycloak.js适配器，您也可以实现相同的行为： var keycloak = new Keycloak('keycloak.json'); keycloak.createLoginUrl({ idpHint: 'facebook' }); kc_idp_hint查询参数还允许客户端覆盖默认身份提供者（如果为Identity Provider Redirector身份验证器配置了一个身份提供者）。 客户端还可以通过将kc_idp_hint查询参数设置为空值来禁用自动重定向。 12.8. 映射声明和断言 您可以将要进行身份验证的外部IDP提供的SAML和OpenID Connect元数据导入到领域的环境中。 这允许您提取用户配置文件元数据和其他信息，以便您可以将其提供给您的应用程序。 通过外部身份提供者登录您的领域的每个新用户将根据SAML或OIDC断言和声明中的元数据，在本地Keycloak数据库中创建一个条目。 如果您点击您所在领域的“身份提供商”页面中列出的身份提供商，您将被带到IDP Settings 标签。 在这个页面上还有一个Mappers选项卡。 单击该选项卡以开始映射传入的IDP元数据。 这个页面上有一个 Create 按钮。 单击此创建按钮可以创建代理映射器。 Broker mappers可以将SAML属性或 OIDC ID/Access 令牌声明导入用户属性和用户角色映射。 从Mapper Type列表中选择一个映射器。 将鼠标悬停在工具提示上可查看映射器的功能说明。 工具提示还描述了您需要输入的配置信息。 单击Save，将添加新的映射器。 对于基于JSON的声明，您可以使用点表示法进行嵌套，使用方括号来按索引访问数组字段。 例如contact.address[0].country。 要调查社交提供程序提供的用户配置文件JSON数据的结构，您可以启用DEBUG级别记录器org.keycloak.social.user_profile_dump。 这是在服务器的app-server配置文件（domain.xml或standalone.xml）中完成的。 12.9. 可用的用户会话数据 用户从外部IDP登录后，Keycloak会存储一些您可以访问的其他用户会话记录数据。 此数据可以传播到客户端，通过令牌请求登录，或者使用适当的客户端映射器将SAML断言传递回客户端。 identity_provider 这是用于执行登录的代理的IDP别名。 identity_provider_identity 这是当前经过身份验证的用户的IDP用户名。 这通常与Keycloak用户名相同，但不一定需要。 例如，Keycloak用户john可以链接到Facebook用户john123@gmail.com，因此在这种情况下，用户会话注释的值将是john123@gmail.com。 您可以使用类型为 User Session Note 的协议映射器将此信息传播给您的客户端。 12.10. 首次登录流程 当用户通过身份代理登录时，会在域的本地数据库中导入和链接用户的某些方面。 当Keycloak通过外部身份提供商成功验证用户时，可能存在两种情况： 已导入Keycloak用户帐户并与经过身份验证的身份提供商帐户关联。 在这种情况下，Keycloak将仅作为现有用户进行身份验证并重定向回应用程序。 尚未为此外部用户导入和链接现有的Keycloak用户帐户。 通常，您只想注册并将新帐户导入Keycloak数据库，但如果现有的Keycloak帐户使用相同的电子邮件，该怎么办？ 自动将现有本地帐户链接到外部身份提供商是一个潜在的安全漏洞，因为您无法始终信任从外部身份提供商处获得的信息。 在处理上面列出的一些冲突和情况时，不同的组织有不同的要求。 为此，IDP设置中有一个First Login Flow选项，允许您选择工作流程用户首次从外部IDP登录后使用。 默认情况下，它指向 first broker login 流，但您可以配置和使用自己的流，并为不同的身份提供者使用不同的流。 流本身在管理控制台的 Authentication 选项卡下配置。 当您选择 First Broker Login 流程时，您将看到默认情况下使用的验证器。 您可以重新配置现有流。 （例如，您可以禁用某些验证器，将其中一些标记为required，配置一些验证器等）。 您还可以创建新的身份验证流和/或编写自己的身份验证器实现，并在流中使用它。 有关详细信息，请参阅服务器开发人员指南。 12.10.1. 默认首次登录流程 让我们描述First Broker Login流程提供的默认行为。 Review Profile(回顾概要) 此验证器可能会显示配置文件信息页面，用户可以在其中查看从身份提供商处检索到的配置文件。 验证器是可配置的。 您可以设置Update Profile On First Login选项。 当On时，将始终向用户显示要查询其他信息的个人资料页面，以便联合他们的身份。 当missing时，只有在身份提供者未提供某些必需信息（电子邮件，名字，姓氏）时，才会向用户显示个人资料页面。 如果Off，则不会显示配置文件页面，除非用户在Review profile info链接的后续阶段点击（后续阶段显示的页面为Confirm Link Existing Account验证者）。 Create User If Unique(创建用户如果唯一) 此身份验证器检查是否已存在具有相同电子邮件或用户名的现有Keycloak帐户，例如来自身份提供商的帐户。 如果不是，那么验证者只需创建一个新的本地Keycloak帐户并将其与身份提供者链接，整个流程就完成了。 否则它将转到下一个Handle Existing Account子流。 如果您始终希望确保没有重复的帐户，则可以将此身份验证器标记为REQUIRED。 在这种情况下，如果存在现有的Keycloak帐户，则用户将看到错误页面，并且用户需要通过帐户管理链接其身份提供商帐户。 Confirm Link Existing Account(确认链接现有帐户) 在信息页面上，用户将看到存在具有相同电子邮件的现有Keycloak帐户。 他们可以再次查看他们的个人资料并使用不同的电子邮件或用户名（重新启动流程并返回Review Profile身份验证器）。 或者他们可以确认他们想要将他们的身份提供者帐户与他们现有的Keycloak帐户相关联。 如果您不希望用户看到此确认页面，请禁用此身份验证器，但直接通过电子邮件验证或重新身份验证链接身份提供商帐户。 Verify Existing Account By Email(通过电子邮件验证现有帐户) 默认情况下，此身份验证器为ALTERNATIVE，因此仅在域配置了SMTP设置时才使用它。 它将向用户发送电子邮件，在那里他们可以确认他们想要将身份提供者与他们的Keycloak帐户相关联。 如果您不想通过电子邮件确认链接，请禁用此选项，但您始终希望用户使用其密码（以及OTP）重新进行身份验证。 通过重新身份验证验证现有帐户 如果禁用或不可用电子邮件身份验证器（SMTP未配置为域），则使用此身份验证器。 它将显示一个登录屏幕，用户需要使用其密码进行身份验证，以将其Keycloak帐户与身份提供商进行链接。 用户还可以使用某些不同的身份提供程序重新进行身份验证，该提供程序已与其Keycloak帐户相关联。 您还可以强制用户使用OTP。 否则它是可选的，仅在已为用户帐户设置OTP时使用。 12.10.2. 自动链接现有的第一个登录流程 在用户可以使用任意用户名/电子邮件地址注册自己的通用环境中，AutoLink身份验证器会很危险。 除非精心策划用户注册并分配用户名/电子邮件地址，否则请勿使用此身份验证器。 要配置第一个登录流，用户在不提示的情况下自动链接，请使用以下两个身份验证器创建新流： Create User If Unique(创建用户如果唯一) 此身份验证器可确保处理唯一用户。 将验证者要求设置为\"Alternative(备选)\"。 Automatically Link Brokered Account(自动链接经纪人账户) 使用此身份验证器自动链接代理身份而无需任何验证。 这在多个用户数据库的Intranet环境中非常有用，每个用户数据库都有重叠的用户名/电子邮件地址，但密码不同，并且您希望允许用户使用任何密码而无需验证。 如果您管理所有内部数据库，并且来自与另一个数据库中的用户名/电子邮件地址匹配的用户名/电子邮件地址属于同一个人，则这是合理的。 将验证者要求设置为\"Alternative(备选)\"。 所描述的设置使用两个验证器，并且是最简单的验证器，但可以根据您的需要使用其他验证器。 例如，如果您仍希望最终用户确认其配置文件信息，则可以将审阅配置文件身份验证器添加到流的开头。 12.11. 检索外部IDP令牌 Keycloak允许您使用外部IDP存储令牌和来自身份验证过程的响应。 为此，您可以在IDP的设置页面上使用Store Token配置选项。 应用程序代码可以检索这些令牌和响应以提取额外的用户信息，或安全地调用外部IDP上的请求。 例如，应用程序可能希望使用Google令牌来调用其他Google服务和REST API。 要检索特定身份提供者的令牌，您需要发送请求，如下所示： GET /auth/realms/{realm}/broker/{provider_alias}/token HTTP/1.1 Host: localhost:8080 Authorization: Bearer 应用程序必须已通过Keycloak进行身份验证并已收到访问令牌。 此访问令牌需要设置broker客户端级别角色read-token。 这意味着用户必须具有此角色的角色映射，并且客户端应用程序必须在其范围内具有该角色。 在这种情况下，假设您在Keycloak中访问受保护的服务，则需要在用户身份验证期间发送Keycloak发出的访问令牌。 在代理配置页面中，您可以通过打开Stored Tokens Readable开关，自动将此角色分配给新导入的用户。 可以通过再次通过提供程序登录或使用客户端启动的帐户链接API重新建立这些外部令牌。 12.12. 身份代理注销 当触发从Keycloak注销时，Keycloak将向用于登录Keycloak的外部身份提供者发送请求，并且该用户也将从该身份提供者注销。 可以跳过此行为并避免在外部身份提供程序中注销。 有关详细信息，请参阅适配器注销文档。 13. 用户会话管理 当用户登录领域时，Keycloak会为他们维护一个用户会话，并记住他们在会话中访问过的每个客户端。 领域管理员可以对这些用户会话执行许多管理功能。 他们可以查看整个领域的登录统计信息，并深入到每个客户端以查看谁登录以及在哪里登录。 管理员可以从管理控制台注销用户或用户组。 他们可以撤销令牌并在那里设置所有令牌和会话超时。 13.1. 管理会话 如果您转到Sessions左侧菜单项，您可以看到该领域当前活动的会话数的顶级视图。 Sessions 给出了客户端列表以及当前为该客户端提供的活动会话数。 您还可以通过单击此列表右侧的Logout all按钮注销域中的所有用户。 13.1.1. 退出所有限制 任何SSO cookie集现在都将无效，并且在活动浏览器会话中请求身份验证的客户端现在必须重新登录。 只有某些客户端会收到此注销事件的通知，特别是使用Keycloak OIDC客户端适配器的客户端。 其他客户端类型（即SAML）将不会收到反向信道注销请求。 重要的是要注意，单击“全部注销”不会撤消任何未完成的访问令牌。 他们必须自然到期。 您必须将撤销策略推送到客户端，但这也仅适用于使用Keycloak OIDC客户端的客户端 适配器。 13.1.2. 应用追溯 在Sessions页面上，您还可以深入查看每个客户端。 这将带您进入该客户端的Sessions选项卡。 单击Show Sessions按钮，可以查看哪些用户登录到该应用程序。 Application Sessions(应用程序会话) 13.1.3. 用户追溯 如果您转到单个用户的Sessions选项卡，您还可以查看会话信息。 User Sessions(用户会话) 13.2. 撤销策略 如果您的系统遭到入侵，您将需要一种方法来撤销所有会话并访问已分发的令牌。 您可以通过转到Sessions屏幕的Revocation选项卡来完成此操作。 Revocation(撤销) 您只能设置基于时间的撤销策略。 控制台允许您指定在该时间和日期之前发出的任何会话或令牌无效的时间和日期。 Set to now将策略设置为当前时间和日期。 Push按钮会将此撤销策略推送到任何已安装Keycloak OIDC客户端适配器的已注册OIDC客户端。 13.3. 会话和令牌超时 Keycloak为您提供对会话，cookie和令牌超时的精细控制。 这都是在Realm Settings左侧菜单项的Tokens选项卡上完成的。 Tokens Tab 让我们来看看这个页面上的每个项目。 配置 描述 Revoke Refresh Token 对于正在执行刷新令牌流的OIDC客户端，此标志（如果启用）将撤消该刷新令牌，并发出另一个请求客户端必须使用的令牌。 这基本上意味着刷新令牌具有一次性使用。 SSO Session Idle 也适用于OIDC客户。 如果用户的活动时间超过此超时时间，则用户会话将失效。 如何检查空闲时间？ 请求身份验证的客户端将阻止空闲超时。 刷新令牌请求也会影响空闲超时。 在会话实际无效之前，始终会有一个小的时间窗口添加到空闲超时（请参阅下面的注释）。 SSO Session Max 用户会话到期和无效之前的最长时间。 这是一个艰难的数字和时间。 它控制用户会话保持活动状态的最长时间，无论活动如何。 SSO Session Idle Remember Me 与标准SSO会话空闲配置相同，但特定于登录并记住我已启用。 当在登录过程中选择记住我时，它允许规定更长的会话空闲超时。 它是可选配置，如果未设置为大于0的值，则使用SSO会话空闲配置中设置的相同空闲超时。 SSO Session Max Remember Me 与标准SSO会话最大值相同，但特定于登录并记住我已启用。 当在登录过程中选择记住我时，它允许规定更长寿的会话。 它是可选配置，如果未设置为大于0的值，则使用SSO会话最大配置中设置的相同会话生命周期。 Offline Session Idle 对于离线访问，这是在撤消脱机令牌之前允许会话保持空闲的时间。 在会话实际无效之前，始终会有一个小的时间窗口添加到空闲超时（请参阅下面的注释）。 Offline Session Max Limited 对于离线访问，如果启用此标志，则启用Offline Session Max以控制脱机令牌的最长时间 无论活动如何，都可以保持活跃状态 Offline Session Max 对于离线访问，这是撤消相应脱机令牌之前的最长时间。 这是一个艰难的数字和时间。 它控制脱机令牌保持活动状态的最长时间，无论活动如何。 Access Token Lifespan 创建OIDC访问令牌时，此值会影响到期时间。 Access Token Lifespan For Implicit Flow 使用Implicit Flow，不提供刷新令牌。 因此，使用Implicit Flow创建的访问令牌会有单独的超时。 Client login timeout 这是客户端在OIDC中完成授权代码流的最长时间。 Login timeout 登录必须花费的总时间。 如果身份验证的时间超过此时间，则用户必须启动身份验证过程。 Login action timeout 用户在身份验证过程中可以在任何一个页面上花费的最长时间。 User-Initiated Action Lifespan 用户发送的动作许可证（例如，忘记密码电子邮件）之前的最长时间已过期。 建议此值较短，因为预计用户会快速响应自行创建的操作。 Default Admin-Initiated Action Lifespan 管理员向用户发送操作许可证之前的最长时间已过期。 建议此值很长，以允许管理员为当前处于脱机状态的用户发送电子邮件。 在发出令牌之前，可以覆盖默认超时。 Override User-Initiated Action Lifespan 允许每次操作具有独立超时的可能性（例如，电子邮件验证，忘记密码，用户操作和身份提供商电子邮件验证）。 此字段不是必需的，如果未指定任何内容，则默认为 User-Initiated Action Lifespan 中配置的值。 对于空闲超时，会有一个小的时间窗口（2分钟），在此期间会话保持未到期。 例如，当您将超时设置为30分钟时，它实际上将在会话过期前32分钟。 对于集群和跨数据中心环境中的某些角落情况，如果令牌在到期前的一个集群节点上刷新很短的时间，而其他集群节点在此期间错误地将会话视为 已过期，因为他们尚未从执行刷新的节点收到有关成功刷新的消息。 13.4. 离线访问 脱机访问是OpenID Connect规范中描述的功能。 我们的想法是，在登录期间，您的客户端应用程序将请求脱机令牌而不是经典的刷新令牌。 应用程序可以将此脱机令牌保存在数据库或磁盘上，即使用户已注销，也可以在以后使用它。 如果您的应用程序需要代表用户执行某些\"offline\"操作，即使用户不在线，这也很有用。 一个例子是每晚定期备份一些数据。 您的应用程序负责将脱机令牌保存在某个存储（通常是数据库）中，然后使用它从Keycloak服务器手动检索新的访问令牌。 经典刷新令牌和离线令牌之间的区别在于，离线令牌在默认情况下永不过期，并且不受 SSO Session Idle timeout 和 SSO Session Max lifespan 的影响。即使在用户注销或服务器重新启动后，脱机令牌仍然有效。但是，默认情况下，您需要至少每30天使用脱机令牌进行一次刷新令牌操作（此值，Offline Session Idle timeout，可以在管理控制台中的Tokens选项卡中更改为Realm Settings设置）。此外，如果启用Offline Session Max Limited选项，则脱机令牌将在60天后过期，无论使用脱机令牌进行刷新令牌操作（此值，Offline Session Max lifespan，也可以在“领域设置”下的“令牌”选项卡中的管理控制台。此外，如果启用Revoke refresh tokens选项，则每个脱机令牌只能使用一次。因此，刷新后，您始终需要将刷新响应中的新脱机令牌存储到您的数据库中，而不是之前的数据库中。 用户可以在用户帐户服务中查看和撤消已由他们授予的脱机令牌。 管理员用户可以在特定用户的Consents(同意)选项卡中撤消管理控制台中各个用户的离线令牌。 管理员还可以查看在每个客户端的Offline Access选项卡中发布的所有脱机令牌。 也可以通过设置撤销策略撤销离线令牌。 为了能够发出脱机令牌，用户需要具有领域级角色offline_access的角色映射。 客户还需要在其范围内具有该角色。 最后，客户端需要将offline_access客户端作用域添加为Optional client scope，默认情况下完成。 客户端可以在向Keycloak发送授权请求时通过添加参数scope=offline_access来请求脱机令牌。 当您使用Keycloak OIDC客户端适配器访问应用程序的安全URL（即http://localhost:8080/customer-portal/secured?scope=offline_access）时，它会自动添加此参数。 如果在身份验证请求的正文中包含scope=offline_access，则直接访问授权和服务帐户也支持脱机令牌。 14. 用户存储联合 许多公司都有现有的用户数据库，用于保存有关用户及其密码或其他凭据的信息。 在许多情况下，无法将这些现有存储迁移到纯粹的Keycloak部署。 Keycloak可以联合现有的外部用户数据库。 开箱即用，我们支持LDAP和Active Directory。 您还可以使用我们的用户存储SPI为您可能拥有的任何自定义用户数据库编写自己的扩展。 它的工作方式是当用户登录时，Keycloak将查看其自己的内部用户存储以查找用户。 如果它找不到它，它将遍历为域配置的每个用户存储提供程序，直到找到匹配项。 来自外部存储的数据映射到Keycloak运行时使用的公共用户模型。 然后，可以将此公共用户模型映射到OIDC令牌声明和SAML断言属性。 外部用户数据库很少拥有支持Keycloak所具有的所有功能所需的每一项数据。 在这种情况下，用户存储提供程序可以选择在Keycloak用户存储中本地存储一些内容。 有些提供商甚至在本地导入用户并定期与外部商店同步。 所有这些都取决于提供商的功能及其配置方式。 例如，您的外部用户存储可能不支持OTP。 根据提供商的不同，Keycloak可以处理和存储此OTP。 14.1. 添加提供商 要添加存储提供程序，请转到管理控制台中的User Federation左侧菜单项。 用户联盟 在中心，有一个Add Provider列表框。 选择要添加的提供程序类型，然后您将进入该提供程序的配置页面。 14.2. 处理提供商失败 如果用户存储提供程序失败，也就是说，如果LDAP服务器已关闭，则可能无法登录，并且可能无法在管理控制台中查看用户。 使用存储提供程序查找用户时，Keycloak不会捕获故障。 它将中止调用。 因此，如果您有一个优先级较高的存储提供程序在用户查找期间失败，则登录或用户查询将完全失败并发生异常并中止。 它不会故障转移到下一个配置的提供程序。 始终首先搜索本地Keycloak用户数据库，以便在任何LDAP或自定义用户存储提供程序之前解析用户。 您可能需要考虑创建存储在本地Keycloak用户数据库中的管理员帐户，以防万一在连接到LDAP和自定义后端时出现任何问题。 每个LDAP和自定义用户存储提供程序在其管理控制台页面上都有一个enable开关。 禁用用户存储提供程序将在执行用户查询时跳过提供程序，以便您可以查看和登录可能存储在具有较低优先级的其他提供程序中的用户。 如果您的提供商使用import策略并禁用它，则导入的用户仍可用于查找，但仅限于只读模式。 在重新启用提供程序之前，您将无法修改这些用户。 如果存储提供程序查找失败，Keycloak不会进行故障转移的原因是用户数据库通常具有重复的用户名或它们之间的重复电子邮件。 这可能导致安全问题和无法预料的问题，因为当管理员期望从另一个用户加载用户时，可以从一个外部存储加载用户。 14.3. LDAP和Active Directory Keycloak附带内置的LDAP/AD提供程序。 可以在同一Keycloak领域中联合多个不同的LDAP服务器。 您可以将LDAP用户属性映射到Keycloak通用用户模型。 默认情况下，它映射用户名，电子邮件，名字和姓氏，但您可以自由配置其他映射。 LDAP提供程序还支持通过LDAP/AD协议进行密码验证以及不同的存储，编辑和同步模式。 要配置联合LDAP存储，请转至管理控制台。 单击 User Federation 左侧菜单选项。 当你到达这个页面时，有一个Add Provider选择框。 您应该在此列表中看到ldap。 选择ldap将带您进入LDAP配置页面。 14.3.1. 存储模式 默认情况下，Keycloak会将用户从LDAP导入到本地Keycloak用户数据库中。 该用户副本可以按需同步，也可以通过定期后台任务同步。 一个例外是密码。 不会导入密码，并且会将密码验证委派给LDAP服务器。 这种方法的好处是所有Keycloak功能都可以工作，因为所需的任何额外的每用户数据都可以存储在本地。 此方法还减少了LDAP服务器上的负载，因为第二次访问时，Keycloak数据库会加载未缓存的用户。 LDAP服务器唯一的负载是密码验证。 这种方法的缺点是，当首次查询用户时，这将需要Keycloak数据库插入。 导入还必须根据需要与LDAP服务器同步。 或者，您可以选择不将用户导入Keycloak用户数据库。 在这种情况下，Keycloak运行时使用的公共用户模型仅由LDAP服务器支持。 这意味着如果LDAP不支持Keycloak功能所需的数据，则该功能将无法使用。 这种方法的好处是您没有将LDAP用户的副本导入和同步到Keycloak用户数据库的开销。 此存储模式由Import Users开关控制。 设置为On以导入用户。 14.3.2. 编辑模式 用户通过用户帐户服务和管理员通过管理控制台可以修改用户元数据。 根据您的设置，您可能拥有或不拥有LDAP更新权限。 Edit Mode配置选项定义了LDAP存储的编辑策略。 READONLY(只读) 用户名，电子邮件，名字，姓氏和其他映射属性将不可更改。 任何人试图更新这些字段时，Keycloak都会显示错误。 此外，不支持密码更新。 WRITABLE(可写) 用户名，电子邮件，名字，姓氏以及其他映射的属性和密码都可以更新，并将自动与LDAP存储同步。 UNSYNCED(不同步) 对用户名，电子邮件，名字，姓氏和密码的任何更改都将存储在Keycloak本地存储中。 由您决定如何同步回LDAP。 这允许Keycloak部署支持在只读LDAP服务器上更新用户元数据。 此选项仅在将用户从LDAP导入本地Keycloak用户数据库时适用。 14.3.3. 其他配置选项 Console Display Name(控制台显示名称) 在管理控制台中引用此提供程序时使用的名称 Priority(优先级) 查找用户或添加用户时此提供程序的优先级。 Sync Registrations(同步注册) 您的LDAP是否支持添加新用户？ 如果希望将管理控制台中的Keycloak创建的新用户或注册页面添加到LDAP，请单击此开关。 Allow Kerberos authentication(允许Kerberos身份验证) 使用从LDAP配置的用户数据在领域中启用Kerberos/SPNEGO身份验证。 更多信息请参见Kerberos部分。 Other options(其他选项) 其余配置选项应该是自解释的。 您可以将鼠标悬停在管理控制台中的工具提示，以查看有关它们的更多详细信息。 14.3.4. 通过SSL连接到LDAP 当您为LDAP存储配置安全连接URL时（例如ldaps://myhost.com:636），Keycloak将使用SSL与LDAP服务器进行通信。 重要的是在Keycloak服务器端正确配置信任库，否则Keycloak不能信任到LDAP的SSL连接。 可以使用Truststore SPI配置Keycloak的全局信任库。 有关更多详细信息，请查看服务器安装和配置指南。 如果未配置信任库SPI，则信任库将回退到Java提供的缺省机制（系统属性javax.net.ssl.trustStore提供的文件或JDK提供的cacerts文件，如果系统属性为 没有设置）。 在LDAP联合提供程序配置中有一个配置属性Use Truststore SPI，您可以在其中选择是否使用Truststore SPI。 默认情况下，该值为Only for ldaps，这适用于大多数部署。 仅当与LDAP的连接以ldaps开头时，才会使用Truststore SPI。 14.3.5. LDAP用户与Keycloak的同步 如果启用了导入，LDAP提供程序将自动负责将所需LDAP用户同步（导入）到Keycloak本地数据库中。 当用户登录时，LDAP提供程序会将LDAP用户导入Keycloak数据库，然后根据LDAP密码进行身份验证。 这是用户导入的唯一时间。 如果您转到管理控制台中的Users左侧菜单项并单击View all users按钮，您将只看到那些已被Keycloak至少验证过一次的LDAP用户。 它以这种方式实现，以便管理员不会意外地尝试导入庞大的LDAP用户数据库。 如果要将所有LDAP用户同步到Keycloak数据库，可以配置并启用您配置的LDAP提供程序的Sync Settings。 有两种类型的同步： 定期完全同步 这会将所有LDAP用户同步到Keycloak DB中。 那些已经存在于Keycloak中并在LDAP中直接更改的LDAP用户将在Keycloak DB中更新（例如，如果用户Mary Kelly在LDAP中更改为'Mary Smith`）。 定期更改用户同步 发生同步时，仅更新和/或导入在上次同步后创建或更新的用户。 处理同步的最佳方法是在首次创建LDAP提供程序时单击Synchronize all users按钮，然后设置已更改用户的定期同步。 LDAP提供程序的配置页面有几个选项可以为您提供支持。 14.3.6. LDAP映射器 LDAP映射器是listeners，由LDAP提供程序在各个点触发，为LDAP集成提供另一个扩展点。 当用户通过LDAP登录并需要导入，在Keycloak启动的注册期间或从管理控制台查询用户时，会触发它们。 当您创建LDAP联合提供程序时，Keycloak将自动为此提供程序提供一组内置的mappers。 您可以自由更改此设置并创建新的映射器或更新/删除现有映射器。 User Attribute Mapper(用户属性映射器) 这允许您指定将哪个LDAP属性映射到Keycloak用户的哪个属性。 因此，例如，您可以将LDAP属性mail配置为Keycloak数据库中的email属性。 对于此映射器实现，始终存在一对一映射（一个LDAP属性映射到一个Keycloak属性） FullName Mapper(全名映射器) 这允许您指定保存在某个LDAP属性（通常是cn）中的用户的全名将映射到Keycloak数据库中的firstName和lastname属性。 让cn包含用户的全名是某些LDAP部署的常见情况。 Role Mapper(角色映射器) 这允许您配置从LDAP到Keycloak角色映射的角色映射。 可以使用一个角色映射器将LDAP角色（通常是来自LDAP树的特定分支的组）映射到与指定客户端的域角色或客户端角色相对应的角色。 为同一LDAP提供程序配置更多角色映射器不是问题。 因此，例如，您可以指定来自ou=main,dc=example,dc=org下的组的角色映射将映射到域ou=finance,dc=example,dc=org下的域中的域角色映射和角色映射 将映射到客户端finance`的客户端角色映射。 Hardcoded Role Mapper(硬编码角色映射器) 此映射器将为与LDAP链接的每个Keycloak用户授予指定的Keycloak角色。 Group Mapper(组映射器) 这允许您将组映射从LDAP配置为Keycloak组映射。 组映射器可用于将LDAP树的特定分支中的LDAP组映射到Keycloak中的组。 它还会将用户组映射从LDAP传播到Keycloak中的用户组映射。 MSAD User Account Mapper(MSAD用户帐户映射器) 此映射器特定于Microsoft Active Directory(MSAD)。 它能够将MSAD用户帐户状态紧密集成到Keycloak帐户状态（启用帐户，密码已过期等）。 它使用userAccountControl和pwdLastSet LDAP属性。 （两者都是MSAD特有的，不是LDAP标准）。 例如，如果pwdLastSet为0，则Keycloak用户需要更新其密码，并且将向用户添加UPDATE_PASSWORD所需的操作。 如果userAccountControl是514（禁用帐户），Keycloak用户也被禁用。 默认情况下，有用户属性映射器将基本的Keycloak用户属性（如用户名，名字，姓氏和电子邮件）映射到相应的LDAP属性。 您可以自由扩展这些并提供其他属性映射。 管理控制台提供工具提示，这有助于配置相应的映射器。 14.3.7. 密码哈希 当用户的密码从Keycloak更新并发送到LDAP时，它始终以纯文本形式发送。 这与将密码更新为内置Keycloak数据库不同，当在将密码发送到DB之前对密码应用散列和salting时。 对于LDAP，Keycloak依赖于LDAP服务器来提供密码的散列和腌制。 大多数LDAP服务器（Microsoft Active Directory，RHDS，FreeIPA）默认提供此功能。 其他一些（OpenLDAP，ApacheDS）可能默认以纯文本形式存储密码，您可能需要为它们显式启用密码散列。 请参阅LDAP服务器的文档更多详细信息。 14.4. SSSD和FreeIPA身份管理集成 Keycloak还附带了一个内置的SSSD（系统安全服务守护程序）插件。 SSSD是最新的Fedora或Red Hat Enterprise Linux的一部分，可以访问多个身份和身份验证提供程序。 它提供故障转移和脱机支持等好处。 有关配置选项的详细信息，请参阅红帽企业Linux身份管理文档。 SSSD还与FreeIPA身份管理（IdM）服务器集成，提供身份验证和访问控制。 对于Keycloak，我们受益于此集成验证PAM服务和从SSSD检索用户数据。 有关在Linux环境中使用Red Hat Identity Management的更多信息，请参阅Red Hat Enterprise Linux身份管理文档。 Keycloak和SSSD之间的大多数通信都是通过只读D-Bus接口实现的。 因此，配置和更新用户的唯一方法是使用FreeIPA/IdM管理界面。 默认情况下，与LDAP联合提供程序一样，它仅设置为导入用户名，电子邮件，名字和姓氏。 组和角色会自动注册，但不会同步，因此Keycloak管理员直接在Keycloak中所做的任何更改都不会与SSSD同步。 下面是有关如何配置FreeIPA/IdM服务器的信息。 14.4.1. FreeIPA/IdM服务器 为简单起见，使用了FreeIPA Docker image。 要设置服务器，请参阅FreeIPA文档。 使用Docker运行FreeIPA服务器需要以下命令： docker run --name freeipa-server-container -it \\ -h server.freeipa.local -e PASSWORD=YOUR_PASSWORD \\ -v /sys/fs/cgroup:/sys/fs/cgroup:ro \\ -v /var/lib/ipa-data:/data:Z freeipa/freeipa-server 带有server.freeipa.local的参数-h代表FreeIPA/IdM服务器主机名。 务必将YOUR_PASSWORD更改为您选择的密码。 容器启动后，将/etc/hosts更改为： x.x.x.x server.freeipa.local 如果不进行此更改，则必须设置DNS服务器。 为了在Keycloak上启动并运行SSSD联合提供程序，您必须在IPA域中注册Linux机器： ipa-client-install --mkhomedir -p admin -w password 要确保一切按预期工作，请在客户端计算机上运行： kinit admin 系统将提示您输入密码。 之后，您可以使用以下命令将用户添加到IPA服务器： $ ipa user-add john --first=John --last=Smith --email=john@smith.com --phone=042424242 --street=\"Testing street\" \\ --city=\"Testing city\" --state=\"Testing State\" --postalcode=0000000000 14.4.2. SSSD and D-Bus 如前所述，联合提供程序使用D-BUS从SSSD获取数据，并使用PAM进行身份验证。 首先，您必须安装sssd-dbus RPM，它允许来自SSSD的信息通过系统总线传输。 $ sudo yum install sssd-dbus 您必须运行Keycloak发行版中提供的配置脚本： $ bin/federation-sssd-setup.sh 该脚本对/etc/sssd/sssd.conf进行必要的更改： [domain/your-hostname.local] ... ldap_user_extra_attrs = mail:mail, sn:sn, givenname:givenname, telephoneNumber:telephoneNumber ... [sssd] services = nss, sudo, pam, ssh, ifp ... [ifp] allowed_uids = root, yourOSUsername user_attributes = +mail, +telephoneNumber, +givenname, +sn 另外，/etc/pam.d/下包含keycloak文件： auth required pam_sss.so account required pam_sss.so 通过运行dbus-send确保一切正常运行： sudo dbus-send --print-reply --system --dest=org.freedesktop.sssd.infopipe /org/freedesktop/sssd/infopipe org.freedesktop.sssd.infopipe.GetUserGroups string:john 您应该能够看到用户的组。 如果此命令返回超时或错误，则表示联合提供程序也无法在Keycloak上检索任何内容。 大多数情况下，这是因为机器未注册FreeIPA IdM服务器或您无权访问SSSD服务。 如果您没有权限，请确保运行Keycloak的用户包含在以下部分的/etc/sssd/sssd.conf文件中： [ifp] allowed_uids = root, your_username 14.4.3. 启用SSSD联合提供程序 Keycloak使用DBus-Java与D-Bus进行低级通信，这取决于Unix套接字库。 可以在此存储库中找到此库的RPM。 在安装之前，请务必检查RPM签名： $ rpm -K libunix-dbus-java-0.8.0-1.fc24.x86_64.rpm libunix-dbus-java-0.8.0-1.fc24.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID 84dc9914: OK Header SHA1 digest: OK (d17bb7ebaa7a5304c1856ee4357c8ba4ec9c0b89) V4 RSA/SHA256 Signature, key ID 84dc9914: OK MD5 digest: OK (770c2e68d052cb4a4473e1e9fd8818cf) $ sudo yum install libunix-dbus-java-0.8.0-1.fc24.x86_64.rpm 使用PAM进行身份验证Keycloak使用JNA。 确保安装了此软件包： $ sudo yum install jna 使用sssctl user-checks命令验证您的设置： $ sudo sssctl user-checks admin -s keycloak 14.5. 配置联合SSSD存储 安装后，您需要配置联合SSSD存储。 要配置联合SSSD存储，请完成以下步骤： 导航到管理控制台。 从左侧菜单中选择 User Federation. 从Add Provider下拉列表中，选择sssd将打开sssd配置页面。 点击Save。 现在，您可以使用FreeIPA/IdM凭据对Keycloak进行身份验证。 14.6. 定制供应商 Keycloak确实有一个用于用户存储联合的SPI，您可以使用它来编写自己的自定义提供程序。 您可以在我们的服务器开发人员指南中找到相关文档。 15. 审计和事件 Keycloak提供丰富的审计功能。 每个登录操作都可以记录并存储在数据库中，并在管理控制台中查看。 还可以记录和审查所有管理操作。 还有一个监听器SPI，插件可以监听这些事件并执行某些操作。 内置侦听器包括简单的日志文件以及在事件发生时发送电子邮件的功能。 15.1. 登录活动 登录事件发生在用户成功登录，有人输入错误密码或用户帐户更新时。 可以记录和查看发生在用户身上的每个事件。 默认情况下，管理控制台中不会存储或查看任何事件。 只有错误事件记录到控制台和服务器的日志文件中。 要开始持久化，您需要启用存储。 转到Events左侧菜单项并选择Config选项卡。 事件配置 要开始存储事件，您需要在Login Events Settings下将Save Events开关打开。 Save Events(保存事件) Saved Types字段允许您指定要在事件存储中存储的事件类型。 Clear events按钮允许您删除数据库中的所有事件。 Expiration字段允许您指定要保存事件的时间。 一旦您启用了登录事件的存储并决定了您的设置，请不要忘记单击本页底部的Save按钮。 要查看事件，请转到Login Events选项卡。 Login Events(登录事件) 如您所见，存储了大量信息，如果您要存储每个事件，则每个登录操作都会存储大量事件。 此页面上的Filter按钮允许您过滤您实际感兴趣的事件。 Login Event Filter(登录事件过滤器) 在此屏幕截图中，我们仅过滤了Login事件。 单击Update按钮可运行过滤器。 15.1.1. 事件类型 登录事件： Login - 用户已登录。 Register - 用户已注册。 Logout - 用户已注销。 Code to Token - 应用程序/客户端已交换令牌代码。 Refresh Token - 应用程序/客户端刷新了令牌。 帐户事件： Social Link - 帐户已与社交提供商相关联。 Remove Social Link - 已从帐户中删除社交提供程序。 Update Email - 帐户的电子邮件地址已更改。 Update Profile - 帐户的个人资料已更改。 Send Password Reset - 已发送密码重置电子邮件。 Update Password - 帐户的密码已更改。 Update TOTP - 帐户的TOTP设置已更改。 Remove TOTP - TOTP已从帐户中删除。 Send Verify Email - 已发送电子邮件验证电子邮件。 Verify Email - 帐户的电子邮件地址已经过验证。 对于所有事件，都存在相应的错误事件。 15.1.2. 事件监听器 事件侦听器侦听事件并基于该事件执行操作。 Keycloak附带了两个内置监听器：Logging Event Listener 和 Email Event Listener。 每当发生错误事件时，Logging Event Listener都会写入日志文件，并且默认情况下处于启用状态。 这是一个示例日志消息： 11:36:09,965 WARN [org.keycloak.events] (default task-51) type=LOGIN_ERROR, realmId=master, clientId=myapp, userId=19aeb848-96fc-44f6-b0a3-59a17570d374, ipAddress=127.0.0.1, error=invalid_user_credentials, auth_method=openid-connect, auth_type=code, redirect_uri=http://localhost:8180/myapp, code_id=b669da14-cdbb-41d0-b055-0810a0334607, username=admin 如果您想使用像Fail2Ban这样的工具来检测是否存在试图猜测用户密码的黑客机器人，则此日志记录非常有用。 您可以解析日志文件中的LOGIN_ERROR并提出IP地址。 然后将此信息提供给Fail2Ban，以便它可以帮助防止攻击。 发生事件时，电子邮件事件监听器会向用户的帐户发送电子邮件。 电子邮件事件监听器目前仅支持以下事件： Login Error(登录错误) Update Password(更新密码) Update TOTP(更新TOTP) Remove TOTP(删除TOTP) 要启用电子邮件侦听器，请转到Config选项卡，然后单击Event Listeners字段。 这将显示一个下拉列表框，您可以在其中选择电子邮件。 您可以通过编辑分发附带的standalone.xml，standalone-ha.xml或domain.xml来排除一个或多个事件，例如： 有关standalone.xml，standalone-ha.xml或`domain的详细信息，请参阅服务器安装和配置指南。 15.2. 管理事件 可以记录管理员在管理控制台中执行的任何操作以进行审计。 管理控制台通过调用Keycloak REST接口来执行管理功能。 Keycloak审核这些REST调用。 然后，可以在管理控制台中查看生成的事件。 要启用管理员操作的审核，请转到Events左侧菜单项并选择Config选项卡。 Event Configuration(事件配置) 在Admin Events Settings部分中，打开Save Events开关。 Admin Event Configuration(管理事件配置) Include Representation开关将包含通过管理REST API发送的任何JSON文档。 这使您可以准确查看管理员已完成的操作，但可以导致存储在数据库中的大量信息。 Clear admin events按钮允许您清除存储的当前信息。 要查看管理事件，请转到Admin Events选项卡。 Admin Events(管理事) 如果Details列有一个Representation框，你可以点击它来查看随该操作发送的JSON。 Admin Representation(管理员代表) 您还可以通过单击Filter按钮来过滤您感兴趣的事件。 Admin Event Filter(管理事件筛选器) 16. 导出和导入 Keycloak具有导出和导入整个数据库的能力。 如果要将整个Keycloak数据库从一个环境迁移到另一个环境或迁移到其他数据库（例如从MySQL到Oracle），这可能特别有用。 导出和导入在服务器启动时触发，其参数通过Java系统属性传递。 需要注意的是，由于导入和导出是在服务器启动时发生的，因此在发生这种情况时，不应对服务器或数据库执行任何其他操作。 您可以将数据库导出/导入到： 本地文件系统上的目录 文件系统上的单个JSON文件 使用目录策略导入时，请注意文件需要遵循下面指定的命名约定。 如果要导入先前导出的文件，则文件已遵循此约定。 -realm.json，例如名为\"acme-roadrunner-affairs\"的\"acme-roadrunner-affairs-realm.json\" -users-.json，例如\"acme-roadrunner-affairs-users-0.json\"，用于名为\"acme-roadrunner-affairs\"的域的第一个用户文件 如果导出到目录，还可以指定将存储在每个JSON文件中的用户数。 如果您的数据库中有大量用户（500或更多），强烈建议导出到目录而不是单个文件。 导出到单个文件可能会导致非常大的文件。 此外，目录提供程序正在为每个\"page\"（具有用户的文件）使用单独的事务，这会带来更好的性能。 每个文件（和事务）的默认用户数为50，这表明我们的性能最佳，但您可以覆盖（见下文）。 导出到单个文件每个导出使用一个事务，每个导入使用一个事务，这导致大量用户的性能不佳。 要导出到未加密的目录，您可以使用： bin/standalone.sh -Dkeycloak.migration.action=export -Dkeycloak.migration.provider=dir -Dkeycloak.migration.dir= 同样，对于import，只需使用-Dkeycloak.migration.action=import而不是export。 要导出到单个JSON文件，您可以使用： bin/standalone.sh -Dkeycloak.migration.action=export -Dkeycloak.migration.provider=singleFile -Dkeycloak.migration.file= 以下是导入示例： bin/standalone.sh -Dkeycloak.migration.action=import -Dkeycloak.migration.provider=singleFile -Dkeycloak.migration.file= -Dkeycloak.migration.strategy=OVERWRITE_EXISTING 其他可用选项包括： -Dkeycloak.migration.realmName 如果要仅导出一个指定的域而不是全部，则使用此属性。 如果未指定，则将导出所有领域。 -Dkeycloak.migration.usersExportStrategy 此属性用于指定用户的导出位置。 可能的值有：DIFFERENT_FILES - 根据每个文件的最大用户数将用户导出到不同的文件中。 这是默认值. SKIP - 将完全跳过用户导出. REALM_FILE - 所有用户将使用领域设置导出到同一文件。 （结果将是一个文件，如\"foo-realm.json\"，包含领域数据和用户。）SAME_FILE - 所有用户将被导出到同一文件但不同于领域文件。 （结果将是带有领域数据的\"foo-realm.json\"文件和带有用户的\"foo-users.json\"。） -Dkeycloak.migration.usersPerFile 此属性用于指定每个文件的用户数（以及每个数据库事务）。 它默认为50。 仅当usersExportStrategy为DIFFERENT_FILES时才使用它 -Dkeycloak.migration.strategy 导入期间使用此属性。 如果要导入数据的数据库中已存在具有相同名称的域，则可以使用它指定如何继续。 可能的值有：IGNORE_EXISTING - 如果此名称的域已经存在，则忽略导入. OVERWRITE_EXISTING - 删除现有域并使用JSON文件中的新数据再次导入它。 如果要将一个环境完全迁移到另一个环境并确保新环境包含与旧环境相同的数据，则可以指定此环境。 导入以前未导出的域文件时，可以使用选项keycloak.import。 如果需要导入多个域文件，则可以指定逗号分隔的文件名列表。 这比以前的情况更合适，因为只有在初始化主域之后才会发生这种情况。 例子： -Dkeycloak.import=/tmp/realm1.json -Dkeycloak.import=/tmp/realm1.json,/tmp/realm2.json 16.1. 管理控制台导出/导入 可以从管理控制台执行大多数资源的导入，也可以导出大多数资源。 不支持导出用户。 注意：包含机密或私人信息的属性将在导出文件中屏蔽。 因此，通过管理控制台获取的导出文件不适用于服务器之间的备份或数据传输。 只有启动时导出才适合。 在\"startup\"导出期间创建的文件也可用于从管理UI导入。 这样，您可以从一个领域导出并导入到另一个领域。 或者，您可以从一台服务器导出并导入到另一台服务器。 注意：管理控制台导出/导入每个文件只允许一个域。 管理控制台导入允许您在选择时\"overwrite\"资源。 请谨慎使用此功能，尤其是在生产系统上。 从管理控制台导出操作导出.json文件通常不适合数据导入，因为它们包含无效的机密值。 管理控制台导出允许您导出客户端，组和角色。 如果您的领域中存在大量这些资产，则操作可能需要一些时间才能完成。 在此期间，服务器可能无法响应用户请求。 请谨慎使用此功能，尤其是在生产系统上。 17. 用户帐户服务 Keycloak有一个内置的用户帐户服务，每个用户都可以访问。 此服务允许用户管理其帐户，更改其凭据，更新其个人资料以及查看其登录会话。 此服务的URL是/auth/realms/{realm-name}/account。 Account Service(帐户服务) 初始页面是用户的配置文件，即Account左侧菜单项。 这是他们指定自己的基本数据的地方。 可以扩展此屏幕以允许用户管理其他属性。 有关详细信息，请参阅服务器开发人员指南。 Password左侧菜单项允许用户更改其密码。 Password Update(密码更新) Authenticator菜单项允许用户根据需要设置OTP。 这只会在OTP是您的领域的有效身份验证机制时显示。 用户可以获得安装FreeOTP或Google身份验证器他们的移动设备上的OTP生成器。 您在屏幕截图中看到的QR码可以扫描到FreeOTP或Google Authenticator移动应用程序中，以便进行简单的设置。 OTP Authenticator(OTP身份验证器) Federated Identity菜单项允许用户将他们的帐户与身份代理链接（这通常用于链接 社交提供者帐户在一起）。 这将显示您为领域配置的外部身份提供程序列表。 Federated Identity(联合身份) Sessions菜单项允许用户查看和管理登录和从哪里登录的设备。 他们也可以从这个屏幕执行这些会话的注销。 Sessions(会话) Applications菜单项向用户显示他们可以访问的应用程序。 Applications(应用) 17.1. 主题化 与Keycloak中的所有UI一样，用户帐户服务完全可以主题化和国际化。 有关详细信息，请参阅服务器开发人员指南。 18. 威胁模型缓解 本章讨论了任何身份验证服务器可能存在的安全漏洞以及Keycloak如何减轻这些漏洞。 在IETF提出的OAuth 2.0威胁模型文档中可以找到一个很好的潜在漏洞清单以及安全实施应该采取哪些措施来缓解这些漏洞。 这里讨论了许多漏洞。 18.1. 主机名 Keycloak使用公共主机名进行许多操作。 例如，在密码重置电子邮件中发送的令牌颁发者字段和URL中。 默认情况下，主机名基于请求标头，并且不会检查以确保此主机名有效。 如果您未在Keycloak前面使用负载均衡器或代理来阻止无效的主机标头，则必须明确配置应接受的主机名。 Hostname SPI提供了一种为请求配置主机名的方法。 开箱即用有两个提供商。 这些是请求和修复。 如果内置提供程序不提供所需的功能，也可以开发自己的提供程序。 18.1.1. 请求提供者 这是默认的主机名提供程序，并使用请求标头来确定主机名。 由于它使用请求中的标头，因此将其与代理或拒绝无效主机名的过滤器结合使用非常重要。 提供有关如何为代理配置有效主机名的说明超出了本文档的范围。 要在过滤器中对其进行配置，您需要编辑standalone.xml以为服务器设置允许的别名。 以下示例仅允许对auth.example.com的请求： ... 从默认配置中进行的更改是添加属性default-host=\"ignore\"并更新属性alias。 default-host=\"ignore\"防止处理未知主机，而alias用于列出接受的主机。 以下是使用CLI命令的等效配置： /subsystem=undertow/server=default-server:write-attribute(name=default-host,value=ignore) /subsystem=undertow/server=default-server/host=default-host:write-attribute(name=alias,value=[auth.example.com] :reload 18.1.2. 固定提供商 固定提供程序可以配置固定主机名。 与请求提供程序不同，固定提供程序允许内部应用程序在备用URL（例如内部IP地址）上调用Keycloak。 还可以通过管理控制台中域的配置覆盖特定域的主机名。 这是在生产中使用的推荐提供商。 要更改为固定提供程序并配置主机名编辑standalone.xml。 以下示例显示了主机名设置为auth.example.com的固定提供程序： fixed 以下是使用CLI命令的等效配置： /subsystem=keycloak-server/spi=hostname:write-attribute(name=default-provider, value=\"fixed\") /subsystem=keycloak-server/spi=hostname/provider=fixed:write-attribute(name=properties.hostname,value=\"auth.example.com\") 默认情况下，从请求中接收httpPort和httpsPort。 只要正确配置了任何代理，就不必更改它。 如有必要，可以通过在固定提供程序上设置httpPort和httpsPort属性来配置固定端口。 在大多数情况下，应该正确设置方案。 如果反向代理无法正确设置X-Forwarded-For标头，或者如果有内部应用程序使用非https来调用Keycloak，则可能不是这样。 在这种情况下，可以将alwaysHttps设置为true。 18.1.3. 定制提供商 要开发自定义主机名提供程序，您需要实现org.keycloak.urls.HostnameProviderFactory和orl.keycloak.urls.HostnameProvider。 按照服务器开发人员指南中“服务提供商接口”部分中的说明，了解有关如何开发自定义提供程序的更多信息。 18.2. 管理员端点和控制台 默认情况下，Keycloak管理REST API和Web控制台在与非管理员用法相同的端口上公开。 如果您在Internet上公开Keycloak，我们建议您不要在Internet上公开管理端点。 这可以直接在Keycloak中实现，也可以使用Apache或nginx等代理实现。 有关代理选项，请按照代理的文档进行操作。 您需要控制对/auth/admin的任何请求的访问。 要在Keycloak中直接实现这一点，有一些选择。 本文档包含两个选项，IP限制和单独端口。 18.2.1. IP限制 可以将对/auth/admin的访问限制为仅限于特定的IP地址。 以下示例将对/auth/admin的访问限制为10.0.0.1到10.0.0.255范围内的IP地址。 ... ... ... ip-access-control(acl={'10.0.0.0/24 allow'})\"/> ... 使用CLI命令进行等效配置： /subsystem=undertow/configuration=filter/expression-filter=ipAccess:add(,expression=\"path-prefix[/auth/admin] -> ip-access-control(acl={'10.0.0.0/24 allow'})\") /subsystem=undertow/server=default-server/host=default-host/filter-ref=ipAccess:add() 对于IP限制，如果您使用代理，请务必正确配置以确保Keycloak接收客户端IP地址而不是代理IP地址 18.2.2. 端口限制 可以将/auth/admin暴露给未在Internet上公开的其他端口。 以下示例在端口8444上公开/auth/admin，而不允许使用默认端口8443进行访问。 ... ... ... response-code(403)\"/> ... ... ... ... 使用CLI命令进行等效配置： /socket-binding-group=standard-sockets/socket-binding=https-admin/:add(port=8444) /subsystem=undertow/server=default-server/https-listener=https-admin:add(socket-binding=https-admin, security-realm=ApplicationRealm, enable-http2=true) /subsystem=undertow/configuration=filter/expression-filter=portAccess:add(,expression=\"path-prefix('/auth/admin') and not equals(%p, 8444) -> response-code(403)\") /subsystem=undertow/server=default-server/host=default-host/filter-ref=portAccess:add() 18.3. 密码猜测：暴力攻击 当攻击者试图猜测用户的密码时，会发生暴力攻击。 Keycloak具有一些有限的强力检测功能。 如果启用，则在达到登录失败阈值时将暂时禁用用户帐户。 要启用此功能，请转到Realm Settings左侧菜单项，单击Security Defenses选项卡，然后转到Brute Force Detection子选项卡。 Brute Force Detection(蛮力检测) 蛮力检测有2种不同的配置; 永久锁定和临时锁定。 永久锁定将在检测到攻击后禁用用户的帐户; 该帐户将被禁用，直到管理员将其重新设置为止。 临时锁定将在检测到攻击后的一段时间内禁用用户的帐户; 帐户被禁用的时间段越长，攻击持续的时间越长。 常用参数 Max Login Failures(最大登录失败) 允许的最大登录失败次数。 默认值为30。 Quick Login Check Milli Seconds(快速登录检查毫秒) 登录尝试之间所需的最短时间。 默认值为1000。 最低快速登录等待 如果登录尝试比快速登录检查毫秒更快，则用户将被暂时禁用的最短时间。 默认为1分钟。 临时锁定参数 Wait Increment(等待增量) 每次达到Max Login Failures(最大登录失败)后暂时禁用用户的时间量。 默认为1分钟。 Max Wait(最长等待) 用户暂时禁用的最长时间。 默认为15分钟。 Failure Reset Time(失败重置时间) 重置故障计数的时间; 计时器从上次失败的登录中运行。 默认为12小时。 永久锁定算法 成功登录后 重置count 登录失败 增加 count 如果count大于Max Login Failures(最大登录失败) 永久禁用用户 否则，如果此故障与上次故障之间的时间间隔小于快速登录检查毫秒 暂时禁用用户最小快速登录等待 当用户被禁用时，他们无法登录，直到管理员启用该用户; 启用帐户会重置count。 临时锁定算法 成功登录后 重置 count 登录失败 如果此故障与上次故障之间的时间间隔大于故障重置时间 重置 count 增加 count 使用Wait Increment (count / Max Login Failures*)计算wait。 除法是整数除法，因此总是向下舍入为整数 如果wait等于0，则此故障与上次故障之间的时间小于 Quick Login Check Milli Seconds 然后将wait设置为 Minimum Quick Login Wait 暂时禁用用户较小的wait和Max Wait秒 暂时禁用用户时登录失败不会增加count。 Keycloak强力检测的缺点是服务器容易受到拒绝服务攻击。 攻击者可以简单地尝试猜测其知道的任何帐户的密码，并且这些帐户将被禁用。 最终，我们将扩展此功能，以在决定是否阻止用户时考虑客户端IP地址。 更好的选择可能是像[Fail2Ban]这样的工具(http://www.fail2ban.org/wiki/index.php/Main_Page)。 您可以将此服务指向Keycloak服务器的日志文件。 Keycloak记录每次登录失败和发生故障的客户端IP地址。 在检测到阻止来自特定IP地址的连接的攻击后，Fail2Ban可用于修改防火墙。 18.3.1. 密码策略 防止密码猜测应该做的另一件事是拥有足够复杂的密码策略，以确保用户选择难以猜测的密码。 有关详细信息，请参阅密码策略一章。 防止密码猜测的最佳方法是将服务器设置为使用一次性密码（OTP）。 18.4. 点击劫持 通过点击劫持，恶意网站将目标网站加载到覆盖在一组虚拟按钮顶部的透明iFrame中，这些虚拟按钮经过精心构造，可直接放置在目标站点上的重要按钮下。 当用户单击可见按钮时，他们实际上是在隐藏页面上单击按钮（例如“登录”按钮）。 攻击者可以窃取用户的身份验证凭据并访问其资源。 默认情况下，Keycloak的每个响应都会设置一些特定的浏览器标头，以防止这种情况发生。 具体来说，它设置X-FRAME_OPTIONS 和 Content-Security-Policy。 你应该看一下这两个标题的定义，因为你可以控制很多细粒度的浏览器访问。 在管理控制台中，您可以指定这些标头将具有的值。 转到Realm Settings左侧菜单项，然后单击Security Defenses选项卡，确保您位于Headers子选项卡上。 默认情况下，Keycloak仅为iframe设置同源(same-origin)政策。 18.5. SSL/HTTPS要求 如果您没有使用SSL/HTTPS进行Keycloak auth服务器与它所保护的客户端之间的所有通信，那么在中间攻击中您将非常容易受到攻击。 OAuth 2.0/OpenID Connect使用访问令牌来提高安全性。 如果没有SSL/HTTPS，攻击者可以嗅探您的网络并获取访问令牌。 一旦他们拥有访问令牌，他们就可以执行令牌已获得权限的任何操作。 Keycloak有SSL / HTTPS的三种模式。 SSL可能很难设置，因此开箱即用，Keycloak允许通过私有IP地址（如localhost，192.168.x.x和其他私有IP地址）进行非HTTPS通信。 在生产中，您应该确保SSL已全面启用并且是必需的。 在适配器/客户端，Keycloak允许您关闭SSL信任管理器。 信任管理器确保客户端正在与之交谈。 它根据服务器的证书检查DNS域名。 在生产中，您应确保将每个客户端适配器配置为使用信任库。 否则你在中间攻击中容易受到DNS人员的攻击。 18.6. CSRF 攻击 跨站点请求伪造（CSRF）是基于Web的攻击，其中HTTP请求从网站信任或已经过身份验证的用户（例如，通过HTTP重定向或HTML表单）传输。 任何使用基于cookie的身份验证的站点都容易受到这些类型的攻击。 通过将状态cookie与发布的表单或查询参数进行匹配来减轻这些攻击。 OAuth 2.0登录规范要求使用状态cookie并与传输的状态参数进行匹配。 Keycloak完全实现了规范的这一部分，因此所有登录都受到保护。 Keycloak管理控制台是一个纯JavaScript / HTML5应用程序，可以对后端Keycloak管理REST API进行REST调用。 这些调用都需要承载令牌认证，并通过JavaScript Ajax调用进行。 CSRF不适用于此处。 管理REST API也可以配置为验证CORS源。 Keycloak中唯一真正落入CSRF的部分是用户帐户管理页面。 要缓解此Keycloak设置状态cookie，并将此状态cookie的值嵌入隐藏表单字段或操作链接中的查询参数。 将针对状态cookie检查此查询或表单参数，以验证用户是否进行了调用。 18.7. 非特定的重定向URI 对于授权代码流程，如果您注册过于笼统的重定向URI，那么就有可能 对于流氓客户端冒充具有更广泛访问范围的不同客户端。 例如，如果两个客户端位于同一域下，则可能发生这种情况。 因此，最好使注册的重定向URI尽可能具体。 18.8. 受损的访问和刷新令牌 您可以采取一些措施来减少访问令牌并刷新令牌被盗。 最重要的是在Keycloak及其客户端和应用程序之间强制执行SSL/HTTPS通信。 这似乎很明显，但由于Keycloak默认情况下没有启用SSL，因此管理员可能没有意识到这是必要的。 您可以采取的另一项措施是减少泄露的访问权限，缩短其生命周期。 您可以在超时页面中指定。 用于访问令牌的短寿命（分钟），以便客户端和应用程序在短时间内刷新其访问令牌。 如果管理员检测到泄漏，他们可以注销所有用户会话以使这些刷新令牌无效或设置撤销策略。 确保刷新令牌永远保持对客户端的私密性并且永远不会传输也是非常重要的。 您还可以通过将这些令牌作为持有者密钥令牌来缓解泄露的访问令牌和刷新令牌。 请参阅OAuth 2.0 Mutual TLS客户端证书绑定访问令牌以了解具体方法。 如果访问令牌或刷新令牌受到威胁，您应该做的第一件事就是转到管理控制台并将一个不在之前的撤销策略推送到所有应用程序。 这将强制执行在该日期之前发布的任何令牌现在无效。 推出新的not-before策略还将确保应用程序将被迫从Keycloak下载新的公钥，因此当您认为领域签名密钥被泄露时，它也适用于该案例。 密钥章节中的更多信息。 如果您认为这些实体中的任何一个完全受到损害，您还可以禁用特定应用程序，客户端和用户。 18.9. 受损的授权码 对于OIDC Auth Code Flow，攻击者很难破解Keycloak授权码。 Keycloak为其授权码生成加密强随机值，因此很难猜测访问令牌。 授权代码只能使用一次才能获得访问令牌。 在管理控制台中，您可以在超时页面上指定授权代码的有效期。 这个值应该非常短，只需几秒钟，并且足够长，以便客户端从代码中获取请求以获取令牌。 18.10. 打开重定向器 攻击者可以使用最终用户授权端点和重定向URI参数将授权服务器滥用为开放重定向器。 开放重定向器是一个端点，使用参数自动将用户代理重定向到参数值指定的位置，而不进行任何验证。 攻击者可以利用用户对授权服务器的信任来发起网络钓鱼攻击。 Keycloak要求所有注册的应用程序和客户端至少注册一个重定向URI模式。 每当客户端要求Keycloak执行重定向（例如登录或注销）时，Keycloak将检查重定向URI与有效注册URI模式列表。 客户端和应用程序注册为特定的URI模式以减轻开放重定向器攻击非常重要。 18.11. 密码数据库受损 Keycloak不会以原始文本存储密码。 它使用PBKDF2算法存储它们的散列。 它实际上使用默认的20,000次散列迭代！ 这是安全社区建议的迭代次数。 这可能会对您的系统产生相当大的性能影响，因为PBKDF2在设计上占用了大量的CPU。 您需要决定保护密码数据库的严肃程度。 18.12. 限制范围 默认情况下，每个新的客户端应用程序都具有无限的角色范围映射。 这意味着为该客户端创建的每个访问令牌都将包含用户拥有的所有权限。 如果客户端遭到入侵并且访问令牌泄露，则用户有权访问的每个系统现在也会受到损害。 强烈建议您使用每个客户端的范围菜单限制访问令牌的角色。 或者，您可以在客户端作用域级别设置角色范围映射，并使用客户端范围菜单将客户端范围分配给客户端。 18.13. 限制令牌受众 在服务之间的信任级别较低的环境中，限制令牌上的受众是一种好习惯。 其背后的动机在OAuth2威胁模型文档中有所描述，更多详细信息请参见受众支持部分。 18.14. SQL注入攻击 在这个时间点，没有在任何Keycloak SQL注入漏洞的知识。 19. 管理员 命令行 在前面的章节中，我们介绍了如何使用Keycloak管理控制台执行管理任务。 您还可以使用Admin CLI命令行工具从命令行界面（CLI）执行这些任务。 19.1. 安装Admin CLI Admin CLI打包在Keycloak Server发行版中。 您可以在bin目录中找到执行脚本。 Linux脚本称为kcadm.sh，Windows脚本称为kcadm.bat。 您可以将Keycloak服务器目录添加到PATH以从文件系统上的任何位置使用客户端。 例如，在： Linux: $ export PATH=$PATH:$KEYCLOAK_HOME/bin $ kcadm.sh Windows: c:\\> set PATH=%PATH%;%KEYCLOAK_HOME%\\bin c:\\> kcadm 我们假设KEYCLOAK_HOME环境（env）变量设置为您解压缩Keycloak Server分发的路径。 为避免重复，本文档的其余部分仅在CLI中的差异超出kcadm命令名称的地方提供Windows示例。 19.2. 使用Admin CLI Admin CLI通过向Admin REST端点发出HTTP请求来工作。 对它们的访问受到保护并需要身份验证。 有关特定端点的JSON属性的详细信息，请参阅Admin REST API文档。 通过提供凭据（即登录）启动经过身份验证的会话。您已准备好执行创建，读取，更新和删除（CRUD）操作。 例如，在: Linux: $ kcadm.sh config credentials --server http://localhost:8080/auth --realm demo --user admin --client admin $ kcadm.sh create realms -s realm=demorealm -s enabled=true -o $ CID=$(kcadm.sh create clients -r demorealm -s clientId=my_client -s 'redirectUris=[\"http://localhost:8980/myapp/*\"]' -i) $ kcadm.sh get clients/$CID/installation/providers/keycloak-oidc-keycloak-json Windows: c:\\> kcadm config credentials --server http://localhost:8080/auth --realm demo --user admin --client admin c:\\> kcadm create realms -s realm=demorealm -s enabled=true -o c:\\> kcadm create clients -r demorealm -s clientId=my_client -s \"redirectUris=[\\\"http://localhost:8980/myapp/*\\\"]\" -i > clientid.txt c:\\> set /p CID= kcadm get clients/%CID%/installation/providers/keycloak-oidc-keycloak-json 在生产环境中，您必须使用 https: 访问Keycloak，以避免将令牌暴露给网络嗅探器。 如果服务器的证书不是由Java的默认证书信任库中包含的受信任证书颁发机构（CA）之一颁发的，请准备truststore.jks文件并指示Admin CLI使用它。 例如，在: Linux: $ kcadm.sh config truststore --trustpass $PASSWORD ~/.keycloak/truststore.jks Windows: c:\\> kcadm config truststore --trustpass %PASSWORD% %HOMEPATH%\\.keycloak\\truststore.jks 19.3. 认证 使用Admin CLI登录时，指定服务器端点URL和域，然后指定用户名。 另一种选择是仅指定clientId，这导致使用特殊的\"(service account)服务帐户\"。 使用用户名登录时，必须使用指定用户的密码。 使用clientId登录时，只需要客户端密码，而不是用户密码。 您也可以使用Signed JWT而不是客户端密钥。 确保用于会话的帐户具有调用Admin REST API操作的适当权限。 例如，realm-management客户端的realm-admin角色允许用户管理定义用户的领域。 验证有两种主要机制。 一种机制使用kcadm config credentials来启动经过身份验证的会话。 $ kcadm.sh config credentials --server http://localhost:8080/auth --realm master --user admin --password admin 此方法通过保存获取的访问令牌和关联的刷新令牌来维护kcadm命令调用之间的经过身份验证的会话。 它还可以在私有配置文件中维护其他秘密。 有关配置文件的更多信息，请参见下一章。 第二种方法仅在该调用期间验证每个命令调用。 这种方法增加了服务器上的负载以及通过往返获取令牌所花费的时间。 这种方法的好处是不需要在调用之间保存任何令牌，这意味着什么都没有保存到磁盘。 指定--no-config参数时使用此模式。 例如，在执行操作时，我们指定身份验证所需的所有信息。 $ kcadm.sh get realms --no-config --server http://localhost:8080/auth --realm master --user admin --password admin 有关使用Admin CLI的更多信息，请运行kcadm.sh help命令。 运行kcadm.sh config credentials --help命令以获取有关启动经过身份验证的会话的更多信息。 19.4. 使用其他配置 默认情况下，Admin CLI会自动维护位于用户主目录下的名为kcadm.config的配置文件。 在基于Linux的系统中，完整路径名是$HOME/.keycloak/kcadm.config。 在Windows上，完整路径名是%HOMEPATH%\\.keycloak\\kcadm.config。 您可以使用--config选项指向不同的文件或位置，以便您可以并行维护多个经过身份验证的会话。 最好从单个线程执行绑定到单个配置文件的操作。 确保不要使配置文件对系统上的其他用户可见。 它包含应该保密的访问令牌和秘密。 默认情况下，~/.keycloak 目录及其内容是使用适当的访问限制自动创建的。 如果该目录已存在，则不会更新其权限。 If your unique circumstances require you to avoid storing secrets inside a configuration file, you can do so. It will be less convenient and you will have to make more token requests. To not store secrets, use the --no-config option with all your commands and specify all the authentication information needed by the config credentials command with each kcadminvocation. 19.5. Basic operations and resource URIs The Admin CLI allows you to generically perform CRUD operations against Admin REST API endpoints with additional commands that simplify performing certain tasks. The main usage pattern is listed below, where the create, get, update, and delete commands are mapped to the HTTP verbs POST, GET, PUT, and DELETE, respectively. $ kcadm.sh create ENDPOINT [ARGUMENTS] $ kcadm.sh get ENDPOINT [ARGUMENTS] $ kcadm.sh update ENDPOINT [ARGUMENTS] $ kcadm.sh delete ENDPOINT [ARGUMENTS] ENDPOINT is a target resource URI and can either be absolute (starting with http: or https:) or relative, used to compose an absolute URL of the following format: SERVER_URI/admin/realms/REALM/ENDPOINT For example, if you authenticate against the server http://localhost:8080/auth and realm is master, then using users as ENDPOINT results in the resource URL http://localhost:8080/auth/admin/realms/master/users. If you set ENDPOINT to clients, the effective resource URI would be http://localhost:8080/auth/admin/realms/master/clients. There is a realms endpoint that is treated slightly differently because it is the container for realms. It resolves to: SERVER_URI/admin/realms There is also a serverinfo endpoint, which is treated the same way because it is independent of realms. When you authenticate as a user with realm-admin powers, you might need to perform commands on multiple realms. In that case, specify the -r option to tell explicitly which realm the command should be executed against. Instead of using REALM as specified via the --realm option of kcadm.sh config credentials, the TARGET_REALM is used. SERVER_URI/admin/realms/TARGET_REALM/ENDPOINT For example, $ kcadm.sh config credentials --server http://localhost:8080/auth --realm master --user admin --password admin $ kcadm.sh create users -s username=testuser -s enabled=true -r demorealm In this example, you start a session authenticated as the admin user in the master realm. You then perform a POST call against the resource URL http://localhost:8080/auth/admin/realms/demorealm/users. The create and update commands send a JSON body to the server by default. You can use -f FILENAME to read a premade document from a file. When you can use -f - option, the message body is read from standard input. You can also specify individual attributes and their values as seen in the previous create users example. They are composed into a JSON body and sent to the server. There are several ways to update a resource using the update command. You can first determine the current state of a resource and save it to a file, and then edit that file and send it to the server for updating. For example: $ kcadm.sh get realms/demorealm > demorealm.json $ vi demorealm.json $ kcadm.sh update realms/demorealm -f demorealm.json This method updates the resource on the server with all the attributes in the sent JSON document. Another option is to perform an on-the-fly update using the -s, --set options to set new values. For example: $ kcadm.sh update realms/demorealm -s enabled=false That method only updates the enabled attribute to false. By default, the update command first performs a get and then merges the new attribute values with existing values. This is the preferred behavior. In some cases, the endpoint may support the PUT command but not the GET command. You can use the -n option to perform a \"no-merge\" update, which performs a PUT command without first running a GETcommand. 19.6. Realm operations Creating a new realm Use the create command on the realms endpoint to create a new enabled realm, and set the attributes to realm and enabled. $ kcadm.sh create realms -s realm=demorealm -s enabled=true A realm is not enabled by default. By enabling it, you can use a realm immediately for authentication. A description for a new object can also be in a JSON format. $ kcadm.sh create realms -f demorealm.json You can send a JSON document with realm attributes directly from a file or piped to a standard input. For example, on: Linux: $ kcadm.sh create realms -f - Windows: c:\\> echo { \"realm\": \"demorealm\", \"enabled\": true } | kcadm create realms -f - Listing existing realms The following command returns a list of all realms. $ kcadm.sh get realms A list of realms is additionally filtered on the server to return only realms a user can see. Returning the entire realm description often provides too much information. Most users are interested only in a subset of attributes, such as realm name and whether the realm is enabled. You can specify which attributes to return by using the --fields option. $ kcadm.sh get realms --fields realm,enabled You can also display the result as comma separated values. $ kcadm.sh get realms --fields realm --format csv --noquotes Getting a specific realm You append a realm name to a collection URI to get an individual realm. $ kcadm.sh get realms/master Updating a realm Use the -s option to set new values for the attributes when you want to change only some of the realm’s attributes. For example: $ kcadm.sh update realms/demorealm -s enabled=false If you want to set all writable attributes with new values, run a get command, edit the current values in the JSON file, and resubmit. For example: $ kcadm.sh get realms/demorealm > demorealm.json $ vi demorealm.json $ kcadm.sh update realms/demorealm -f demorealm.json Deleting a realm Run the following command to delete a realm. $ kcadm.sh delete realms/demorealm Turning on all login page options for the realm Set the attributes controlling specific capabilities to true. For example: $ kcadm.sh update realms/demorealm -s registrationAllowed=true -s registrationEmailAsUsername=true -s rememberMe=true -s verifyEmail=true -s resetPasswordAllowed=true -s editUsernameAllowed=true Listing the realm keys Use the get operation on the keys endpoint of the target realm. $ kcadm.sh get keys -r demorealm Generating new realm keys Get the ID of the target realm before adding a new RSA-generated key pair. For example: $ kcadm.sh get realms/demorealm --fields id --format csv --noquotes Add a new key provider with a higher priority than the existing providers as revealed by kcadm.sh get keys -r demorealm. For example, on: Linux: $ kcadm.sh create components -r demorealm -s name=rsa-generated -s providerId=rsa-generated -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s 'config.priority=[\"101\"]' -s 'config.enabled=[\"true\"]' -s 'config.active=[\"true\"]' -s 'config.keySize=[\"2048\"]' Windows: c:\\> kcadm create components -r demorealm -s name=rsa-generated -s providerId=rsa-generated -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s \"config.priority=[\\\"101\\\"]\" -s \"config.enabled=[\\\"true\\\"]\" -s \"config.active=[\\\"true\\\"]\" -s \"config.keySize=[\\\"2048\\\"]\" Set the parentId attribute to the value of the target realm’s ID. The newly added key should now become the active key as revealed by kcadm.sh get keys -r demorealm. Adding new realm keys from a Java Key Store file Add a new key provider to add a new key pair already prepared as a JKS file on the server. For example, on: Linux: $ kcadm.sh create components -r demorealm -s name=java-keystore -s providerId=java-keystore -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s 'config.priority=[\"101\"]' -s 'config.enabled=[\"true\"]' -s 'config.active=[\"true\"]' -s 'config.keystore=[\"/opt/keycloak/keystore.jks\"]' -s 'config.keystorePassword=[\"secret\"]' -s 'config.keyPassword=[\"secret\"]' -s 'config.alias=[\"localhost\"]' Windows: c:\\> kcadm create components -r demorealm -s name=java-keystore -s providerId=java-keystore -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s \"config.priority=[\\\"101\\\"]\" -s \"config.enabled=[\\\"true\\\"]\" -s \"config.active=[\\\"true\\\"]\" -s \"config.keystore=[\\\"/opt/keycloak/keystore.jks\\\"]\" -s \"config.keystorePassword=[\\\"secret\\\"]\" -s \"config.keyPassword=[\\\"secret\\\"]\" -s \"config.alias=[\\\"localhost\\\"]\" Make sure to change the attribute values for keystore, keystorePassword, keyPassword, and alias to match your specific keystore. Set the parentId attribute to the value of the target realm’s ID. Making the key passive or disabling the key Identify the key you want to make passive $ kcadm.sh get keys -r demorealm Use the key’s providerId attribute to construct an endpoint URI, such as components/PROVIDER_ID. Perform an update. For example, on: Linux: $ kcadm.sh update components/PROVIDER_ID -r demorealm -s 'config.active=[\"false\"]' Windows: c:\\> kcadm update components/PROVIDER_ID -r demorealm -s \"config.active=[\\\"false\\\"]\" You can update other key attributes. Set a new enabled value to disable the key, for example, config.enabled=[\"false\"]. Set a new priority value to change the key’s priority, for example, config.priority=[\"110\"]. Deleting an old key Make sure the key you are deleting has been passive and disabled to prevent any existing tokens held by applications and users from abruptly failing to work. Identify the key you want to make passive. $ kcadm.sh get keys -r demorealm Use the providerId of that key to perform a delete. $ kcadm.sh delete components/PROVIDER_ID -r demorealm Configuring event logging for a realm Use the update command on the events/config endpoint. The eventsListeners attribute contains a list of EventListenerProviderFactory IDs that specify all event listeners receiving events. Separately, there are attributes that control a built-in event storage, which allows querying past events via the Admin REST API. There is separate control over logging of service calls (eventsEnabled) and auditing events triggered during Admin Console or Admin REST API (adminEventsEnabled). You may want to set up expiry of old events so that your database does not fill up; eventsExpiration is set to time-to-live expressed in seconds. Here is an example of setting up a built-in event listener that receives all the events and logs them through jboss-logging. (Using a logger called org.keycloak.events, error events are logged as WARN, and others are logged as DEBUG.) For example, on: Linux: $ kcadm.sh update events/config -r demorealm -s 'eventsListeners=[\"jboss-logging\"]' Windows: c:\\> kcadm update events/config -r demorealm -s \"eventsListeners=[\\\"jboss-logging\\\"]\" Here is an example of turning on storage of all available ERROR events—not including auditing events—for 2 days so they can be retrieved via Admin REST. For example, on: Linux: $ kcadm.sh update events/config -r demorealm -s eventsEnabled=true -s 'enabledEventTypes=[\"LOGIN_ERROR\",\"REGISTER_ERROR\",\"LOGOUT_ERROR\",\"CODE_TO_TOKEN_ERROR\",\"CLIENT_LOGIN_ERROR\",\"FEDERATED_IDENTITY_LINK_ERROR\",\"REMOVE_FEDERATED_IDENTITY_ERROR\",\"UPDATE_EMAIL_ERROR\",\"UPDATE_PROFILE_ERROR\",\"UPDATE_PASSWORD_ERROR\",\"UPDATE_TOTP_ERROR\",\"VERIFY_EMAIL_ERROR\",\"REMOVE_TOTP_ERROR\",\"SEND_VERIFY_EMAIL_ERROR\",\"SEND_RESET_PASSWORD_ERROR\",\"SEND_IDENTITY_PROVIDER_LINK_ERROR\",\"RESET_PASSWORD_ERROR\",\"IDENTITY_PROVIDER_FIRST_LOGIN_ERROR\",\"IDENTITY_PROVIDER_POST_LOGIN_ERROR\",\"CUSTOM_REQUIRED_ACTION_ERROR\",\"EXECUTE_ACTIONS_ERROR\",\"CLIENT_REGISTER_ERROR\",\"CLIENT_UPDATE_ERROR\",\"CLIENT_DELETE_ERROR\"]' -s eventsExpiration=172800 Windows: c:\\> kcadm update events/config -r demorealm -s eventsEnabled=true -s \"enabledEventTypes=[\\\"LOGIN_ERROR\\\",\\\"REGISTER_ERROR\\\",\\\"LOGOUT_ERROR\\\",\\\"CODE_TO_TOKEN_ERROR\\\",\\\"CLIENT_LOGIN_ERROR\\\",\\\"FEDERATED_IDENTITY_LINK_ERROR\\\",\\\"REMOVE_FEDERATED_IDENTITY_ERROR\\\",\\\"UPDATE_EMAIL_ERROR\\\",\\\"UPDATE_PROFILE_ERROR\\\",\\\"UPDATE_PASSWORD_ERROR\\\",\\\"UPDATE_TOTP_ERROR\\\",\\\"VERIFY_EMAIL_ERROR\\\",\\\"REMOVE_TOTP_ERROR\\\",\\\"SEND_VERIFY_EMAIL_ERROR\\\",\\\"SEND_RESET_PASSWORD_ERROR\\\",\\\"SEND_IDENTITY_PROVIDER_LINK_ERROR\\\",\\\"RESET_PASSWORD_ERROR\\\",\\\"IDENTITY_PROVIDER_FIRST_LOGIN_ERROR\\\",\\\"IDENTITY_PROVIDER_POST_LOGIN_ERROR\\\",\\\"CUSTOM_REQUIRED_ACTION_ERROR\\\",\\\"EXECUTE_ACTIONS_ERROR\\\",\\\"CLIENT_REGISTER_ERROR\\\",\\\"CLIENT_UPDATE_ERROR\\\",\\\"CLIENT_DELETE_ERROR\\\"]\" -s eventsExpiration=172800 Here is an example of how to reset stored event types to all available event types; setting to empty list is the same as enumerating all. $ kcadm.sh update events/config -r demorealm -s enabledEventTypes=[] Here is an example of how to enable storage of auditing events. $ kcadm.sh update events/config -r demorealm -s adminEventsEnabled=true -s adminEventsDetailsEnabled=true Here is an example of how to get the last 100 events; they are ordered from newest to oldest. $ kcadm.sh get events --offset 0 --limit 100 Here is an example of how to delete all saved events. $ kcadm delete events Flushing the caches Use the create command and one of the following endpoints: clear-realm-cache, clear-user-cache, or clear-keys-cache. Set realm to the same value as the target realm. For example: $ kcadm.sh create clear-realm-cache -r demorealm -s realm=demorealm $ kcadm.sh create clear-user-cache -r demorealm -s realm=demorealm $ kcadm.sh create clear-keys-cache -r demorealm -s realm=demorealm Importing a realm from exported .json file Use the create command on the partialImport endpoint. Set ifResourceExists to one of FAIL, SKIP, OVERWRITE. Use -f to submit the exported realm .json file For example: $ kcadm.sh create partialImport -r demorealm2 -s ifResourceExists=FAIL -o -f demorealm.json If realm does not yet exist, you first have to create it. For example: $ kcadm.sh create realms -s realm=demorealm2 -s enabled=true 19.7. Role operations Creating a realm role Use the roles endpoint to create a realm role. $ kcadm.sh create roles -r demorealm -s name=user -s 'description=Regular user with limited set of permissions' Creating a client role Identify the client first and then use the get command to list available clients when creating a client role. $ kcadm.sh get clients -r demorealm --fields id,clientId Create a new role by using the clientId attribute to construct an endpoint URI, such as clients/ID/roles. For example: $ kcadm.sh create clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles -r demorealm -s name=editor -s 'description=Editor can edit, and publish any article' Listing realm roles Use the get command on the roles endpoint to list existing realm roles. $ kcadm.sh get roles -r demorealm You can also use the get-roles command. $ kcadm.sh get-roles -r demorealm Listing client roles There is a dedicated get-roles command to simplify listing realm and client roles. It is an extension of the get command and behaves the same with additional semantics for listing roles. Use the get-roles command, passing it either the clientId attribute (via the --cclientid option) or id (via the --cidoption) to identify the client to list client roles. For example: $ kcadm.sh get-roles -r demorealm --cclientid realm-management Getting a specific realm role Use the get command and the role name to construct an endpoint URI for a specific realm role: roles/ROLE_NAME, where user is the name of the existing role. For example: $ kcadm.sh get roles/user -r demorealm You can also use the special get-roles command, passing it a role name (via the --rolename option) or ID (via the --roleid option). For example: $ kcadm.sh get-roles -r demorealm --rolename user Getting a specific client role Use a dedicated get-roles command, passing it either the clientId attribute (via the --cclientid option) or ID (via the --cid option) to identify the client, and passing it either the role name (via the --rolename option) or ID (via the --roleid) to identify a specific client role. For example: $ kcadm.sh get-roles -r demorealm --cclientid realm-management --rolename manage-clients Updating a realm role Use the update command with the same endpoint URI that you used to get a specific realm role. For example: $ kcadm.sh update roles/user -r demorealm -s 'description=Role representing a regular user' Updating a client role Use the update command with the same endpoint URI that you used to get a specific client role. For example: $ kcadm.sh update clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles/editor -r demorealm -s 'description=User that can edit, and publish articles' Deleting a realm role Use the delete command with the same endpoint URI that you used to get a specific realm role. For example: $ kcadm.sh delete roles/user -r demorealm Deleting a client role Use the delete command with the same endpoint URI that you used to get a specific client role. For example: $ kcadm.sh delete clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles/editor -r demorealm Listing assigned, available, and effective realm roles for a composite role Use a dedicated get-roles command to list assigned, available, and effective realm roles for a composite role. To list assigned realm roles for the composite role, you can specify the target composite role by either name (via the --rname option) or ID (via the --rid option). For example: $ kcadm.sh get-roles -r demorealm --rname testrole Use the additional --effective option to list effective realm roles. For example: $ kcadm.sh get-roles -r demorealm --rname testrole --effective Use the --available option to list realm roles that can still be added to the composite role. For example: $ kcadm.sh get-roles -r demorealm --rname testrole --available Listing assigned, available, and effective client roles for a composite role Use a dedicated get-roles command to list assigned, available, and effective client roles for a composite role. To list assigned client roles for the composite role, you can specify the target composite role by either name (via the --rname option) or ID (via the --rid option) and client by either the clientId attribute (via the --cclientid option) or ID (via the --cid option). For example: $ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-management Use the additional --effective option to list effective realm roles. For example: $ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-management --effective Use the --available option to list realm roles that can still be added to the target composite role. For example: $ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-management --available Adding realm roles to a composite role There is a dedicated add-roles command that can be used for adding realm roles and client roles. The following example adds the user role to the composite role testrole. $ kcadm.sh add-roles --rname testrole --rolename user -r demorealm Removing realm roles from a composite role There is a dedicated remove-roles command that can be used to remove realm roles and client roles. The following example removes the user role from the target composite role testrole. $ kcadm.sh remove-roles --rname testrole --rolename user -r demorealm Adding client roles to a realm role Use a dedicated add-roles command that can be used for adding realm roles and client roles. The following example adds the roles defined on the client realm-management - create-client role and the view-users role to the testrole composite role. $ kcadm.sh add-roles -r demorealm --rname testrole --cclientid realm-management --rolename create-client --rolename view-users Adding client roles to a client role Determine the ID of the composite client role by using the get-roles command. For example: $ kcadm.sh get-roles -r demorealm --cclientid test-client --rolename operations Assume that there is a client with a clientId attribute of test-client, a client role called support, and another client role called operations, which becomes a composite role, that has an ID of \"fc400897-ef6a-4e8c-872b-1581b7fa8a71\". Use the following example to add another role to the composite role. $ kcadm.sh add-roles -r demorealm --cclientid test-client --rid fc400897-ef6a-4e8c-872b-1581b7fa8a71 --rolename support List the roles of a composite role by using the get-roles --all command. For example: $ kcadm.sh get-roles --rid fc400897-ef6a-4e8c-872b-1581b7fa8a71 --all Removing client roles from a composite role Use a dedicated remove-roles command to remove client roles from a composite role. Use the following example to remove two roles defined on the client realm management - create-client role and the view-users role from the testrole composite role. $ kcadm.sh remove-roles -r demorealm --rname testrole --cclientid realm-management --rolename create-client --rolename view-users Adding client roles to a group Use a dedicated add-roles command that can be used for adding realm roles and client roles. The following example adds the roles defined on the client realm-management - create-client role and the view-users role to the Group group (via the --gname option). The group can alternatively be specified by ID (via the --gidoption). See Group operations for more operations that can be performed to groups. $ kcadm.sh add-roles -r demorealm --gname Group --cclientid realm-management --rolename create-client --rolename view-users Removing client roles from a group Use a dedicated remove-roles command to remove client roles from a group. Use the following example to remove two roles defined on the client realm management - create-client role and the view-users role from the Group group. See Group operations for more operations that can be performed to groups. $ kcadm.sh remove-roles -r demorealm --gname Group --cclientid realm-management --rolename create-client --rolename view-users 19.8. Client operations Creating a client Run the create command on a clients endpoint to create a new client. For example: $ kcadm.sh create clients -r demorealm -s clientId=myapp -s enabled=true Specify a secret if you want to set a secret for adapters to authenticate. For example: $ kcadm.sh create clients -r demorealm -s clientId=myapp -s enabled=true -s clientAuthenticatorType=client-secret -s secret=d0b8122f-8dfb-46b7-b68a-f5cc4e25d000 Listing clients Use the get command on the clients endpoint to list clients. For example: $ kcadm.sh get clients -r demorealm --fields id,clientId This example filters the output to list only the id and clientId attributes. Getting a specific client Use a client’s ID to construct an endpoint URI that targets a specific client, such as clients/ID. For example: $ kcadm.sh get clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm Getting the current secret for a specific client Use a client’s ID to construct an endpoint URI, such as clients/ID/client-secret. For example: $ kcadm.sh get clients/$CID/client-secret Getting an adapter configuration file (keycloak.json) for a specific client Use a client’s ID to construct an endpoint URI that targets a specific client, such as clients/ID/installation/providers/keycloak-oidc-keycloak-json. For example: $ kcadm.sh get clients/c7b8547f-e748-4333-95d0-410b76b3f4a3/installation/providers/keycloak-oidc-keycloak-json -r demorealm Getting a WildFly subsystem adapter configuration for a specific client Use a client’s ID to construct an endpoint URI that targets a specific client, such as clients/ID/installation/providers/keycloak-oidc-jboss-subsystem. For example: $ kcadm.sh get clients/c7b8547f-e748-4333-95d0-410b76b3f4a3/installation/providers/keycloak-oidc-jboss-subsystem -r demorealm Getting a Docker-v2 example configuration for a specific client Use a client’s ID to construct an endpoint URI that targets a specific client, such as clients/ID/installation/providers/docker-v2-compose-yaml. Note that response will be in .zip format. For example: $ kcadm.sh get http://localhost:8080/auth/admin/realms/demorealm/clients/8f271c35-44e3-446f-8953-b0893810ebe7/installation/providers/docker-v2-compose-yaml -r demorealm > keycloak-docker-compose-yaml.zip Updating a client Use the update command with the same endpoint URI that you used to get a specific client. For example, on: Linux: $ kcadm.sh update clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm -s enabled=false -s publicClient=true -s 'redirectUris=[\"http://localhost:8080/myapp/*\"]' -s baseUrl=http://localhost:8080/myapp -s adminUrl=http://localhost:8080/myapp Windows: c:\\> kcadm update clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm -s enabled=false -s publicClient=true -s \"redirectUris=[\\\"http://localhost:8080/myapp/*\\\"]\" -s baseUrl=http://localhost:8080/myapp -s adminUrl=http://localhost:8080/myapp Deleting a client Use the delete command with the same endpoint URI that you used to get a specific client. For example: $ kcadm.sh delete clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm Adding or removing roles for client’s service account Service account for the client is just a special kind of user account with username service-account-CLIENT_ID. You can perform user operations on this account as if it was a regular user. 19.9. User operations Creating a user Run the create command on the users endpoint to create a new user. For example: $ kcadm.sh create users -r demorealm -s username=testuser -s enabled=true Listing users Use the users endpoint to list users. The target user will have to change the password the next time they log in. For example: $ kcadm.sh get users -r demorealm --offset 0 --limit 1000 You can filter users by username, firstName, lastName, or email. For example: $ kcadm.sh get users -r demorealm -q email=google.com $ kcadm.sh get users -r demorealm -q username=testuser Filtering does not use exact matching. For example, the above example would match the value of the username attribute against the *testuser* pattern. You can also filter across multiple attributes by specifying multiple -q options, which return only users that match the condition for all the attributes. Getting a specific user Use a user’s ID to compose an endpoint URI, such as users/USER_ID. For example: $ kcadm.sh get users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm Updating a user Use the update command with the same endpoint URI that you used to get a specific user. For example, on: Linux: $ kcadm.sh update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm -s 'requiredActions=[\"VERIFY_EMAIL\",\"UPDATE_PROFILE\",\"CONFIGURE_TOTP\",\"UPDATE_PASSWORD\"]' Windows: c:\\> kcadm update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm -s \"requiredActions=[\\\"VERIFY_EMAIL\\\",\\\"UPDATE_PROFILE\\\",\\\"CONFIGURE_TOTP\\\",\\\"UPDATE_PASSWORD\\\"]\" Deleting a user Use the delete command with the same endpoint URI that you used to get a specific user. For example: $ kcadm.sh delete users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm Resetting a user’s password Use the dedicated set-password command to reset a user’s password. For example: $ kcadm.sh set-password -r demorealm --username testuser --new-password NEWPASSWORD --temporary That command sets a temporary password for the user. The target user will have to change the password the next time they log in. You can use --userid if you want to specify the user by using the id attribute. You can achieve the same result using the update command on an endpoint constructed from the one you used to get a specific user, such as users/USER_ID/reset-password. For example: $ kcadm.sh update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2/reset-password -r demorealm -s type=password -s value=NEWPASSWORD -s temporary=true -n The last parameter (-n) ensures that only the PUT command is performed without a prior GET command. It is necessary in this instance because the reset-password endpoint does not support GET. Listing assigned, available, and effective realm roles for a user You can use a dedicated get-roles command to list assigned, available, and effective realm roles for a user. Specify the target user by either user name or ID to list assigned realm roles for the user. For example: $ kcadm.sh get-roles -r demorealm --uusername testuser Use the additional --effective option to list effective realm roles. For example: $ kcadm.sh get-roles -r demorealm --uusername testuser --effective Use the --available option to list realm roles that can still be added to the user. For example: $ kcadm.sh get-roles -r demorealm --uusername testuser --available Listing assigned, available, and effective client roles for a user Use a dedicated get-roles command to list assigned, available, and effective client roles for a user. Specify the target user by either a user name (via the --uusername option) or an ID (via the --uid option) and client by either a clientId attribute (via the --cclientid option) or an ID (via the --cid option) to list assigned client roles for the user. For example: $ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-management Use the additional --effective option to list effective realm roles. For example: $ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-management --effective Use the --available option to list realm roles that can still be added to the user. For example: $ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-management --available Adding realm roles to a user Use a dedicated add-roles command to add realm roles to a user. Use the following example to add the user role to user testuser. $ kcadm.sh add-roles --uusername testuser --rolename user -r demorealm Removing realm roles from a user Use a dedicated remove-roles command to remove realm roles from a user. Use the following example to remove the user role from the user testuser. $ kcadm.sh remove-roles --uusername testuser --rolename user -r demorealm Adding client roles to a user Use a dedicated add-roles command to add client roles to a user. Use the following example to add two roles defined on the client realm management - create-client role and the view-users role to the user testuser. $ kcadm.sh add-roles -r demorealm --uusername testuser --cclientid realm-management --rolename create-client --rolename view-users Removing client roles from a user Use a dedicated remove-roles command to remove client roles from a user. Use the following example to remove two roles defined on the realm management client. $ kcadm.sh remove-roles -r demorealm --uusername testuser --cclientid realm-management --rolename create-client --rolename view-users Listing a user’s sessions Identify the user’s ID, and then use it to compose an endpoint URI, such as users/ID/sessions. Use the get command to retrieve a list of the user’s sessions. For example: $kcadm get users/6da5ab89-3397-4205-afaa-e201ff638f9e/sessions Logging out a user from a specific session Determine the session’s ID as described above. Use the session’s ID to compose an endpoint URI, such as sessions/ID. Use the delete command to invalidate the session. For example: $ kcadm.sh delete sessions/d0eaa7cc-8c5d-489d-811a-69d3c4ec84d1 Logging out a user from all sessions You need a user’s ID to construct an endpoint URI, such as users/ID/logout. Use the create command to perform POST on that endpoint URI. For example: $ kcadm.sh create users/6da5ab89-3397-4205-afaa-e201ff638f9e/logout -r demorealm -s realm=demorealm -s user=6da5ab89-3397-4205-afaa-e201ff638f9e 19.10. Group operations Creating a group Use the create command on the groups endpoint to create a new group. For example: $ kcadm.sh create groups -r demorealm -s name=Group Listing groups Use the get command on the groups endpoint to list groups. For example: $ kcadm.sh get groups -r demorealm Getting a specific group Use the group’s ID to construct an endpoint URI, such as groups/GROUP_ID. For example: $ kcadm.sh get groups/51204821-0580-46db-8f2d-27106c6b5ded -r demorealm Updating a group Use the update command with the same endpoint URI that you used to get a specific group. For example: $ kcadm.sh update groups/51204821-0580-46db-8f2d-27106c6b5ded -s 'attributes.email=[\"group@example.com\"]' -r demorealm Deleting a group Use the delete command with the same endpoint URI that you used to get a specific group. For example: $ kcadm.sh delete groups/51204821-0580-46db-8f2d-27106c6b5ded -r demorealm Creating a subgroup Find the ID of the parent group by listing groups, and then use that ID to construct an endpoint URI, such as groups/GROUP_ID/children. For example: $ kcadm.sh create groups/51204821-0580-46db-8f2d-27106c6b5ded/children -r demorealm -s name=SubGroup Moving a group under another group Find the ID of an existing parent group and of an existing child group. Use the parent group’s ID to construct an endpoint URI, such as groups/PARENT_GROUP_ID/children. Run the create command on this endpoint and pass the child group’s ID as a JSON body. For example: $ kcadm.sh create groups/51204821-0580-46db-8f2d-27106c6b5ded/children -r demorealm -s id=08d410c6-d585-4059-bb07-54dcb92c5094 Get groups for a specific user Use a user’s ID to determine a user’s membership in groups to compose an endpoint URI, such as users/USER_ID/groups. For example: $ kcadm.sh get users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups -r demorealm Adding a user to a group Use the update command with an endpoint URI composed from user’s ID and a group’s ID, such as users/USER_ID/groups/GROUP_ID, to add a user to a group. For example: $ kcadm.sh update users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups/ce01117a-7426-4670-a29a-5c118056fe20 -r demorealm -s realm=demorealm -s userId=b544f379-5fc4-49e5-8a8d-5cfb71f46f53 -s groupId=ce01117a-7426-4670-a29a-5c118056fe20 -n Removing a user from a group Use the delete command on the same endpoint URI as used for adding a user to a group, such as users/USER_ID/groups/GROUP_ID, to remove a user from a group. For example: $ kcadm.sh delete users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups/ce01117a-7426-4670-a29a-5c118056fe20 -r demorealm Listing assigned, available, and effective realm roles for a group Use a dedicated get-roles command to list assigned, available, and effective realm roles for a group. Specify the target group by name (via the --gname option), path (via the [command] --gpath option), or ID (via the --gid option) to list assigned realm roles for the group. For example: $ kcadm.sh get-roles -r demorealm --gname Group Use the additional --effective option to list effective realm roles. For example: $ kcadm.sh get-roles -r demorealm --gname Group --effective Use the --available option to list realm roles that can still be added to the group. For example: $ kcadm.sh get-roles -r demorealm --gname Group --available Listing assigned, available, and effective client roles for a group Use a dedicated get-roles command to list assigned, available, and effective client roles for a group. Specify the target group by either name (via the --gname option) or ID (via the --gid option), and client by either the clientId attribute (via the [command] --cclientid option) or ID (via the --id option) to list assigned client roles for the user. For example: $ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management Use the additional --effective option to list effective realm roles. For example: $ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management --effective Use the --available option to list realm roles that can still be added to the group. For example: $ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management --available 19.11. Identity provider operations Listing available identity providers Use the serverinfo endpoint to list available identity providers. For example: $ kcadm.sh get serverinfo -r demorealm --fields 'identityProviders(*)' The serverinfo endpoint is handled similarly to the realms endpoint in that it is not resolved relative to a target realm because it exists outside any specific realm. Listing configured identity providers Use the identity-provider/instances endpoint. For example: $ kcadm.sh get identity-provider/instances -r demorealm --fields alias,providerId,enabled Getting a specific configured identity provider Use the alias attribute of the identity provider to construct an endpoint URI, such as identity-provider/instances/ALIAS, to get a specific identity provider. For example: $ kcadm.sh get identity-provider/instances/facebook -r demorealm Removing a specific configured identity provider Use the delete command with the same endpoint URI that you used to get a specific configured identity provider to remove a specific configured identity provider. For example: $ kcadm.sh delete identity-provider/instances/facebook -r demorealm Configuring a Keycloak OpenID Connect identity provider Use keycloak-oidc as the providerId when creating a new identity provider instance. Provide the config attributes: authorizationUrl, tokenUrl, clientId, and clientSecret. For example: $ kcadm.sh create identity-provider/instances -r demorealm -s alias=keycloak-oidc -s providerId=keycloak-oidc -s enabled=true -s 'config.useJwksUrl=\"true\"' -s config.authorizationUrl=http://localhost:8180/auth/realms/demorealm/protocol/openid-connect/auth -s config.tokenUrl=http://localhost:8180/auth/realms/demorealm/protocol/openid-connect/token -s config.clientId=demo-oidc-provider -s config.clientSecret=secret Configuring an OpenID Connect identity provider Configure the generic OpenID Connect provider the same way you configure the Keycloak OpenID Connect provider, except that you set the providerId attribute value to oidc. Configuring a SAML 2 identity provider Use saml as the providerId. Provide the config attributes: singleSignOnServiceUrl, nameIDPolicyFormat, and signatureAlgorithm. For example: $ kcadm.sh create identity-provider/instances -r demorealm -s alias=saml -s providerId=saml -s enabled=true -s 'config.useJwksUrl=\"true\"' -s config.singleSignOnServiceUrl=http://localhost:8180/auth/realms/saml-broker-realm/protocol/saml -s config.nameIDPolicyFormat=urn:oasis:names:tc:SAML:2.0:nameid-format:persistent -s config.signatureAlgorithm=RSA_SHA256 Configuring a Facebook identity provider Use facebook as the providerId. Provide the config attributes: clientId and clientSecret. You can find these attributes in the Facebook Developers application configuration page for your application. For example: $ kcadm.sh create identity-provider/instances -r demorealm -s alias=facebook -s providerId=facebook -s enabled=true -s 'config.useJwksUrl=\"true\"' -s config.clientId=FACEBOOK_CLIENT_ID -s config.clientSecret=FACEBOOK_CLIENT_SECRET Configuring a Google identity provider Use google as the providerId. Provide the config attributes: clientId and clientSecret. You can find these attributes in the Google Developers application configuration page for your application. For example: $ kcadm.sh create identity-provider/instances -r demorealm -s alias=google -s providerId=google -s enabled=true -s 'config.useJwksUrl=\"true\"' -s config.clientId=GOOGLE_CLIENT_ID -s config.clientSecret=GOOGLE_CLIENT_SECRET Configuring a Twitter identity provider Use twitter as the providerId. Provide the config attributes clientId and clientSecret. You can find these attributes in the Twitter Application Management application configuration page for your application. For example: $ kcadm.sh create identity-provider/instances -r demorealm -s alias=google -s providerId=google -s enabled=true -s 'config.useJwksUrl=\"true\"' -s config.clientId=TWITTER_API_KEY -s config.clientSecret=TWITTER_API_SECRET Configuring a GitHub identity provider Use github as the providerId. Provide the config attributes clientId and clientSecret. You can find these attributes in the GitHub Developer Application Settings page for your application. For example: $ kcadm.sh create identity-provider/instances -r demorealm -s alias=github -s providerId=github -s enabled=true -s 'config.useJwksUrl=\"true\"' -s config.clientId=GITHUB_CLIENT_ID -s config.clientSecret=GITHUB_CLIENT_SECRET Configuring a LinkedIn identity provider Use linkedin as the providerId. Provide the config attributes clientId and clientSecret. You can find these attributes in the LinkedIn Developer Console application page for your application. For example: $ kcadm.sh create identity-provider/instances -r demorealm -s alias=linkedin -s providerId=linkedin -s enabled=true -s 'config.useJwksUrl=\"true\"' -s config.clientId=LINKEDIN_CLIENT_ID -s config.clientSecret=LINKEDIN_CLIENT_SECRET Configuring a Microsoft Live identity provider Use microsoft as the providerId. Provide the config attributes clientId and clientSecret. You can find these attributes in the Microsoft Application Registration Portal page for your application. For example: $ kcadm.sh create identity-provider/instances -r demorealm -s alias=microsoft -s providerId=microsoft -s enabled=true -s 'config.useJwksUrl=\"true\"' -s config.clientId=MICROSOFT_APP_ID -s config.clientSecret=MICROSOFT_PASSWORD Configuring a Stack Overflow identity provider Use stackoverflow command as the providerId. Provide the config attributes clientId, clientSecret, and key. You can find these attributes in the Stack Apps OAuth page for your application. For example: $ kcadm.sh create identity-provider/instances -r demorealm -s alias=stackoverflow -s providerId=stackoverflow -s enabled=true -s 'config.useJwksUrl=\"true\"' -s config.clientId=STACKAPPS_CLIENT_ID -s config.clientSecret=STACKAPPS_CLIENT_SECRET -s config.key=STACKAPPS_KEY 19.12. Storage provider operations Configuring a Kerberos storage provider Use the create command against the components endpoint. Specify realm id as a value of the parentId attribute. Specify kerberos as the value of the providerId attribute, and org.keycloak.storage.UserStorageProvider as the value of the providerType attribute. For example: $ kcadm.sh create components -r demorealm -s parentId=demorealmId -s id=demokerberos -s name=demokerberos -s providerId=kerberos -s providerType=org.keycloak.storage.UserStorageProvider -s 'config.priority=[\"0\"]' -s 'config.debug=[\"false\"]' -s 'config.allowPasswordAuthentication=[\"true\"]' -s 'config.editMode=[\"UNSYNCED\"]' -s 'config.updateProfileFirstLogin=[\"true\"]' -s 'config.allowKerberosAuthentication=[\"true\"]' -s 'config.kerberosRealm=[\"KEYCLOAK.ORG\"]' -s 'config.keyTab=[\"http.keytab\"]' -s 'config.serverPrincipal=[\"HTTP/localhost@KEYCLOAK.ORG\"]' -s 'config.cachePolicy=[\"DEFAULT\"]' Configuring an LDAP user storage provider Use the create command against the components endpoint. Specify ldap as a value of the providerId attribute, and org.keycloak.storage.UserStorageProvider as the value of the providerType attribute. Provide the realm ID as the value of the parentId attribute. Use the following example to create a Kerberos-integrated LDAP provider. $ kcadm.sh create components -r demorealm -s name=kerberos-ldap-provider -s providerId=ldap -s providerType=org.keycloak.storage.UserStorageProvider -s parentId=3d9c572b-8f33-483f-98a6-8bb421667867 -s 'config.priority=[\"1\"]' -s 'config.fullSyncPeriod=[\"-1\"]' -s 'config.changedSyncPeriod=[\"-1\"]' -s 'config.cachePolicy=[\"DEFAULT\"]' -s config.evictionDay=[] -s config.evictionHour=[] -s config.evictionMinute=[] -s config.maxLifespan=[] -s 'config.batchSizeForSync=[\"1000\"]' -s 'config.editMode=[\"WRITABLE\"]' -s 'config.syncRegistrations=[\"false\"]' -s 'config.vendor=[\"other\"]' -s 'config.usernameLDAPAttribute=[\"uid\"]' -s 'config.rdnLDAPAttribute=[\"uid\"]' -s 'config.uuidLDAPAttribute=[\"entryUUID\"]' -s 'config.userObjectClasses=[\"inetOrgPerson, organizationalPerson\"]' -s 'config.connectionUrl=[\"ldap://localhost:10389\"]' -s 'config.usersDn=[\"ou=People,dc=keycloak,dc=org\"]' -s 'config.authType=[\"simple\"]' -s 'config.bindDn=[\"uid=admin,ou=system\"]' -s 'config.bindCredential=[\"secret\"]' -s 'config.searchScope=[\"1\"]' -s 'config.useTruststoreSpi=[\"ldapsOnly\"]' -s 'config.connectionPooling=[\"true\"]' -s 'config.pagination=[\"true\"]' -s 'config.allowKerberosAuthentication=[\"true\"]' -s 'config.serverPrincipal=[\"HTTP/localhost@KEYCLOAK.ORG\"]' -s 'config.keyTab=[\"http.keytab\"]' -s 'config.kerberosRealm=[\"KEYCLOAK.ORG\"]' -s 'config.debug=[\"true\"]' -s 'config.useKerberosForPasswordAuthentication=[\"true\"]' Removing a user storage provider instance Use the storage provider instance’s id attribute to compose an endpoint URI, such as components/ID. Run the delete command against this endpoint. For example: $ kcadm.sh delete components/3d9c572b-8f33-483f-98a6-8bb421667867 -r demorealm Triggering synchronization of all users for a specific user storage provider Use the storage provider’s id attribute to compose an endpoint URI, such as user-storage/ID_OF_USER_STORAGE_INSTANCE/sync. Add the action=triggerFullSync query parameter and run the create command. For example: $ kcadm.sh create user-storage/b7c63d02-b62a-4fc1-977c-947d6a09e1ea/sync?action=triggerFullSync Triggering synchronization of changed users for a specific user storage provider Use the storage provider’s id attribute to compose an endpoint URI, such as user-storage/ID_OF_USER_STORAGE_INSTANCE/sync. Add the action=triggerChangedUsersSync query parameter and run the create command. For example: $ kcadm.sh create user-storage/b7c63d02-b62a-4fc1-977c-947d6a09e1ea/sync?action=triggerChangedUsersSync Test LDAP user storage connectivity Run the get command on the testLDAPConnection endpoint. Provide query parameters bindCredential, bindDn, connectionUrl, and useTruststoreSpi, and then set the action query parameter to testConnection. For example: $ kcadm.sh get testLDAPConnection -q action=testConnection -q bindCredential=secret -q bindDn=uid=admin,ou=system -q connectionUrl=ldap://localhost:10389 -q useTruststoreSpi=ldapsOnly Test LDAP user storage authentication Run the get command on the testLDAPConnection endpoint. Provide the query parameters bindCredential, bindDn, connectionUrl, and useTruststoreSpi, and then set the action query parameter to testAuthentication. For example: $ kcadm.sh get testLDAPConnection -q action=testAuthentication -q bindCredential=secret -q bindDn=uid=admin,ou=system -q connectionUrl=ldap://localhost:10389 -q useTruststoreSpi=ldapsOnly 19.13. Adding mappers Adding a hardcoded role LDAP mapper Run the create command on the components endpoint. Set the providerType attribute to org.keycloak.storage.ldap.mappers.LDAPStorageMapper. Set the parentId attribute to the ID of the LDAP provider instance. Set the providerId attribute to hardcoded-ldap-role-mapper. Make sure to provide a value of role configuration parameter. For example: $ kcadm.sh create components -r demorealm -s name=hardcoded-ldap-role-mapper -s providerId=hardcoded-ldap-role-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config.role=[\"realm-management.create-client\"]' Adding an MS Active Directory mapper Run the create command on the components endpoint. Set the providerType attribute to org.keycloak.storage.ldap.mappers.LDAPStorageMapper. Set the parentId attribute to the ID of the LDAP provider instance. Set the providerId attribute to msad-user-account-control-mapper. For example: $ kcadm.sh create components -r demorealm -s name=msad-user-account-control-mapper -s providerId=msad-user-account-control-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea Adding a user attribute LDAP mapper Run the create command on the components endpoint. Set the providerType attribute to org.keycloak.storage.ldap.mappers.LDAPStorageMapper. Set the parentId attribute to the ID of the LDAP provider instance. Set the providerId attribute to user-attribute-ldap-mapper. For example: $ kcadm.sh create components -r demorealm -s name=user-attribute-ldap-mapper -s providerId=user-attribute-ldap-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config.\"user.model.attribute\"=[\"email\"]' -s 'config.\"ldap.attribute\"=[\"mail\"]' -s 'config.\"read.only\"=[\"false\"]' -s 'config.\"always.read.value.from.ldap\"=[\"false\"]' -s 'config.\"is.mandatory.in.ldap\"=[\"false\"]' Adding a group LDAP mapper Run the create command on the components endpoint. Set the providerType attribute to org.keycloak.storage.ldap.mappers.LDAPStorageMapper. Set the parentId attribute to the ID of the LDAP provider instance. Set the providerId attribute to group-ldap-mapper. For example: $ kcadm.sh create components -r demorealm -s name=group-ldap-mapper -s providerId=group-ldap-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config.\"groups.dn\"=[]' -s 'config.\"group.name.ldap.attribute\"=[\"cn\"]' -s 'config.\"group.object.classes\"=[\"groupOfNames\"]' -s 'config.\"preserve.group.inheritance\"=[\"true\"]' -s 'config.\"membership.ldap.attribute\"=[\"member\"]' -s 'config.\"membership.attribute.type\"=[\"DN\"]' -s 'config.\"groups.ldap.filter\"=[]' -s 'config.mode=[\"LDAP_ONLY\"]' -s 'config.\"user.roles.retrieve.strategy\"=[\"LOAD_GROUPS_BY_MEMBER_ATTRIBUTE\"]' -s 'config.\"mapped.group.attributes\"=[\"admins-group\"]' -s 'config.\"drop.non.existing.groups.during.sync\"=[\"false\"]' -s 'config.roles=[\"admins\"]' -s 'config.groups=[\"admins-group\"]' -s 'config.group=[]' -s 'config.preserve=[\"true\"]' -s 'config.membership=[\"member\"]' Adding a full name LDAP mapper Run the create command on the components endpoint. Set the providerType attribute to org.keycloak.storage.ldap.mappers.LDAPStorageMapper. Set the parentId attribute to the ID of the LDAP provider instance. Set the providerId attribute to full-name-ldap-mapper. For example: $ kcadm.sh create components -r demorealm -s name=full-name-ldap-mapper -s providerId=full-name-ldap-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config.\"ldap.full.name.attribute\"=[\"cn\"]' -s 'config.\"read.only\"=[\"false\"]' -s 'config.\"write.only\"=[\"true\"]' 19.14. Authentication operations Setting a password policy Set the realm’s passwordPolicy attribute to an enumeration expression that includes the specific policy provider ID and optional configuration. Use the following example to set a password policy to default values. The default values include: 27,500 hashing iterations at least one special character at least one uppercase character at least one digit character not be equal to a user’s username be at least eight characters long $ kcadm.sh update realms/demorealm -s 'passwordPolicy=\"hashIterations and specialChars and upperCase and digits and notUsername and length\"' If you want to use values different from defaults, pass the configuration in brackets. Use the following example to set a password policy to: 25,000 hash iterations at least two special characters at least two uppercase characters at least two lowercase characters at least two digits be at least nine characters long not be equal to a user’s username not repeat for at least four changes back $ kcadm.sh update realms/demorealm -s 'passwordPolicy=\"hashIterations(25000) and specialChars(2) and upperCase(2) and lowerCase(2) and digits(2) and length(9) and notUsername and passwordHistory(4)\"' Getting the current password policy Get the current realm configuration and filter everything but the passwordPolicy attribute. Use the following example to display passwordPolicy for demorealm. $ kcadm.sh get realms/demorealm --fields passwordPolicy Listing authentication flows Run the get command on the authentication/flows endpoint. For example: $ kcadm.sh get authentication/flows -r demorealm Getting a specific authentication flow Run the get command on the authentication/flows/FLOW_ID endpoint. For example: $ kcadm.sh get authentication/flows/febfd772-e1a1-42fb-b8ae-00c0566fafb8 -r demorealm Listing executions for a flow Run the get command on the authentication/flows/FLOW_ALIAS/executions endpoint. For example: $ kcadm.sh get authentication/flows/Copy%20of%20browser/executions -r demorealm Adding configuration to an execution Get execution for a flow, and take note of its ID Run the create command on the authentication/executions/{executionId}/config endpoint. For example: $ kcadm create \"authentication/executions/a3147129-c402-4760-86d9-3f2345e401c7/config\" -r examplerealm -b '{\"config\":{\"x509-cert-auth.mapping-source-selection\":\"Match SubjectDN using regular expression\",\"x509-cert-auth.regular-expression\":\"(.*?)(?:$)\",\"x509-cert-auth.mapper-selection\":\"Custom Attribute Mapper\",\"x509-cert-auth.mapper-selection.user-attribute-name\":\"usercertificate\",\"x509-cert-auth.crl-checking-enabled\":\"\",\"x509-cert-auth.crldp-checking-enabled\":false,\"x509-cert-auth.crl-relative-path\":\"crl.pem\",\"x509-cert-auth.ocsp-checking-enabled\":\"\",\"x509-cert-auth.ocsp-responder-uri\":\"\",\"x509-cert-auth.keyusage\":\"\",\"x509-cert-auth.extendedkeyusage\":\"\",\"x509-cert-auth.confirmation-page-disallowed\":\"\"},\"alias\":\"my_otp_config\"}' Getting configuration for an execution Get execution for a flow, and get its authenticationConfig attribute, containing the config ID. Run the get command on the authentication/config/ID endpoint. For example: $ kcadm get \"authentication/config/dd91611a-d25c-421a-87e2-227c18421833\" -r examplerealm Updating configuration for an execution Get execution for a flow, and get its authenticationConfig attribute, containing the config ID. Run the update command on the authentication/config/ID endpoint. For example: $ kcadm update \"authentication/config/dd91611a-d25c-421a-87e2-227c18421833\" -r examplerealm -b '{\"id\":\"dd91611a-d25c-421a-87e2-227c18421833\",\"alias\":\"my_otp_config\",\"config\":{\"x509-cert-auth.extendedkeyusage\":\"\",\"x509-cert-auth.mapper-selection.user-attribute-name\":\"usercertificate\",\"x509-cert-auth.ocsp-responder-uri\":\"\",\"x509-cert-auth.regular-expression\":\"(.*?)(?:$)\",\"x509-cert-auth.crl-checking-enabled\":\"true\",\"x509-cert-auth.confirmation-page-disallowed\":\"\",\"x509-cert-auth.keyusage\":\"\",\"x509-cert-auth.mapper-selection\":\"Custom Attribute Mapper\",\"x509-cert-auth.crl-relative-path\":\"crl.pem\",\"x509-cert-auth.crldp-checking-enabled\":\"false\",\"x509-cert-auth.mapping-source-selection\":\"Match SubjectDN using regular expression\",\"x509-cert-auth.ocsp-checking-enabled\":\"\"}}' Deleting configuration for an execution Get execution for a flow, and get its authenticationConfig attribute, containing the config ID. Run the delete command on the authentication/config/ID endpoint. For example: $ kcadm delete \"authentication/config/dd91611a-d25c-421a-87e2-227c18421833\" -r examplerealm Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-01-04 20:08:20 "}}